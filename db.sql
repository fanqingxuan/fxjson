-- MySQL dump 10.13  Distrib 5.7.26, for Linux (x86_64)
--
-- Host: localhost    Database: jsonblog
-- ------------------------------------------------------
-- Server version	5.7.26-log

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `tbl_comments`
--

DROP TABLE IF EXISTS `tbl_comments`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tbl_comments` (
  `coid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `cid` int(10) unsigned DEFAULT '0',
  `created` int(10) unsigned DEFAULT '0',
  `author` varchar(200) DEFAULT NULL,
  `authorId` int(10) unsigned DEFAULT '0',
  `ownerId` int(10) unsigned DEFAULT '0',
  `mail` varchar(200) DEFAULT NULL,
  `url` varchar(200) DEFAULT NULL,
  `ip` varchar(64) DEFAULT NULL,
  `agent` varchar(200) DEFAULT NULL,
  `text` text,
  `type` varchar(16) DEFAULT 'comment',
  `status` varchar(16) DEFAULT 'approved',
  `parent` int(10) unsigned DEFAULT '0',
  PRIMARY KEY (`coid`),
  KEY `cid` (`cid`),
  KEY `created` (`created`)
) ENGINE=MyISAM AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tbl_comments`
--

LOCK TABLES `tbl_comments` WRITE;
/*!40000 ALTER TABLE `tbl_comments` DISABLE KEYS */;
INSERT INTO `tbl_comments` VALUES (3,20,1594996510,'心灵博客',0,1,'xylx@mail.blog.dngz.net','http://blog.dngz.net/','112.96.173.202','Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.80 Safari/537.36','吃过strpos = 的亏，后来总算记住了要===或!==','comment','approved',0),(5,75,1608989228,'doctorwu',0,2,'123@qq.com','http://doctorwu.io/','112.37.122.220','Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36','赞一个','comment','approved',0);
/*!40000 ALTER TABLE `tbl_comments` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tbl_contents`
--

DROP TABLE IF EXISTS `tbl_contents`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tbl_contents` (
  `cid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(200) DEFAULT NULL,
  `slug` varchar(200) DEFAULT NULL,
  `created` int(10) unsigned DEFAULT '0',
  `modified` int(10) unsigned DEFAULT '0',
  `text` longtext,
  `order` int(10) unsigned DEFAULT '0',
  `authorId` int(10) unsigned DEFAULT '0',
  `template` varchar(32) DEFAULT NULL,
  `type` varchar(16) DEFAULT 'post',
  `status` varchar(16) DEFAULT 'publish',
  `password` varchar(32) DEFAULT NULL,
  `commentsNum` int(10) unsigned DEFAULT '0',
  `allowComment` char(1) DEFAULT '0',
  `allowPing` char(1) DEFAULT '0',
  `allowFeed` char(1) DEFAULT '0',
  `parent` int(10) unsigned DEFAULT '0',
  `views` int(10) DEFAULT '0',
  `is_recommend` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否推荐文章',
  PRIMARY KEY (`cid`),
  UNIQUE KEY `slug` (`slug`),
  KEY `created` (`created`),
  KEY `modified` (`modified`)
) ENGINE=MyISAM AUTO_INCREMENT=126 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tbl_contents`
--

LOCK TABLES `tbl_contents` WRITE;
/*!40000 ALTER TABLE `tbl_contents` DISABLE KEYS */;
INSERT INTO `tbl_contents` VALUES (1,'phalcon的php版本依赖注入容器','start',1591518480,1591526930,'<!--markdown-->### 环境要求\r\n**php7.0+**\r\n\r\n### 安装\r\n\r\n```php+HTML\r\ncomposer require fanqingxuan/di \r\n```\r\n如果你想安装php扩展版本的容器，可参考**[di-ext](https://github.com/fanqingxuan/di-ext)**，用法跟这个一模一样\r\n\r\n### 基本用法\r\n\r\n```php\r\nrequire_once \'vendor/autoload.php\';\r\n\r\nuse JsonDi\\Di;\r\n\r\nclass Test\r\n{\r\n}\r\n\r\n$di = new Di;\r\n//注入的方式\r\n$di->set(\'test\', \'Test\');\r\n$di->set(\"test2\", function () {\r\n    return new Test;\r\n});\r\n$di->set(\"test3\", Test::class);\r\n$di->set(\'test4\', new Test);\r\n\r\n```\r\n你可以看到，有以下几种方式注入容器\r\n\r\n- 字符串 \r\n\r\n```php\r\n$di->set(\'test\',\'Test\');\r\n$di->set(\"test3\",Test::class);\r\n```\r\n\r\n- 实例对象\r\n\r\n```php\r\n$di->set(\'test5\',new Test);\r\n```\r\n\r\n- 闭包/匿名函数\r\n\r\n```php\r\n$di->set(\"test2\",function() {\r\nreturn new Test;\r\n});\r\n```\r\n你也可以给匿名函数传递额外的参数\r\n\r\n```php\r\nrequire_once \'vendor/autoload.php\';\r\n\r\nuse JsonDi\\Di;\r\nuse JsonDi\\Config;\r\n$di = new Di;\r\n$di->set(\'config\',new Config(\r\n    [\r\n        \'database\'  =>  [\r\n            \'host\'      =>  \'localhost\',\r\n            \'username\'  =>  \'root\',\r\n            \'password\'  =>  \'111111\'\r\n        ]\r\n    ]\r\n));\r\nclass MysqlDb\r\n{\r\n    public function __construct($config) \r\n    {\r\n        print_r($config);\r\n    }\r\n}\r\n$di->set(\'db\',function () {\r\n    return new MysqlDb($this->get(\'config\')->database);//get the database config from container\r\n});\r\n```\r\n\r\n你也可以使用use关键字实现\r\n\r\n```php\r\n$config = [\r\n    \'host\'      =>  \'localhost\',\r\n    \'username\'  =>  \'root\',\r\n    \'password\'  =>  \'111111\'\r\n];\r\n$di->set(\'db\',function () use ($config) {\r\n    return new MysqlDb($config);\r\n});\r\n```\r\n\r\n### 高级用法\r\n\r\n- #### 构造函数注入\r\n\r\n这种注入类型可以给构造函数注入参数\r\n  ```php\r\n  class UserService \r\n  {\r\n      protected $userDao;\r\n      protected $userType;\r\n      \r\n      public function __construct(UserDao $userDao,$userType) \r\n      {\r\n          $this->userDao  = $userDao;\r\n          $this->userType = $userType;\r\n      }\r\n  }\r\n  ```\r\n\r\n  通过下面的方式注入\r\n\r\n  ```php\r\n  $di->set(\r\n      \'userDao\',\r\n      [\r\n  		\'className\'	=>	UserDao::class\r\n      ]\r\n  );\r\n  $di->set(\r\n  	\'userService\',\r\n      [\r\n          \'className\'	=>	UserService::class,\r\n          \'arguments\'	=>	[\r\n              [\r\n                  \'type\'	=>	\'service\',\r\n                  \'name\'	=>	\'userDao\',//another service name in the container\r\n              ],\r\n              [\r\n                  \'type\'	=>	\'parameter\',\r\n                  \'value\'	=>	3\r\n              ]\r\n          ]\r\n      ]\r\n  );\r\n  ```\r\n\r\n- #### setter方式注入\r\n\r\n```php \r\nclass UserService \r\n{\r\n    protected $userDao;\r\n    protected $userType;\r\n    \r\n    public function setUserDao(UserDao $userDao) \r\n    {\r\n        $this->userDao = $userDao;\r\n    }\r\n    \r\n    public function setUserType($userType) \r\n    {\r\n        $this->userType = $userType;\r\n    }\r\n}\r\n```\r\n\r\n通过下面的方式给setter注入参数\r\n```php\r\n$di->set(\r\n    \'userService\',\r\n    [\r\n        \'className\'	=>	\'UserService\',\r\n        \'calls\'		=>	[\r\n            [\r\n                \'method\'	=>	\'setUserDao\',\r\n                \'arguments\'	=>	[\r\n                    [\r\n                        \'type\'	=>	\'service\',\r\n                    	\'name\'	=>	\'userDao\',\r\n                    ]\r\n                ]\r\n            ],\r\n            [\r\n                \'method\'	=>	\'setUserType\',\r\n                \'arguments\'	=>	[\r\n                    [\r\n                        \'type\'	=>	\'parameter\',\r\n                    	\'value\'	=>	3\r\n                    ]\r\n                ]\r\n            ]\r\n        ]\r\n    ]\r\n);\r\n```\r\n\r\n- #### 属性注入\r\n\r\n给public的属性注入参数\r\n\r\n```php\r\nclass UserService \r\n{\r\n    public $userDao;\r\n    public $userType;\r\n    public $tempObj;\r\n}\r\n```\r\n\r\n```php\r\n$di->set(\r\n	\'userService\',\r\n    [\r\n        \'className\'	=>	UserService::class,\r\n        \'properties\'=>[\r\n            [\r\n                \'name\'	=>	\'userDao\',\r\n                \'value\'	=>	[\r\n                    \'type\'	=>	\'service\',\r\n                    \'name\'	=>	\'userDao\',//service name in the container\r\n                ]\r\n            ],\r\n            [\r\n                \'name\'	=>	\'userType\',\r\n                \'value\'	=>	[\r\n                    \'type\'	=>	\'parameter\',\r\n                    \'value\'	=>	2,\r\n                ]\r\n            ],\r\n            [\r\n                \'name\'	=>	\'tempObj\',\r\n                \'value\'	=>	[\r\n                    \'type\'	=>	\'instance\',\r\n                    \'className\'	=>	\'StdClass\',\r\n                    \'arguments\'	=>	[]\r\n                ]\r\n            ]\r\n        ]\r\n    ]\r\n);\r\n```\r\n\r\n### 更多高级用法\r\n\r\n下面是通过php文件注入\r\n\r\n```php\r\n//service.php\r\n<?php\r\nreturn [\r\n    \'testA\' => [\r\n        \'className\' => Test::class,\r\n        \'shared\'    => true,\r\n    ],\r\n];\r\n```\r\n\r\n通过如下的方式注入\r\n```php\r\nrequire_once \'vendor/autoload.php\';\r\n\r\nuse Json/Config;\r\n\r\n$di = new Di;\r\n$di->loadFromPhp(\'service.php\');\r\n```\r\n\r\n### 数组方式注入\r\n\r\n上面我们介绍了使用set函数注入的方式，事实上，也可以使用数组key-value方式注入\r\n```php\r\n$di[\'db\'] = new StdClass;\r\n$di[\'db\'] = function() {\r\n    return new StdClass;\r\n}\r\n$di[\'db\'] = \'StdClass\';\r\n$di[\'db\'] = [\r\n    \'className\'	=>	\'StdClass\'\r\n]\r\n```\r\n\r\n### 属性方式注入\r\n\r\n可以使用实例属性方式注入，本质上是容器实现了__set,__get魔术方法\r\n```php\r\n$di->db = new StdClass;\r\n$di->db = function() {\r\n    return new StdClass;\r\n}\r\n$di->db = StdClass::class;\r\n$di->db = [\r\n    \'className\'	=>	\'stdClass\'\r\n];\r\n```\r\n\r\n\r\n\r\n### 获取服务\r\n\r\n- get方法\r\n\r\n```php\r\n$di->get(\'db\');\r\n```\r\n\r\n- magic方法\r\n\r\n```php\r\n$di->getDb();\r\n```\r\n\r\n- 数组key\r\n\r\n```php\r\n$di[\'db\'];\r\n```\r\n\r\n- 实例属性\r\n\r\n```\r\n$di->db;\r\n```\r\n\r\n\r\n\r\n### 单例服务\r\n服务可以作为单例模式注入到容器，也就是说在执行过程中同一个服务只有一个实例\r\n\r\n```php\r\n$di->setShared(\r\n	\'db\',\r\n    function() {\r\n        return new MysqlDb();\r\n    }\r\n);\r\n```\r\n也可以用set方法，将第三个参数设置值为true\r\n```php\r\n$di->set(\r\n	\'db\',\r\n    function() {\r\n        return new MysqlDb();\r\n    },\r\n    true\r\n);\r\n```\r\n\r\n### 修改容器中的服务\r\n\r\n服务注入容器后，你也可以修改它\r\n```php\r\nclass Test \r\n{\r\n    \r\n}\r\n//register service\r\n$di->set(\'test\',\'StdClass\');\r\n//get service\r\n$test = $di->getService(\'test\');\r\n//change the definition\r\n$test->setDefinition(function() {\r\n    return new Test;\r\n});\r\n//resolve the service\r\n$test->resolve();\r\n```\r\n\r\n### 将容器注入到服务中\r\n\r\n容器是用来将其它服务注入到容器中的，但是有时候需要将容器注入到服务当中，这样在服务中就可以通过容器访问容器中所有服务，实现解耦。为实现这个目的，你需要将你的服务继承JsonDi\\Di\\AbstractInjectionAware类即可\r\n\r\n```php\r\nrequire_once \'vendor/autoload.php\';\r\n\r\nuse JsonDi\\Di;\r\nuse JsonDi\\Di\\AbstractInjectionAware;\r\n\r\nclass Mysql\r\n{\r\n    public function select()\r\n    {   \r\n       return \"this is select\";\r\n    }   \r\n}\r\n\r\nclass HomeController extends AbstractInjectionAware\r\n{\r\n    public function say()\r\n    {   \r\n       echo $this->container->get(\'db\')->select();\r\n    }   \r\n}\r\n\r\n$di = new Di; \r\n$di->set(\'db\', Mysql::class);\r\n\r\n$di->set(\'home\', HomeController::class);\r\n$di->get(\'home\')->say();\r\n```\r\n\r\n### 服务提供者\r\n\r\n使用JsonDi\\Di\\ServiceProviderInterface接口你可以将你的注入容器代码写入到register方法中。\r\n```php\r\nrequire_once \'vendor/autoload.php\';\r\n\r\nuse JsonDi\\Di\\DiInterface;\r\nuse JsonDi\\Di\\ServiceProviderInterface;\r\nclass SessionServiceProvider implements ServiceProviderInterface \r\n{\r\n    public function register(DiInterface $di):void\r\n    {\r\n        $di->set(\r\n        	\'session\',\r\n            \'SessionClass\'\r\n        );\r\n    }\r\n}\r\n$di->register(new SessionServiceProvider());\r\n$di->get(\'session\');\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,733,0),(2,'关于我','about',1591518480,1617005690,'<!--markdown-->### 简介\r\n- 网名:Json\r\n- 职业:码了多年代码的码农\r\n- 微信:fanqingxuan007\r\n- 邮箱:fanqingxuan@163.com\r\n- github:https://github.com/fanqingxuan\r\n- 爱好:旅游，码代码\r\n\r\n### 我不是大牛，我只是代码的搬运工',1,1,NULL,'page','publish',NULL,0,'0','0','0',0,2081,0),(4,'php基础之foreach引用的陷阱','4',1591528724,1591528724,'<!--markdown-->直接上代码\r\n```php\r\n$list = array(\r\n    array(\'id\'=>1,\'amount\'=>1),\r\n    array(\'id\'=>2,\'amount\'=>2),\r\n    array(\'id\'=>3,\'amount\'=>30),\r\n);\r\nforeach($list as &$item) {\r\n}\r\n\r\nforeach($list as $item) {\r\n    print_r($item);\r\n}\r\n```\r\n我们期望的结果肯定是\r\n```php\r\nArray\r\n(\r\n    [id] => 1\r\n    [amount] => 1\r\n)\r\nArray\r\n(\r\n    [id] => 2\r\n    [amount] => 2\r\n)\r\nArray\r\n(\r\n    [id] => 3\r\n    [amount] => 30\r\n)\r\n\r\n```\r\n实际结果却是\r\n```php\r\nArray\r\n(\r\n    [id] => 1\r\n    [amount] => 1\r\n)\r\nArray\r\n(\r\n    [id] => 2\r\n    [amount] => 2\r\n)\r\nArray\r\n(\r\n    [id] => 2\r\n    [amount] => 2\r\n)\r\n\r\n```\r\n原因是循环使用了引用变量&$item\r\n在第一次foreach循环中:\r\n- 第一次循环 $item 是 $list[0] 的引用；\r\n- 第二次循环 $item 是 $list[1] 的应用；\r\n- 第三次循环 $item 是 $list[2] 的引用；\r\n- 循环结束$item此时还在引用$list[2]\r\n\r\n在第二次foreach循环中仍然使用了变量$item,循环会修改引用的变量的值\r\n- 第一次循环结束 $item指向的元素变成了$list[0],也就是$list[2]改变成了$list[0]\r\n- 第二次循环接受 $item指向的元素变成了$list[1],也就是$list[2]改变成了$list[1]\r\n- 第三次取$list[2]跟$list[1]值一样(list的倒数第二个)\r\n\r\n所以尽量不要在foreach循环上使用引用变量,如果必须要，则解决这个问题的方案有两种\r\n- 在第一次foreach完毕后及时unset($item)取消item对别的元素的引用\r\n- 别的循环上不要再使用引用变量，即不要再使用$item',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,602,0),(5,'composer包开发之Request类封装','5',1536146340,1591528833,'<!--markdown-->自己封装的一个Request类\r\n\r\n### 安装\r\n```code\r\ncomposer require fanqingxuan/request\r\n```\r\n### 使用\r\n```php\r\n\r\nrequire \"vendor/autoload.php\";\r\n\r\nuse Json\\Request;\r\n\r\n$request = new Request;\r\n\r\nvar_dump($request->isGet());\r\n```\r\n\r\n### 封装的方法\r\n\r\n- get($name,$defaultValue)   --从REQUEST中获取值，可指定name不存在的默认值\r\n- getClientAddress() --获取客户端ip\r\n- getHeaders() --获取请求头信息\r\n- getHttpHost() --获取域名\r\n- getHTTPReferer() --获取从哪个地址跳转过来的\r\n- getJsonRawBody() --获取非multipart/form-data形式json格式数据\r\n- getMethod() --获取请求方法，包括GET、POST、PUT、DELETE、PATCH等\r\n- getPort() --获取端口\r\n- getPost($name,$defaultValue) --获取POST请求中name的值，不存在则返回defaultValue的值\r\n- getPut($name,$defaultValue) --获取PUT请求中name的值，不存在则返回defaultVlaue的值\r\n- getQuery($name,$defaultValue) --获取GET请求name的值，不存在则返回defalutValue的值\r\n- getRawBody() --获取原始输入流\r\n- getScheme() --获取请求协议\r\n- getServer($name) --获取$_SERVER中name键对应的值\r\n- getServerAddress() --获取服务端ip\r\n- getURI($onlyPath=false) --获取URI,传true不返回get参数部分\r\n- getUserAgent() --获取用户代理\r\n- has($name) --判断$_REQUEST中是否存在某key\r\n- hasPost($name) --判断$_POST中是否有某key\r\n- hasPut($name) --判断PUT请求中是否有某key\r\n- hasQuery($name) --判断$_GET中是否有某key\r\n- isAjax() --判断是否是ajax请求\r\n- isConnect() --判断是否connect请求\r\n- isDelete() --判断是否delete请求\r\n- isGet() --判断是否get请求\r\n- isHead() --判断是否head请求\r\n- isMethod($mehtod) --是否是某种请求，例如isMethod(\'GET\')\r\n- isPatch() --判断是否Patch请求\r\n- isOptions() --判断是否Options请求\r\n- isPost() --判断是否POST请求\r\n- isValidHttpMethod($method) --判断请求method是否http有效的method\r\n- hasFiles() --请求是否包含文件\r\n- getUploadedFiles() --获取上传文件',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,673,0),(6,'自动将所有表生成php中的model类','6',1591529141,1591529141,'<!--markdown-->一般的开源框架都有自己的orm，比如laravel，yii等，并且他们都有自己的命令行，所以不需要自己生成。但是也有一些高性能框架没有封装db层，比如yaf，phpslim，这个时候需要我们手动创建model，或者dao去操作数据库。\r\n\r\n我们一般创建一个model基类，封装基本的增删改查方法，然后实体model去继承基类，像下面这样\r\n\r\n```php\r\nclass Base {\r\n    public function __construct() {\r\n        \r\n    }\r\n    \r\n    public function find() {\r\n        \r\n    }\r\n    \r\n    public function findAll() {\r\n        \r\n    }\r\n    \r\n    public function update() {\r\n        \r\n    }\r\n    \r\n    public function query() {\r\n        \r\n    }\r\n    \r\n    public function insert() {\r\n        \r\n    }\r\n}\r\n\r\nclass User extends Base {\r\n    \r\n}\r\n\r\nclass Post extends Base {\r\n    \r\n}\r\n```\r\n\r\n这个时候我们发现，如果数据库中表比较多，我们就需要手动创建类似的代码，容易产出错误，另外每个表都有自己的主键，都有自己的表名称，需要在实体model中去声明的。\r\n\r\n```php\r\n<?php\r\nclass User {\r\n    public $primaryKey = \'user_id\';\r\n    \r\n    public static function tableName() {\r\n        return \"tbl_users\";\r\n    }\r\n} \r\n```\r\n\r\n上面基本上是自己封装model的设计思路\r\n\r\n\r\n我们希望手动写更少的代码，减少错误，自动根据表生成model\r\n\r\n### 用法\r\n\r\n- 安装\r\n\r\n```php\r\ncomposer require fanqingxuan/gen-models\r\n```\r\n\r\n- 使用\r\n\r\n```shell\r\n$vendor/bin/gen-models model database path //将连接的数据库中的所有表，一个表一个模型生成到对应目录,默认host是localhost,db user是root,password是root，port是3306\r\n\r\n$vendor/bin/gen-models model -h //查看命令帮助\r\n\r\n$vendor/bin/gen-models model database path -uroot123 //连接的时候db user使用root123\r\n\r\n$vendor/bin/gen-models model database path -uroot123 -pa12345 -H192.168.56.55 -P3308 //连接host是192.168.56.55,user是root123 pasword是a12345,端口是3308的库\r\n\r\n$vendor/bin/gen-models model database path --ignore-prefix  tbl_  //创建的model类名忽略表前缀\r\n\r\n$vendor/bin/gen-models model database path -f //若path中model文件已经存在，进行覆盖，不存在则创建\r\n\r\n$vendor/bin/gen-models model database path --suffix //为model类文件添加Dao或者Model后缀\r\n\r\n```\r\n\r\n\r\n\r\n- model生成规则\r\n\r\n1. tbl_user_address表生成文件名是TblUserAddress.php,类名是TblUserAddress的驼峰类\r\n2. tbl_user_address表如果命令行使用了--ignore-prefix,则生成文件名UserAddress.php,类名是UserAddress的驼峰类\r\n3. tbl_user_address如果使用了--suffix，并且选择了Model，没有使用--ignore-prefix命令，生成文件名是TblUserAddressModel.php的TblUserAddressModel类\r\n4. tbl_user_address如果使用了--suffix，并且选择了Dao，使用--ignore-prefix命令，生成文件名是UserAddressDao.php的UserAddressDao类\r\n\r\n- 生成的实例demo,包含primary_key属性，和tableName静态属性\r\n\r\n```php\r\n<?php\r\n\r\n/**\r\n * Generate by generate-model-tool\r\n * @name UsersModel\r\n * @desc UsersModel类, 主要用来访问数据库\r\n * @author Json\r\n * @see http://github.com/fanqingxuan/gen-models\r\n */\r\nclass UsersModel extends BaseModel {\r\n\r\n   /**\r\n    * table primary key\r\n    */\r\n   protected $primary_key = \'user_id\';\r\n\r\n   /**\r\n    * @return string\r\n    */\r\n   public static function tableName()\r\n   {\r\n        return \'users\';\r\n   }\r\n\r\n}\r\n```\r\n\r\n### 其它\r\n\r\n如果您电脑没有安装composer，可以使用gen-models，然后执行如下命令就可以了\r\n\r\n```\r\n$php gen-models model database path\r\n$./gen-models model database path\r\n```\r\n**注意:gen-models可执行文件需要单独下载，目前存放在github，地址是:https://github.com/fanqingxuan/gen-models**\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,600,0),(7,'php基础之json_encode的小tips','7',1591529386,1591529386,'<!--markdown-->- json_encode一个从整数0开始的连续数组，返回的是一个数组结构，否则返回对象结构 \r\n- 另:空数组返回的结构也是类似js的数组结构\r\n\r\n```\r\n$arr = array(1,2,3);\r\necho json_encode($arr);//输出[1,2,3]\r\necho \"<br/>\";\r\n\r\n$arr = array(1,2,\'3\'=>3);\r\necho json_encode($arr);//输出{\"0\":1,\"1\":2,\"3\":3}\r\necho \"<br/>\";\r\n\r\necho json_encode(array());//输出[]\r\necho \"<br/>\";\r\n\r\n$obj = new StdClass();\r\necho json_encode($obj);//输出{}\r\n\r\necho \"<br/>\";\r\necho json_encode(array(),JSON_FORCE_OBJECT);//输出{}\r\necho \"<br/>\";\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,580,0),(8,'php基础之数组array_merge和+','8',1591531500,1591531733,'<!--markdown-->- 当key是数字时，array_merge不会覆盖、去重元素，键名以 0 开始进行重新索引\r\n```\r\n$arr = array(1,2,\"5\"=>9);\r\n$arr1 = array(1,8,9);\r\nvar_dump(\"<pre>\",array_merge($arr,$arr1)); //array(1,2,9,1,8,9)\r\n```\r\n\r\n- 当key是字符串时，array_merge对于相同的key后者会覆盖前者，没有重复的key会按顺序进行拼接\r\n```\r\n$arr = array(\"one\"=>1,\"two\"=>2,\"three\"=>3);\r\n$arr1 = array(\"one\"=>11,\"four\"=>44);\r\nvar_dump(\"<pre>\",array_merge($arr,$arr1));// array(\"one\"=>11,\"two\"=>2,\"three\"=>3,\"four\"=>44);\r\n```\r\n- 两个数组直接相加，对于相同的key会保留前者，对于没有重复的key(key不分是数字还是字符串)会按顺序进行拼接\r\n```\r\n$arr = array(\"one\"=>1,\"two\"=>2,\"three\"=>3);\r\n$arr1 = array(\"one\"=>11,\"four\"=>44);\r\nvar_dump(\"<pre>\",$arr+$arr1);//array(\"one\"=>1,\"two\"=>2,\"three\"=>3,\"four\"=>44);\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,570,0),(9,'仿laravel之优雅的访问配置文件的配置项','9',1591532520,1591532603,'<!--markdown-->使用过laravel框架的朋友大概都使用过laravel中的config辅助函数，例如config(\"app.name\"),多维数组总能转化成config(\"key.key1.key2\")用点号的形式访问，看着挺舒服，今天我们就仿照laravel实现下\r\n\r\n### 定义一个Config类，如下\r\n```php\r\nclass Config\r\n{\r\n    private $data;//用来存储数组\r\n\r\n    public function __construct($path)\r\n    {\r\n        $this->data = array();\r\n        $this->handle($path);\r\n    }\r\n\r\n    public function handle($path)\r\n    {\r\n        $itemlist = glob(\"{$path}/*.php\");//匹配路径下的php文件\r\n        foreach ($itemlist as $filename) {\r\n            $prepend = basename($filename, \'.php\');\r\n			//将二维数组拼成点号的一维数组\r\n            $item = $this->dot(require_once $filename, $prepend.\'.\');\r\n            $this->data = array_merge($this->data, $item);\r\n        }\r\n    }\r\n	//二维数组转成点号的一维数组实现\r\n    private function dot($array, $prepend = \'\')\r\n    {\r\n        $results = array();\r\n        foreach ($array as $key => $value) {\r\n            if (is_array($value) && ! empty($value)) {\r\n                $results = array_merge($results, static::dot($value, $prepend.$key.\'.\'));\r\n            } else {\r\n                $results[$prepend.$key] = $value;\r\n            }\r\n        }\r\n\r\n        return $results;\r\n    }\r\n	\r\n	//对外的访问函数\r\n    public function get($name, $default = null)\r\n    {\r\n        return isset($this->data[$name])?$this->data[$name]:$default;\r\n    }\r\n\r\n    public function all()\r\n    {\r\n        return $this->data;\r\n    }\r\n}\r\n```\r\n### 实例化\r\n```php\r\n$config = new Config(\'./config\');//指定配置文件所在目录\r\n```\r\n### 使用\r\n- 获取所有配置项\r\n```php\r\n$config->all();\r\n```\r\n- 获取单个配置项值\r\n```php\r\n$config->get(\'app.hello\', \'default value\');\r\n```\r\n第一个参数是配置项名称(文件名.配置名称)，第二个是默认值(如果配置项不存在，则返回默认值)\r\n\r\n举例如下:\r\n\r\n1. 访问app文件中的name属性,不存在则返回默认值\r\n```\r\n$config->get(\'app.name\',\'Json博客\');\r\n```\r\n2. 访问database文件中的host配置\r\n```\r\n$config->get(\'database.host\');\r\n```\r\n3. 访问app文件中list配置的第一个值\r\n```\r\n$config->get(\'app.list.0\')\r\n```\r\n### 完整实例\r\n```php\r\n$config = new Config(\'./config\');\r\nvar_dump($config->get(\'app.name\',\'Json博客\'));\r\nvar_dump($config->get(\'database.host\'));\r\nvar_dump($config->get(\'app.list.0\'));\r\n```\r\n重点是Config类的实现',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,678,0),(10,'根据phpredis扩展生成stub文件','10',1591536764,1591536764,'<!--markdown-->### stub文件\r\nphpredis是php的c扩展形式实现的redis客户端代码，有时候我们想知道这个扩展到底有哪些方法，或者我们想让编辑器帮我们自动提示，这时候就需要stub文件了，当然phpstorm这个强大的编辑器插件里面已经包含了phpredis的stub文件，但是其它如sublime，vscode却没有，这时候我们就需要自己去生成，然后copy到项目里面，就能帮我们提示了\r\n\r\n### 启发\r\n研究鸟哥的yaf框架的时候，鸟哥自己写了个yaf-tools，包含了yaf的所有方法，便于编辑器提示，鸟哥在工具里面还给出了生成yaf stub文件的代码，所以拿鸟哥的代码改成phpredis扩展的，就可以生成phpredis stub了\r\n\r\n### 实现\r\ngen-redis-stub.php文件代码\r\n```php\r\n<?php\r\n/**\r\n * Redis Classes stub generator\r\n *\r\n * @author  Json\r\n * @date    2020-05-07 16:49:09\r\n * @version $Id$\r\n */\r\n\r\n$classPrefix = \"Redis\";\r\n$classes = array_merge(get_declared_classes(), get_declared_interfaces());\r\nforeach ($classes as $key => $value) {\r\n    if (strncasecmp($value, $classPrefix, 5)) {\r\n        unset($classes[$key]);\r\n    }\r\n}\r\nob_start();\r\necho \"<?php\\n\";\r\n\r\nforeach ($classes as $class_name) {\r\n    $class = new ReflectionClass($class_name);\r\n    $indent  = \"\";\r\n\r\n    $classAttributes = \"\";\r\n\r\n    if ($class->isInterface()) {\r\n        $classAttributes .= \"interface \";\r\n    } else {\r\n        if ($class->isFinal()) {\r\n            $classAttributes .= \"final \";\r\n        }\r\n\r\n        if ($class->isAbstract()) {\r\n            $classAttributes .= \"abstract \";\r\n        }\r\n\r\n        $classAttributes .= \"class \";\r\n    }\r\n\r\n    echo $indent, $classAttributes, $class_name;\r\n\r\n    /* parent */\r\n    $parent = $class->getParentClass();\r\n    if ($parent) {\r\n        echo \" extends \", $parent->getName();\r\n    }\r\n\r\n    /* interface */\r\n    $interfaces = $class->getInterfaceNames();\r\n    if (count($interfaces)) {\r\n        echo \" implements \", join(\", \", $interfaces);\r\n    }\r\n    echo \" {\\n\";\r\n\r\n    $indent .= \"\\t\";\r\n    /* constants */\r\n    $constants = $class->getConstants();\r\n    if (0 < count($constants)) {\r\n      echo $indent, \"/* constants */\\n\";\r\n\r\n      foreach ($constants as $k => $v) {\r\n           echo $indent, \"const \", $k , \" = \\\"\", $v , \"\\\";\\n\";\r\n      }\r\n      echo \"\\n\";\r\n    }\r\n\r\n    /* properties */\r\n    $properties = $class->getProperties();\r\n    if (0 < count($properties)) {\r\n      echo $indent, \"/* properties */\\n\";\r\n      $values     = $class->getDefaultProperties();\r\n      foreach ($properties as $p) {\r\n          echo $indent;\r\n\r\n          if ($p->isStatic()) {\r\n              echo \"static \";\r\n          }\r\n\r\n          if ($p->isPublic()) {\r\n              echo \"public \";\r\n          } else if ($p->isProtected()) {\r\n              echo \"protected \";\r\n          } else {\r\n              echo \"private \";\r\n          }\r\n\r\n          echo \'$\', $p->getName(), \" = \";\r\n\r\n          if (isset($values[$p->getName()])) {\r\n              echo \'\"\', $values[$p->getName()], \'\"\';\r\n          } else {\r\n              echo \"NULL\";\r\n          }\r\n          echo \";\\n\";\r\n      }\r\n      echo \"\\n\";\r\n    }\r\n\r\n    /* methods */\r\n    $methods = $class->getMethods();\r\n    if (0 < count($methods)) {\r\n      echo $indent, \"/* methods */\\n\";\r\n\r\n      foreach ($methods as $m) {\r\n          echo $indent;\r\n          echo implode(\' \', Reflection::getModifierNames($m->getModifiers()));\r\n          echo \" function \", $m->getName(), \"(\";\r\n\r\n          if ($m->isAbstract()) {\r\n              // abstract methods are without a body \"{ ... }\"\r\n              echo \");\\n\";\r\n              continue;\r\n          }\r\n\r\n          $parameters = $m->getParameters();\r\n          $number = count($parameters);\r\n          $index  = 0;\r\n          foreach ($parameters as $a) {\r\n              if (($type = $a->getClass())) {\r\n                  echo $type->getName(), \" \";\r\n              } else if ($a->isArray()) {\r\n                  echo \"array \";\r\n              }\r\n\r\n              if ($a->isPassedByReference()) {\r\n                  echo \"&\";\r\n              }\r\n\r\n              $name = $a->getName();\r\n              if ($name == \"...\") {\r\n                  echo \'$_ = \"...\"\';\r\n              } else {\r\n                  echo \"$\", $name;\r\n              }\r\n\r\n              if ($a->isOptional()) {\r\n                  if ($a->isDefaultValueAvailable()) {\r\n                      echo \" = \", $a->getDefaultValue();\r\n                  } else {\r\n                      echo \" = NULL\";\r\n                  }\r\n              }\r\n\r\n              if (++$index < $number) {\r\n                  echo \", \";\r\n              }\r\n          }\r\n\r\n          echo \") {\\n\";\r\n          echo $indent, \"}\\n\";\r\n      }\r\n    }\r\n\r\n    $indent = substr($indent, 0, -1);\r\n    echo $indent, \"}\\n\";\r\n\r\n}\r\n\r\n\r\n$content = ob_get_contents();\r\nob_end_clean();\r\n\r\nfile_put_contents(\"Redis.stub.php\",$content);\r\n\r\n```\r\n### 使用\r\n```php\r\n$ php gen-redis-stub.php\r\n```\r\n会在当前目录生成Redis.stub.php\r\n\r\n**其实这个例子的目的不是教大家生成redis的stub文件，而是教大家如何灵活使用php中的反射相关的各种方法**',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,690,0),(11,'驼峰&lt;--&gt;长蛇转换函数','11',1591537680,1591537783,'<!--markdown-->驼峰长蛇转换函数最常见的场景就是\r\n1. table表名转成驼峰model类名\r\n2. 根据model名称自动生成table表\r\n\r\n### 实现\r\n下面给出驼峰转长蛇相互转换的函数\r\n```php\r\n/**\r\n * 将\'ModelName\'转成\'model_name\'.\r\n */\r\nfunction tableize(string $word)\r\n{\r\n    $tableized = preg_replace(\'~(?<=\\\\w)([A-Z])~u\', \'_$1\', $word);\r\n\r\n    if ($tableized === null) {\r\n        throw new RuntimeException(sprintf(\r\n            \'preg_replace returned null for value \"%s\"\',\r\n            $word\r\n        ));\r\n    }\r\n\r\n    return mb_strtolower($tableized);\r\n}\r\n\r\n/**\r\n * 将\'table_name\'转成\'TableName\'.\r\n */\r\nfunction classify(string $word)\r\n{\r\n    return str_replace([\' \', \'_\', \'-\'], \'\', ucwords($word, \' _-\'));\r\n}\r\n```\r\n###使用\r\n```php\r\nvar_dump(tableize(\"UserInfo\"),classify(\"tbl_user_info\"));\r\n//string(9) \"user_info\" string(11) \"TblUserInfo\"\r\n```\r\n\r\n**大家不要崇拜我，这两个函数不是我自己写的，来源于[doctrine/inflector](https://github.com/doctrine/inflector)中的两个函数,doctrine/inflector是个好东西，具体是干嘛的，大家可自行百度，其实学习的过程就是这样，将别人优秀的东西拿过来用，我们不必关心整体，关心我们需要的功能就可以了**',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,597,0),(12,'git常用命令','12',1591539060,1618632881,'<!--markdown-->### Git SSH Key 生成步骤\r\n- 设置Git的user name和email\r\n```shell\r\ngit config --global user.name \"gitadmin\"\r\ngit config --global user.email \"gitadmin@admin.com\"\r\n```\r\n- 生成SSH密钥过程\r\n```shell\r\nssh-keygen -t rsa -C \"gitadmin@admin.com\"\r\n按3个回车，密码为空。\r\n```\r\n最后得到了两个文件：id_rsa和id_rsa.pub\r\n\r\n- 添加密钥到ssh\r\n将id_rsa.pub文件里面的内容复制到自己的git服务端，如github的个人设置里面的ssh相关菜单\r\n\r\n### 开始使用\r\n建立本地<-->远端仓库的关系，\r\n如果是新项目(远端不存在该项目)，执行如下\r\n```shell\r\necho \"# demo\" >> README.md\r\ngit init\r\ngit add README.md\r\ngit commit -m \"first commit\"\r\ngit remote add origin https://github.com/fanqingxuan/demo.git\r\ngit push -u origin master\r\n```\r\n远端已经存在的项目\r\n```shell\r\ngit clone git@github.com:fanqingxuan/di.git\r\n```\r\n###设置别名\r\n```shell\r\ngit config --global alias.ll \"log --graph --all --pretty=format:\'%Cred%h %Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset\' --abbrev-commit --date=relative\"\r\ngit config --global color.status auto\r\ngit config --global color.branch auto\r\ngit config --global color.diff auto\r\ngit config --global color.interactive auto\r\ngit config --global alias.co checkout\r\ngit config --global alias.br branch\r\ngit config --global alias.ci commit\r\ngit config --global alias.st status\r\ngit config --global alias.last \"log -1 HEAD\"\r\ngit config --global alias.df diff\r\ngit config --global color.ui true\r\ngit config --global core.quotepath false   #防止git status中文文件名乱码\r\ngit config --global pull.rebase true #设置pull默认rebase\r\ngit config --global core.filemode false #忽略文件权限的变更\r\n```\r\n### 常用命令\r\n```shell\r\ngit push origin master #将本地的master分支推送到origin主机的master分支,如果后者不存在，则会被新建\r\n\r\n#分支支推送顺序的写法是<来源地>:<目的地>，所以git pull是<远程分支>:<本地分支>，而git push是<本地分支>:<远程分支>\r\n\r\n#删除远程master分支\r\ngit push origin :master\r\ngit push origin --delete master\r\n\r\n#不使用fast forward合并,日志是一条线，没有分叉\r\ngit merge --no-ff -m \"merge with no-ff\" develop\r\n\r\ngit add file  #将内容由工作区提交到暂存区\r\ngit commit -m \"log message\"  #将内容由暂存区提交到仓库\r\ngit commit -a #由工作区直接提交到仓库\r\ngit commit --amend #修改最后一次修改信息,或者是有漏掉的提交，可以将上一次的提交和漏掉的文件重新作为一次提交\r\ngit checkout -- file    #用暂存区或仓库内容覆盖工作区，以最新的时间点为参照，这个命令改变的是工作区\r\ngit checkout HEAD #用仓库内容直接覆盖工作区\r\ngit checkout - #跳到之前的分支\r\ngit reset --hard HEAD #工作区和暂存区都回退到和仓库一致\r\n\r\ngit diff #对比工作区和暂存区\r\ngit diff HEAD #对比工作区和仓库\r\ngit diff --cached #对比暂存区和仓库\r\n\r\ngit push origin master:master #本地master仓库提交到远程master仓库\r\n\r\ngit pull/rebase origin master:fanxiajie #拉取远程master仓库到本地fanxiaojie仓库,并合并到当前分支\r\ngit fetch origin fanxiaojie:fanxiaojie #只拉取远程仓库到本地仓库，不合并到当前分支\r\n\r\n#把暂存区的修改撤销掉（unstage），重新放回工作区\r\ngit reset HEAD\r\ngit reset HEAD filename\r\n\r\ngit add -a #表示添加所有内容， \r\ngit add . #表示添加新文件和编辑过的文件不包括删除的文件; \r\ngit add -u #表示添加编辑或者删除的文件，不包括新添加的文件\r\n\r\n#新建标签\r\ngit tag v1.0\r\n#给commit id 为25656e2的历史版本打标签\r\ngit tag v1.0  25656e2\r\n#查看标签\r\ngit tag\r\n#删除本地tag\r\ngit tag -d v0.9\r\n#删除远程tag\r\ngit push origin :refs/tags/v0.9\r\n#git show tagname查看标签信息\r\ngit show v1.0\r\n\r\n# 删除 untracked files\r\ngit clean -f\r\n# 连 untracked 的目录也一起删掉\r\ngit clean -fd\r\n# 连 gitignore 的untrack 文件/目录也一起删掉 （慎用，一般这个是用来删掉编译出来的 .o之类的文件用的）\r\ngit clean -xfd\r\n# 在用上述 git clean 前，墙裂建议加上 -n 参数来先看看会删掉哪些文件，防止重要文件被误删\r\ngit clean -nxfd\r\ngit clean -nf\r\ngit clean -nfd\r\n\r\n#查看远程仓库地址:\r\ngit remote -v\r\n```\r\n\r\n### 问题\r\n- git bash命令行下面文件名是中文显示乱码，执行\r\n```shell\r\ngit config --global core.quotepath false\r\n```\r\n- git提示\"bad index file sha1 signature fatal: index file corrupt\"\r\n    需要删除.git/index文件，然后在仓库目录下运行git reset，重新生成index文件\r\n```shell\r\nrm -f .git/index\r\ngit reset\r\n```\r\n- git push代码到github上一直提示输入用户名及密码的问题\r\n出现这种情况的原因是我们使用了http的方式clone代码到本地，相应的，也是使用http的方式将代码push到服务器\r\n    git remote -v 查看当前方式\r\n    解决办法很简单，将http方式改为ssh方式，操作步骤如下:\r\n```bash\r\ngit remote rm origin\r\ngit remote add origin git@github.com:fanqingxuan/blog_demo.git\r\ngit push --set-upstream origin master\r\n```\r\n- 进个项目文件夹中，使用git命令时报如下错\r\n```shell\r\n$ git status\r\nfatal: not a git repository (or any of the parent directories): .git\r\n```\r\n实际上，项目文件夹中，存在`.git`文件夹\r\n**原因**:电脑异常关机，电脑运行时间过长，或者非正常退出git，导致git的HEAD文件损坏\r\n**解决方式**:将项目中的.git/HEAD文件内容修改为`ref: refs/heads/develop`,然后重新进入终端',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,634,0),(13,'学习方法分享','13',1591808160,1591961241,'<!--markdown--># 前奏\r\n经常有伙伴问我有啥好的学习建议没，问的我没有话说，自己确实没有总结过自己是怎么学习的，故而不知道怎么回答。问的人越来越多，因此自己有必要总结下是怎么学习的，大家可选择性吸收。\r\n\r\n# 正文\r\n#### 好奇心\r\n\r\n>好奇心很重要，可能跟对代码的热爱是分不开的,对工作中或者遇到的代码特性充满好奇,要喜欢探索和研究\r\n\r\n举两个例子\r\n\r\n- laravel大家都用的很熟了,有没有好奇过laravel不需要安装phpredis扩展就可以直接使用redis,怎么实现的呢,以此可以深入研究实现原理,有时候不需要深入研究细节，可以大体看下逻辑,带着自己关心的点,去读源码\r\n\r\n- 有没有好奇过thinkphp框架里面对db的连贯操作,比如$db->where()->order()->select(),怎么实现的呢,看着好爽呢，带着问题看源码，原来就是return了个$this对象\r\n\r\n#### [github](https://github.com/)\r\n> 如果你还不知道github是干什么的，那真的应该去反思了，可以关注github上star比较多的项目，那都是很优秀的项目，另外还可以根据star比较多的项目，看看这个项目是哪个组织或者用户贡献的，从而去发现这个组织或用户的更多项目，没准会有意想不到的收货\r\n\r\n#### 优秀项目的开源库\r\n> 这个怎么讲呢，举例比如laravel这个大红大紫的框架，composer.json里面都依赖哪些其它项目库，有不认识的库可以去google搜索，了解这个库的实际用途，从而可以举一反三，没准在日后的项目里就可以用上这些库\r\n	\r\n#### 关注优秀博客论坛\r\n> 关注优秀的博客和论坛，不需要关注过多，因为有的不太好的资料可能会误导你，使你走弯路，关注博客或者论坛不需要所有资料的精读细读，选择自己感兴趣的版块或者文章去浏览阅读，关注自己感兴趣的话题或者技术词汇\r\n\r\n这里推荐两个我关注的网站\r\n**[v2ex](https://www.v2ex.com/)**  这是一个讨论技术周边的社区\r\n**[segmentfault](https://segmentfault.com/)** 有网站有讨论社区\r\n\r\n#### 实际工作\r\n> 我们绝大部分时间还是在工作，实际项目中引入的优秀库是很好的一个学习资源，不仅可以提升自己，还可以在当前工作中马上使用\r\n\r\n#### 招聘网站\r\n> 对我们程序员来说，拉勾、Boss直聘不仅仅是投简历找工作的地方，也是学习的好去处，怎么学习呢，看各个工作的招聘要求，看看当前社会上别的公司都在使用什么技术，有的招聘需求上直接描述了对具体技术点的要求，这个技术点就是我们可以考虑学习的东西\r\n\r\n#### 其它\r\n> 读书，看视频这个就仁者见仁了，有的人喜欢读书，有的人感觉看视频教程效率高，也有的人就喜欢逛论坛，选择适合自己的方式就好\r\n',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,637,0),(14,'缓存穿透、缓存击穿、缓存雪崩','14',1591922636,1591922636,'<!--markdown-->我们使用数据缓存的流程一般是这样的\r\n1. 请求过来之后，先从缓存中读取数据，若取到数据则返回结果\r\n2. 若没取到缓存，就查询Db，查询到结果就更新缓存，同时返回结果\r\n3. 若没取到缓存，同时查询Db也没查到数据，则直接返回空数据\r\n\r\n缓存以redis为例，伪代码实现过程大概是这样的\r\n```php\r\n    function getData($key) {\r\n        $cacheValue = $redis->get($key);\r\n        if($cacheValue !== NULL) {\r\n            return $cacheValue;\r\n        }\r\n        $dbValue = Db.getData($key);\r\n        if($dbValue) {\r\n            $redis->set($key,$dbValue);\r\n            return $dbValue;\r\n        } else {\r\n            return array();\r\n        }\r\n    }\r\n```\r\n在一个访问量或者中小型网站上没什么问题，如果我们的网站或者项目很火，访问量很大，不断的有竞争者或者黑客取尝试攻击，那问题就来了\r\n\r\n### 缓存穿透\r\n**缓存穿透是指查询一个缓存和数据库中一定不存在的数据，而用户不断发起请求，或者不断有请求打过来，这个时候每个请求都会查询数据库，导致数据库压力过大，甚至Db挂了**\r\n如上面的代码，若某个key缓存中不存在，并且db中也不存在，这个时候会每个请求都会走Db.getData去查询数据库，增大了数据库压力\r\n知道了问题就可以采取相应的策略取解决了，常用的两种方式是\r\n- 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免对底层存储系统的查询压力，这个没有用过\r\n- 简单暴力的方式: 若db查询的结果为空，将空结果缓存起来，这个数据过期时间可以设置短一些，比如60s，这种方式可能会存在60s的数据误差，这种方式优化后的代码如下\r\n```php\r\nfunction getData($key) {\r\n    $cacheValue = $redis->get($key);\r\n    if($cacheValue !== NULL) {\r\n        return $cacheValue;\r\n    }\r\n    $dbValue = Db.getData($key);\r\n    $redis->set($key,$dbValue);\r\n    if($dbValue === NULL) {\r\n        $redis->expire($key,60);//设置60s过期时间\r\n    }\r\n    return $dbValue;\r\n}\r\n```\r\n嗯，看着似乎没有什么问题了:)\r\n我们想象这样一种情况，缓存中没有数据(可能就真是没有，也可能缓存过期了)，并且请求的访问量又特别大，那么可能瞬间就有几万几十万个请求打到Db上，Db流量瞬间暴增，还是会增大数据库的压力，这就引入了**缓存击穿**当遇到这样情况的时候你的项目应该是特别火啦\r\n### 缓存击穿\r\n**缓存击穿是指缓存中没有(缓存到期，没有缓存过)但数据库中有的数据，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力**\r\n这种情况的解决方案是加锁，避免多个请求同时访问Db，如下伪代码\r\n```php\r\nfunction getData($key) {\r\n    $cacheValue = $redis->get($key);\r\n    if($cacheValue !== NULL) {\r\n        return $cacheValue;\r\n    }\r\n    if($redis->setnx(\"lock\",1)) {//加锁\r\n        $redis->expire(\"lock\",60);\r\n        $dbValue = Db.getData($key);\r\n        $redis->set($key,$dbValue);\r\n        if($dbValue === NULL) {\r\n            $redis->expire($key,60);//设置60s过期时间\r\n        }\r\n        $redis->delete(\"lock\");//释放锁\r\n        return $dbValue;\r\n    } else {\r\n        sleep(1);//睡眠1s\r\n        return getData($key);\r\n    } \r\n}\r\n```\r\n嗯，差不多了，仔细研究分析的话，这段代码还有问题\r\n1. 代码走到setnx时候，程序中断或者程序挂了，或者服务器故障了，程序还没有走到expire(设置锁过期时间)，恢复程序之后，是不是就进入了死循环\r\n2. 两个不同key都是高并发，如果缓存中没有这两个key，数据库中存在，那一个key走到setnx上锁的时候是不是另一个key的上锁也阻塞到那里了\r\n所以基于以上两点，可以优化成下面的样子\r\n```php\r\nfunction getData($key) {\r\n    $cacheValue = $redis->get($key);\r\n    if($cacheValue !== NULL) {\r\n        return $cacheValue;\r\n    }\r\n    array(\'nx\', \'ex\' => $ttl)\r\n    if($redis->set(\"lock_\".$key,1,array(\'nx\', \'ex\' => 60))) {//加锁,过期时间60s\r\n        $dbValue = Db.getData($key);\r\n        $redis->set($key,$dbValue);\r\n        if($dbValue === NULL) {\r\n            $redis->expire($key,60);//设置60s过期时间\r\n        }\r\n        $redis->delete(\"lock_\".$key);//释放锁\r\n        return $dbValue;\r\n    } else {\r\n        sleep(1);//睡眠1s\r\n        return getData($key);\r\n    } \r\n}\r\n```\r\n这样差不多就ok了\r\n一个key缓存中不存在，db中存在，这叫缓存击穿，如果缓存中同时多个key失效，又是高并发，这该怎么办呢，这就引入了另一个概念**缓存雪崩**\r\n### 缓存雪崩\r\n**缓存雪崩是指缓存中数据大批量到过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。 **\r\n因此我们在设置缓存时要考虑如何避免缓存雪崩，具体不限于以下三种方案:\r\n- 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生\r\n- 如果缓存数据库是分布式部署，将热点数据均匀分布在不同缓存数据库中\r\n- 设置热点数据永远不过期',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,620,0),(15,'aksk鉴权的实现思路','15',1591883100,1591922728,'<!--markdown-->### 什么是鉴权\r\n鉴权是一种用于在网络通信中对试图访问服务的请求或用户进行权限认证的方法\r\n\r\n### 鉴权使用场景\r\n鉴权通常用于跨系统或者项目进行**重要数据**交互的场景\r\n\r\n### 鉴权的作用\r\n- 对请求进行身份验证\r\n- 防止非法者劫持数据，对数据进行篡改\r\n- 防止恶意攻击\r\n- 防止不怀好意的人获取系统重要数据\r\n\r\n### 什么是AKSK\r\nAKSK是鉴权过程中的一对秘钥对，通常成对出现\r\nAK即Access Key，用户的唯一标识\r\nSK即Secret Key，用于加密认证的秘钥字符串，必须保密，不能泄露，鉴权过程中不在网络中传输，若SecretKey被恶意第三方窃取，可能导致非常严重的数据泄漏风险\r\n\r\n### 鉴权过程\r\n鉴权需要双方按照一定的规则进行数据交互传输，请求除了业务过程中必要的参数外，客户端在请求时还需要添加额外的参数以完成鉴权\r\n- timestamp:当前请求时间戳\r\n- signature:按照双方约定的算法，由客户端生成的签名串，加密算法中需要包含SK,通常用2-5个参数值进行加密\r\n- accessKey:服务端提供给客户端的公钥，服务端用于查询对应的SK秘钥，然后按照相同的算法进行加密\r\n\r\n### 服务端鉴权步骤\r\n1. 根据业务对请求参数进行非空校验\r\n2. 校验请求时间是否超时\r\n3. 根据请求参数的公钥获取分配给该客户的秘钥，不存在则提示非法\r\n3. 对请求参数拼接组装，按照双方约定的算法进行加密生成签名串\r\n4. 判断客户端传递的签名串和服务端生成的签名串是否一致，不一致则提示非法\r\n5. 校验通过，进行业务处理\r\n\r\n### 举例说明\r\n假如一个客户端要获取服务端一段时间内新增用户的信息，双方规定好了业务参数包括\r\nstartTime:开始时间，如2019-11-1\r\nendTime:结束时间，若2019-11-31\r\ntype:查询类型，1用户信息列表 2企业信息列表\r\n签名串signature的生成算法是:md5(startTime+md5(endTime)+SK+type)\r\n请求方式是GET请求\r\n\r\n那在请求时需要加上我们之前说的三项timestamp、signature、accessKey\r\n\r\n服务端的鉴权代码应该类似是下面的样子\r\n```php\r\n    $arrInput = array(\r\n        \'startTime\' =>  $_GET[\'startTime\'],\r\n        \'endTime\'   =>  $_GET[\'endTime\'],\r\n        \'type\'      =>  $_GET[\'type\'],\r\n        \'timestamp\' =>  $_GET[\'startTime\'],\r\n        \'signature\' =>  $_GET[\'startTime\'],\r\n        \'accessKey\' =>  $_GET[\'accessKey\'],\r\n    );\r\n    $ret = array(\r\n        \'errCode\'   =>  \'\',\r\n        \'data\'      =>  array(),\r\n        \'errMsg\'    =>  \'\',\r\n    );\r\n    if(strtotime($arrInput[\'startTime\']>=strtotime($arrInput[\'endTime\'])) {\r\n        $ret[\'errCode\'] = 3001;\r\n        $ret[\'errMsg\']  = \'开始时间不能大于结束时间\';\r\n        echo json_encode($ret);\r\n        die;\r\n    }\r\n    if($arrInput[\'type\'] !=1 && $arrInput[\'type\'] != 2) {\r\n        $ret[\'errCode\'] = 3001;\r\n        $ret[\'errMsg\']  = \'查询类型不对\';\r\n        echo json_encode($ret);\r\n        die;\r\n    }\r\n    //为了防止客户端与服务器时间不同步而导致的认证失败，引入5分钟的宽松系数\r\n    if(time()-$arrInput[\'timestamp\']>300) {\r\n        $ret[\'errCode\'] = 3001;\r\n        $ret[\'errMsg\']  = \'请求超时\';\r\n        echo json_encode($ret);\r\n        die;\r\n    }\r\n    $dbSecretKey = $db->get($arrInput[\'accessKey\']);\r\n    if(empty($dbSecretKey)) {\r\n        $ret[\'errCode\'] = 3002;\r\n        $ret[\'errMsg\']  = \'非法攻击\';\r\n        echo json_encode($ret);\r\n        die;\r\n    }\r\n    $signature = md5($arrInput[\'startTime\'].md5($arrInput[\'endTime\']).$dbSecretKey.$arrInput[\'type\']);\r\n    if($signature != $arrInput[\'signature\']) {\r\n        $ret[\'errCode\'] = 3003;\r\n        $ret[\'errMsg\']  = \'鉴权失败\';\r\n        echo json_encode($ret);\r\n        die;\r\n    }\r\n    //业务处理，查询db返回数据\r\n    $data = $db->getData($arrInput[\'startTime\'],$arrInput[\'endTime\'],$arrInput[\'type\']);\r\n    $ret[\'data\']  = $data;\r\n    echo json_encode($ret);\r\n    die;\r\n```\r\n看下上面的代码，基本上就是一个鉴权认证的思路，可以理一下代码，如果请求被非法劫持，修改任何一个参数都不会获取到数据，如果不修改参数也只能5分钟内可以获取一段时间内数据',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,1796,0),(16,'mysql json字段类型','16',1591922823,1591922823,'<!--markdown-->### 测试mysql版本5.7.29\r\n\r\n##### 创建json字段表\r\n\r\n```sql\r\ncreate table test (\r\n	id int(11) NOT NULL PRIMARY KEY AUTO_INCREMENT,\r\n	data json\r\n) charset=utf8;\r\n```\r\n\r\n写入字段数据,插入满足json格式的字符串，不符合json格式的字符串插入时会报错\r\n\r\n```sql\r\n insert into test (data) values (\'dddd\');  -- 非json格式会报错\r\n insert into test (data) values (\'{\"name\":\"范晓杰\",\"age\":34}\'); \r\n insert into test (data) values (\'[11,22,33]\');\r\n```\r\n\r\n##### 更新字段数据\r\n\r\n```sql\r\nupdate test set data = \'{\"name\":\"json\"}\' where id=1;\r\n```\r\n\r\n##### json函数\r\n\r\n- json_array 构建json列表数据\r\n\r\n  ```sql\r\n  select json_array(11,22,33,44);-- 查询\r\n  insert into test(data) values (json_array(33,44,55));-- 插入\r\n  ```\r\n\r\n- json_object构建son对象数据\r\n\r\n  ```sql\r\n  select json_object(\"name\",\"json\",\"age\",12); -- json_object 构建对象数据，key value，**值必须是偶数个**，构成key,value，否则会报错\r\n  insert into test(data) values (json_object(\"name\",\"json\",\"age\",12))\r\n  select json_object(33,44,55) -- 奇数个报错\r\n  ```\r\n\r\n**注意value一定要是偶数个，否则会报错 **\r\n\r\n- json_merge_preserve合并多个json数据\r\n\r\n  ```sql\r\n  select json_merge_preserve(\'[11,22]\',\'{\"name\":4}\',\'[44]\',\'[]\'); -- json_merge_preserve 合并多个json格式数据\r\n  \r\n  insert into test(data) values (json_merge_preserve(\'[11,22]\',\'{\"name\":4}\',\'[44]\',\'[]\'));\r\n  \r\n  insert into test(data) values (json_merge_preserve(json_array(11,22),json_array(11,23))); -- 综合各种函数\r\n  ```\r\n\r\n- json_keys返回对象的所有key\r\n\r\n  ```sql\r\n  select json_keys(data) from test;\r\n  ```\r\n\r\n- JSON_REPLACE 替换值（只替换已经存在的旧值，不存在则不写入）\r\n\r\n  ```sql\r\n  select json_replace(\'{\"name\":\"json\"}\',\'$.name\',\"范晓杰\"); -- name替换成了范晓杰\r\n  select json_replace(\'{\"name\":\"json\"}\',\'$.age\',\"23\"); -- 没有写入age属性\r\n  update test set data = json_replace(\'{\"name\":\"json\"}\',\'$.age\',\"23\") where id=1;\r\n  ```\r\n\r\n- JSON_SET 设置值（替换旧值或插入不存在的新值）\r\n\r\n  ```sql\r\n  select json_set(\'{\"name\":\"json\"}\',\'$.name\',\"范晓杰\"); -- name替换成了范晓杰\r\n  select json_set(\'{\"name\":\"json\"}\',\'$.age\',\"23\"); -- 写入age属性\r\n  ```\r\n\r\n- JSON_INSERT 插入值（插入新值，不替换已经存在的旧值）\r\n\r\n  ```SQL\r\n  select json_insert(\'{\"name\":\"json\"}\',\'$.name\',\"范晓杰\"); -- name没有替换，仍然是json\r\n  select json_insert(\'{\"name\":\"json\"}\',\'$.age\',\"23\"); -- 写入了age属性\r\n  ```\r\n\r\n- JSON_REMOVE 删除JSON数据，删除指定值后的JSON文档\r\n\r\n  ```sql\r\n  select json_remove(\'{\"name\":\"json\"}\',\'$.name\'); -- 删除了name属性\r\n  ```\r\n\r\n**json还提供了许多其它函数，可自行查询网络资料，注意看当前使用的mysql版本是否支持该函数，一定要实践**\r\n\r\n##### json字段查询\r\n\r\n​    mysql5.7版本提供了两种方式获取json字段的单值\r\n\r\n  1. json_extract解析json的值\r\n\r\n  2. column->path的形式\r\n\r\n  3. 用法\r\n\r\n     - .keyName 获取JSON对象中键名为keyName的值\r\n\r\n       ```sql\r\n       SELECT json_extract(data,\'$.name\') from test; -- 获取data字段中key为name的value\r\n       SEKECT data->\'$.name\' from test;--等价于select json_extract(data,\'$.name\') from test\r\n       SELECT data->>\'$.name\' from test; --等价于select json_unquote(json_extract(data,\'$.name\')) from test;\r\n       ```\r\n\r\n     - 对于不合法的键名（如有空格），在路径引用中必须用双引号\"将键名括起来\r\n\r\n       ```sql\r\n       select json_extract(data,\'$.\"address info\"\') from test;\r\n       select data->\'$.\"address info\"\' from test;\r\n       ```\r\n\r\n     - [index]：JSON数组中索引为index的值，JSON数组的索引同样从0开始\r\n\r\n       ```sql\r\n       select json_extract(data,\'$[0]\') from test;\r\n       select data->\'$[0]\' from test;\r\n       ```\r\n\r\n     - [ index1 to index2]：~~JSON数组中从index1到index2的值的集合,可能跟版本有关系，mysql5.7.29版本验证没有通过~~\r\n\r\n       ```sql\r\n       select data->\'$[0 to 2]\' from test;\r\n       ```\r\n\r\n     - .*:JSON对象中的所有value,**注意是value，不获取key**\r\n\r\n       ```sql\r\n       select json_extract(data,\'$.*\') from test;\r\n       select data->\'$.*\' from test;\r\n       ```\r\n\r\n     - [*] :JSON数组中的所有值\r\n\r\n       ```sql\r\n       select data->\'$[*]\' from test;\r\n       select json_extract(data,\'$[*]\') from test;\r\n       ```\r\n\r\n     - 查询不存在的属性返回结果为NULL\r\n\r\n     - 支持访问嵌套属性\r\n\r\n       ```sql\r\n       select data->\'$.list[0].age\' from test;\r\n       ```\r\n\r\n**注意column->>key方式可以去掉value的引号，同json_unquote(json_extract(column,\'$.key\'))**\r\n\r\n##### json字段where条件过滤\r\n\r\n- where后面直接使用json_extract或者column->key格式\r\n\r\n  ```sql\r\n  select * from test where json_extract(data,\'$.age\')>10;  -- where后面使用json_extract 走全表扫描，不会使用索引\r\n  select * from test where data->\'$.age\'=10;\r\n  ```\r\n\r\n- 虚拟列方式\r\n\r\n  ```sql\r\n  ALTER TABLE test  ADD name_virtual  varchar (32) GENERATED ALWAYS  AS (json_extract(data,  \'$.name\' )) VIRTUAL;\r\n  \r\n  select * from test where name_virtual=\'\"json\"\'; -- 像正常字段一样访问虚拟列\r\n  select name_virtual from test;\r\n  ```\r\n\r\n  **注意:**   \r\n\r\n  1. 插入数据时不可以向虚拟列插入数值,也不可以更新虚拟列值，否则会报错，只需要更新或写入json字段值，mysql会自动映射虚拟列值\r\n\r\n  2. 创建虚拟列是varchar类型，并且where条件是虚拟列\r\n\r\n     - 若创建表时就创建了虚拟列，则查询条件值需要加双引号\r\n\r\n       ```sql\r\n       select * from test where name_virtual=\'\"json\"\';\r\n       ```\r\n\r\n     - 若表中已经有数据，之后才创建了虚拟列，虚拟列映射的值可能有数值类型，也可能有字符串类型，where条件带双引号和不带双引号可能都不合适,  建议创建json字段时根据业务场景就要创建好虚拟列，或者一定要保证某key数据类型的一致性\r\n\r\n  3. 使用 column->key和json_extract方式不需要加双引号，mysql内部会自动过滤\r\n\r\n     ```sql\r\n     select * from test where data->\'$.num\'=\'34\';\r\n     ```\r\n\r\n   - 对虚拟列创建索引\r\n\r\n        ```sql\r\n        CREATE INDEX name_virtual_index  ON test(name_virtual);\r\n        ```\r\n\r\n#####  48环境坑 \r\n\r\n- 执行任何sql报错\r\n           Expression #1 of ORDER BY clause is not in GROUP BY clause and contains nonaggregated column \'information_schema.PROFILING.SEQ\' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by\r\n           原因:sql _mode中only _full _group _by不兼容\r\n           暂时解决方式:SET sql_mode=(SELECT REPLACE(@@sql_mode,\'ONLY_FULL_GROUP_BY\',\'\'));\r\n           根治方式:my.ini 配置sql_mode\r\n- 创建包含json字段的表，查询不到json字段\r\n          create table test(\r\n              id int(11) NOT NULL PRIMARY KEY AUTO_INCREMENT,\r\n              data json,\r\n              age int(11)\r\n          );\r\n          select * from test;   -- 只查询到了id,age列\r\n        原因:**可能是navicat客户端的问题，用mysql命令行，可以正常展示json字段列**     \r\n\r\n##### php代码测试json字段	\r\n\r\n```php\r\n//mysqli方式\r\n $conn = mysqli_connect(\"hostname\",\"root\",\"a12345\",\"demo\");\r\n\r\n mysqli_query($conn, \"set names utf8\");\r\n\r\n $ret = mysqli_query($conn, \"select * from test\");\r\n\r\n $row = mysqli_fetch_assoc($ret);\r\n var_dump($row);\r\n\r\n//pdo方式\r\n $pdo = new PDO(\"mysql:host=hostname;dbname=demo\",\"root\",\"a12345\");\r\n $pdo->query(\"set names utf8\");\r\n $result = $pdo->query(\"SELECT * FROM test\"); \r\n```\r\n\r\n- 结论\r\n  1. php不能将json字段自动解析成php数组，mysql的json数据字段返回的结果是json字符串，如果需要使用,则需要php json_decode解析成数组\r\n  2. **查询json的varchar虚拟列，若json字段该key存储的是字符串，返回的结果是带有双引号的值，如\"范晓杰\",而不是期望的:范晓杰，若json字段该key存储的是整形，则返回的结果是常规字符串,需要特别注意**\r\n     - 解决方式:\r\n       - 结果在php层面使用json_decode解析\r\n       - 使用mysql函数JSON_UNQUOTE去双引号，例如:select JSON_UNQUOTE(data->\'$.name\') from test;\r\n\r\n##### 进阶技巧分享\r\n\r\n​	如果你通过上面的测试，以及结合php测试，可以发现有如下的几个不方便的地方\r\n\r\n- 查询json某字符串key返回的是带有双引号的值，如\"value\"\r\n- where条件之后使用data->\'$.name\'=\'\"xxxx\"\'的形式，或者json_extract(data,\'$.name\')=\'xx\'的形式会全表扫描\r\n- where条件包含虚拟列过滤时，需要特别注意添加\"\",例如name_virtual=\'\"json\"\',代码层面可能多很多双引号，必要时需要使用\\去转义，也很容易忘记添加双引号造成不必要的bug\r\n- 返回的字符串虚拟列也带有双引号，如\"json\",业务代码需要json_decode特殊处理\r\n\r\n基于以上问题有如下解决方式\r\n\r\n```sql\r\nALTER TABLE test  ADD name_virtual_1  varchar (32) GENERATED ALWAYS  AS (json_unquote(json_extract(data,  \'$.name\' ))) VIRTUAL; -- 不带双引号的value,创建虚拟列\r\nalter table test add index name_virtual_index_1(name_virtual_1); --虚拟列加索引\r\n```\r\n\r\n通过以上sql解决了问题\r\n\r\n- 通过虚拟列查询，使用了索引，可以用explain查看\r\n- where条件不需要\"json\"了，直接使用json，跟其它字符串查询一致，不需要使用select * from test where name_virtual=\'\"json\"\'，直接使用select * from test where name_virtual=\'json\';\r\n- 返回的name_virtual_1字段不再包含\"\"，跟字符串一样, 不再需要业务层json_decode\r\n\r\n#####  其它注意问题\r\n\r\n- 创建虚拟列要考虑历史数据的字段类型，json字段里面不限制字段类型，比如表里已经存在数据{\"name\":\"json\",\"age\":\"范晓杰\"}，执行如下sql\r\n\r\n  ```sql\r\n  ALTER TABLE test  ADD age  int(11) GENERATED ALWAYS  AS (json_unquote(json_extract(data,  \'$.age\' )));\r\n  ```\r\n\r\n  再写入数据则会报错，即使写入的age字段是int类型也会报错，所以要写入正确的数据，或者根据业务场景在创建json字段时及时创建虚拟列\r\n\r\n- 不要使用json_set(data,\'$.name\',NULL)试图删除name列，mysql会存储为null字符串，php查询结果是\"null\"而不是NULL，要使用json_remove',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,965,0),(17,'php基础之isset和array_key_exists','17',1591923158,1591923158,'<!--markdown-->- array_key_exists() 会检查键值的存在. 这个函数会返回TRUE，只要键值存在，即使值为NULL\r\n- isset()会同时检查键和值，只有当健存在，且对应的值不为NULL的时候才会返回TURE\r\n\r\n```php\r\n$arr = array(\r\n    \"one\"   => 1,\r\n    \"two\"   =>  null,\r\n);\r\nvar_dump(array_key_exists(\"one\",$arr),array_key_exists(\"two\",$arr),isset($arr[\"one\"]),isset($arr[\'two\']));\r\n\r\n//bool(true) bool(true) bool(true) bool(false)\r\n```',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,618,0),(18,'php版Redis并发锁的正确实现方式','18',1592043600,1592044068,'<!--markdown-->## 加锁\r\n### 正确加锁的实现方式\r\n```php\r\n<?\r\nclass Lock {\r\n    \r\n    public const SET_IF_NOT_EXIST = \"NX\";\r\n    public const SET_EXPIRE_TIME = \"EX\";\r\n    \r\n    /**\r\n     * [getLock 加锁]\r\n     * @param  $redis      [redis对象]\r\n     * @param  $lockKey    [redis key]\r\n     * @param  $requestId  [value]\r\n     * @param  $expireTime [锁的过期时间]\r\n     */\r\n    public static function getLock($redis, $lockKey, $requestId, $expireTime) {\r\n        \r\n        if($redis->set($lockKey, $requestId,[self::SET_IF_NOT_EXIST, self::SET_EXPIRE_TIME=>$expireTime])) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n```\r\n可以看到getLock的实现其实就一行代码\r\n```php\r\n$redis->set($lockKey, $requestId,[self::SET_IF_NOT_EXIST, self::SET_EXPIRE_TIME=>$expireTime])\r\n```\r\n这个方法共有四个参数\r\n- lockKey 锁的key，也就是redis中的key\r\n- requestId 锁存储的value，一般用请求的唯一标识作为value，可以使用uuid库生成，用于解锁时使用，否则的话解锁时区分不了请求\r\n- NX 意思是SET IF NOT EXIST，即当key不存在时，我们进行redis上锁操作；若key已经存在，则不做任何操作\r\n- expireTime 给key设置一个过期时间\r\n\r\n执行上面的set()方法就只会导致两种结果：\r\n1. 当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时requestId表示加锁的客户端\r\n2. 已有锁存在，不做任何操作\r\n\r\n仔细分析这个set方法，可以发现，这个锁的几个特点\r\n- 互斥性\r\n	set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性\r\n- 无死锁\r\n对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除）\r\n- 可解锁\r\n将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端\r\n\r\n### 错误的实现方式\r\n#### setnx组合expire命令\r\n```php\r\n	/**\r\n     * [getLock 加锁]\r\n     * @param  $redis      [redis对象]\r\n     * @param  $lockKey    [redis key]\r\n     * @param  $requestId  [value]\r\n     * @param  $expireTime [锁的过期时间]\r\n     */\r\n    public static function getLock($redis, $lockKey, $requestId, $expireTime) {\r\n        \r\n        if($redis->setnx($lockKey, $requestId)) {\r\n        	$redis->expire($lockKey,$expireTime);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n```\r\n乍一看好像和前面的set()方法结果一样，然而由于这是两条Redis命令，**不具有原子性**，如果程序在执行完setnx()之后突然崩溃，导致锁没有设置过期时间,那么将会发生死锁。\r\n\r\n#### 利用客户端时间\r\n```php\r\n	/**\r\n     * [getLock 加锁]\r\n     * @param  $redis      [redis对象]\r\n     * @param  $lockKey    [redis key]\r\n     * @param  $expireTime [锁的过期时间]\r\n     */\r\n    public static function getLock($redis, $lockKey, $expireTime) {\r\n        \r\n        $expireStr = time() + $expireTime;\r\n        if($redis->setnx($lockKey, $expireStr)) {\r\n            return true;\r\n        }\r\n        $redis_value = $redis->get($lockKey);\r\n        if($redis_value && $redis_value<time()) {\r\n        	$old_value = $redis->getset($lockKey,$expireStr);\r\n        	if($old_value && $old_value == $redis_value) {\r\n        		return true;\r\n        	}\r\n        }\r\n        return false;\r\n    }\r\n```\r\n实现过程如下\r\n1. 通过setnx()方法尝试加锁，如果当前锁不存在，返回加锁成功。\r\n2. 如果锁已经存在则获取锁的过期时间，和当前时间比较，如果锁已经过期，则设置新的过期时间，并且返回加锁成功。\r\n\r\n这个实现的问题在于\r\n- 依赖于服务器的本地时间，如果分布式，则要求各个机器的时间必须一致\r\n- 若锁过期，多个请求同时执行getset，则只有一个获取锁成功，但是获取锁的这个请求的过期时间可能被其它客户端覆盖\r\n- 锁没有用户标识，任何人都可以解锁\r\n\r\n## 解锁\r\n### 正确解锁的实现方式\r\n```php\r\n	/**\r\n     * [getLock 加锁]\r\n     * @param  $redis      [redis对象]\r\n     * @param  $lockKey    [redis key]\r\n     * @param  $requestId  [value]\r\n     */\r\n    public static function releaseLock($redis,$lockKey, $requestId ) {\r\n\r\n    	$script = \"if redis.call(\'get\', \'$lockKey\') == \'$requestId\' then return redis.call(\'del\', \'$lockKey\') else return 0 end\";\r\n        return $redis->eval($script);\r\n    }\r\n```\r\n使用了redis->eval方法来解锁，redis天然集成了lua，eval方法是将lua代码交给redis服务器端执行。\r\n```php\r\n$script = \"if redis.call(\'get\', \'$lockKey\') == \'$requestId\' then return redis.call(\'del\', \'$lockKey\') else return 0 end\";\r\n```\r\n首先获取锁lockKey对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁）,使用eval的目的是就是实现原子操作\r\n\r\n### 错误解锁方式\r\n#### 暴力删除\r\n```php\r\npublic static function releaseLock($redis,$lockKey ) {\r\n    return $redis->del($lockKey);\r\n}\r\n```\r\n没有区分客户端，无论是不是自己锁定的，强制解锁了,任何客户端都可以随时进行解锁，即使这把锁不是自己占用的\r\n\r\n#### 迷惑性错误\r\n```php\r\npublic static function releaseLock($redis,$lockKey,$requestId ) {\r\n	if($redis->get($lockKey) == $requestId) {\r\n		return $redis->del($lockKey);\r\n	}\r\n}\r\n```\r\n这个看上似乎没什么问题，其实仔细分析，还是有点儿问题的，就是没有实现原子性。如果客户端A加锁，一段时间之后客户端A解锁，在A执行del()之前，锁突然过期了，此时客户端B尝试加锁成功，然后客户端A再执行del()方法，则将客户端B的锁给解除了\r\n\r\n**关于redis锁的问题，实际应用场景中还有很多方法，各种各样的实现，各种各样的坑，值得我们去分析和研究，只要我们记住始终用原子操作，就不会有太大问题**',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,744,0),(19,'神奇的strtotime函数','19',1592053860,1592054141,'<!--markdown-->### 起因\r\n工作中因为业务的关系，需要查询从上一个月1号到当前时间的数据，于是使用了如下代码表示查询时间的起始时间\r\n```php\r\ndate(\"Y-m-1\",strtotime(\"-1 month\"))\r\n```\r\n突然有一天测试同学在测试过程中发现数据不对，于是经过层层打断点发现，起始时间不是上一个月的1号，而是这一个月的一号，好奇怪，然后经过搜索资料，发现了亚一程鸟哥博客上的解释\r\n\r\n### 正文\r\n如果今天是2018-07-31 ,执行代码\r\n```php\r\ndate(\"Y-m-d\",strtotime(\"-1 month\"))\r\n```\r\n输出的结果是2018-07-01\r\n\r\n鸟哥给出的内部逻辑如下:\r\n\r\n - 先做-1 month, 那么当前是07-31, 减去一以后就是06-31.\r\n \r\n- 再做日期规范化, 因为6月没有31号, 所以就好像2点60等于3点一样, 6月31就等于了7月1\r\n\r\n可以通过如下几个测试验证确实如鸟哥所说\r\n```php\r\nvar_dump(date(\"Y-m-d\", strtotime(\"-1 month\", strtotime(\"2017-03-31\"))));\r\n//输出2017-03-03\r\nvar_dump(date(\"Y-m-d\", strtotime(\"+1 month\", strtotime(\"2017-08-31\"))));\r\n//输出2017-10-01\r\nvar_dump(date(\"Y-m-d\", strtotime(\"next month\", strtotime(\"2017-01-31\"))));\r\n//输出2017-03-03\r\nvar_dump(date(\"Y-m-d\", strtotime(\"last month\", strtotime(\"2017-03-31\"))));\r\n//输出2017-03-03\r\n\r\n```\r\n#### 规避方式\r\n从PHP5.3开始, date新增了一系列修正短语, 来明确这个问题, 那就是\"first day of\" 和 \"last day of\", 也就是你可以限定好不要让date自动\"规范化\"\r\n\r\n```php\r\nvar_dump(date(\"Y-m-d\", strtotime(\"last day of -1 month\", strtotime(\"2017-03-31\"))));\r\n//输出2017-02-28\r\nvar_dump(date(\"Y-m-d\", strtotime(\"first day of +1 month\", strtotime(\"2017-08-31\"))));\r\n//输出2017-09-01\r\nvar_dump(date(\"Y-m-d\", strtotime(\"first day of next month\", strtotime(\"2017-01-31\"))));\r\n//输出2017-02-01\r\nvar_dump(date(\"Y-m-d\", strtotime(\"last day of last month\", strtotime(\"2017-03-31\"))));\r\n//输出2017-02-28\r\n```',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,569,0),(20,'新人必须走的php小坑','20',1592093940,1592094108,'<!--markdown-->### intval或者int整形转换\r\n\r\n工作中遇到过后端跟前端交互时，前端传递了\"null\"或者\"undefined\"字符串，后端做了强制转整形，(int)参数,\r\n结果(int)\"undefined\"值是0，很是惊讶，第一感觉应该是1才对啊，于是查了手册，才知道官方的解释：\r\n\r\n- 如果参数是字符串，则返回字符串中第一个不是数字的字符之前的数字串所代表的整数值。\r\n- 如果字符串第一个是‘-\'，则从第二个开始算起。\r\n- 如果参数是符点数，则返回他取整之后的值。\r\n- 当然intval()返回的值在一个4字节所能表示的范围之内（-2147483648~2147483647），对于超过这个范围的值将用边界值代替\r\n\r\n### 浮点数精度问题\r\n```php\r\nvar_dump((0.1 + 0.7) * 10 === 0.8 * 10);//boolean false\r\n\r\nvar_dump((0.1 + 0.7) * 100 === 0.8 * 100);//boolean true\r\n\r\necho intval(0.58 * 100);//57\r\n```\r\n因为浮点数在底层存储的是一个近似值，并不是确切的值，所以运算结果也是一个近似值\r\n\r\n**浮点数不要参与比较**\r\n\r\n### 慎用用strpos或者array_search做if判断\r\n\r\n- strpos是查找字符串首次出现的位置，如果没有查询到返回布尔值false，注意如果子字符串在开头，返回位置0\r\n```php\r\nvar_dump(strpos(\"hello\",\"h\"));//返回0\r\n```\r\n- array_search函数在数组中搜索某个键值，并返回对应的键名,注意如果查找的键值是第一个，返回0\r\n```php\r\nvar_dump(array_search(\"aa\",[\'aa\',\'bb\',\'cc\']));\r\n//返回0\r\n```\r\n\r\n综上，当用if判断是否存在时不能使用\r\n```php\r\nif(strpos(xx,xx)) {\r\n	//do something\r\n}\r\n\r\nif(array_search(xx,xx)) {\r\n	//do something\r\n}\r\n```\r\n需要使用恒等式\r\n```php\r\nif(strpos(xx,xx) !== false) {\r\n	//do something\r\n}\r\n\r\nif(array_search(xx,xx) !== false) {\r\n	//do something\r\n}\r\n```\r\n\r\n### url请求参数中的0\r\n业务中有时候需要前端传递bool参数，通常用0或者1代替bool值，这时候需要特别注意了，url中的参数值是一个字符串，使用$_GET或者$_POST获取的是一个\"0\"字符串，\"0\"直接if判断结果是true，因此使用if判断时要特别注意\r\n```php\r\n//错误\r\nif($_GET[\'xx\']) {\r\n\r\n}\r\n//正确\r\nif($_GET[\'xx\'] == 0) {\r\n\r\n}\r\n```',0,1,NULL,'post','publish',NULL,1,'1','1','1',0,801,0),(21,'ArrayAccess（数组式访问）接口','21',1592121900,1592122389,'<!--markdown-->ArrayAccess是PHP提供的一个接口，其作用是**使得你的对象可以像数组一样被访问**\r\n\r\n什么意思呢？我们直接看使用方法\r\n```php\r\n<?php\r\nclass Container implements ArrayAccess {\r\n        \r\n    private $elements;\r\n    \r\n    public function offsetExists($offset){\r\n        return isset($this->elements[$offset]);\r\n    }\r\n    \r\n    public function offsetSet($offset, $value){\r\n        $this->elements[$offset] = $value;\r\n    }\r\n    \r\n    public function offsetGet($offset){\r\n        return $this->elements[$offset];\r\n    }\r\n    \r\n    public function offsetUnset($offset){\r\n        unset($this->elements[$offset]);\r\n    }\r\n}\r\n$di = new Container();\r\n$di[\'name\'] = \'hello world\';\r\n\r\nvar_dump($di[\'name\'],isset($di[\'name\']));//true true\r\n\r\nunset($di[\'name\']);\r\nvar_dump($di[\'name\'],isset($di[\'name\']));//null false\r\n\r\n?>\r\n```\r\n看到没有我们可以像访问数组一样访问对象，其实很简单,\r\nArrayAccess接口为我们提供了4个抽象方法，只有我们实现了这几个抽象方法就可以了\r\n```php\r\nArrayAccess {\r\n/* 方法 */\r\n	abstract public offsetExists ( mixed $offset ) : boolean\r\n	\r\n	abstract public offsetGet ( mixed $offset ) : mixed\r\n	\r\n	abstract public offsetSet ( mixed $offset , mixed $value ) : void\r\n	\r\n	abstract public offsetUnset ( mixed $offset ) : void\r\n}\r\n```\r\n\r\n- $di[xxx] 对应调用offsetGet方法\r\n\r\n- $di[xxx] = \'yyy\' 对应调用offsetSet方法\r\n\r\n- isset($di[xxx]) 对应调用offsetExists方法\r\n\r\n- unset($di[xxx]) 对应调用offsetUnset方法\r\n',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,610,0),(22,'http请求之curl和stream流','22',1592354455,1592354455,'<!--markdown-->### Curl\r\n- get请求\r\n```php\r\nfunction get($url) {\r\n    $ch = curl_init();\r\n    curl_setopt($ch, CURLOPT_URL, $url);\r\n    $header = array(\r\n        \'Content-Type: application/json\',\r\n    );\r\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\r\n    //设置获取的信息以文件流的形式返回，而不是直接输出。  \r\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);  \r\n    if(substr($url, 0, 5) == \'https\') {\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\r\n    }\r\n    $output = curl_exec($ch);\r\n    \r\n    if($output === false) {\r\n        $error = curl_error($ch);\r\n        throw new Exception(\"Curl request error:\".$error);\r\n        \r\n    } \r\n    curl_close($ch);\r\n    return $output;\r\n}\r\n```\r\n- post请求\r\n```php\r\nfunction post($url, $data, $content_type=\'\') {\r\n\r\n    $ch = curl_init();\r\n    curl_setopt($ch, CURLOPT_URL, $url);\r\n    \r\n    if($content_type == \"json\"){\r\n        $contentType = \"application/json\";\r\n        $post_string = json_encode($data);\r\n    }else{\r\n        $contentType = \"application/x-www-form-urlencoded\";\r\n        $post_string = http_build_query($data);\r\n    }\r\n    $header = array(\r\n        \'Content-Type: \'.$contentType,\r\n        \'Content-Length: \' . strlen($post_string),\r\n    );\r\n    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);\r\n    //设置获取的信息以文件流的形式返回，而不是直接输出。  \r\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);  \r\n    curl_setopt($ch, CURLOPT_POST, 1);\r\n    curl_setopt($ch, CURLOPT_POSTFIELDS, $post_string);\r\n    if(substr($url, 0, 5) == \'https\') {\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\r\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\r\n    }\r\n    $output = curl_exec($ch);\r\n    \r\n    if($output === false) {\r\n        $error = curl_error($ch);\r\n        throw new Exception(\"Curl request error:\".$error);\r\n        \r\n    } \r\n    curl_close($ch);\r\n    return $output;\r\n}\r\n```\r\n注意post请求有两个选项\r\n```php\r\ncurl_setopt($ch, CURLOPT_POST, 1);\r\ncurl_setopt($ch, CURLOPT_POSTFIELDS, $post_string);\r\n```\r\n**需要特别注意的是，如果你的请求有https请求，最好加下面的代码，表示不验证https证书，不加的话,https请求可能报错**\r\n```php\r\ncurl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE); // https请求 不验证证书和hosts\r\ncurl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);\r\n```\r\n\r\n### stream流\r\n```php\r\n\r\nfunction post($url, $data, $content_type =\'application/x-www-form-urlencoded\') {\r\n    if($content_type == \"json\"){\r\n        $contentType = \"application/json\";\r\n        $postdata = json_encode($data);\r\n    }else{\r\n        $contentType = \"application/x-www-form-urlencoded\";\r\n        $postdata = http_build_query($data);\r\n    }\r\n\r\n    $opts = array(\r\n        \'http\' => array(\r\n            \'method\' => \"POST\",\r\n            \'header\' => \"Connection: close\\r\\n\".\r\n                \"Content-type: $contentType\\r\\n\".\r\n                \"Content-Length: \".strlen($postdata).\"\\r\\n\",\r\n            \'content\' => $postdata,\r\n            \'timeout\' => 180\r\n        )\r\n        ,\'ssl\' => array(\r\n            \'verify_peer\' => false,\r\n            \'verify_peer_name\' => false,\r\n            \'allow_self_signed\' => true\r\n        )\r\n    );\r\n    $context = stream_context_create($opts);\r\n    return file_get_contents($url, false,$context);\r\n}\r\nvar_dump(post(\"http://web.demo.com:8899/test.php\",[\'name\'=>\'hello world\'],\'json\'));\r\n\r\n```\r\n注意这里的ssl设置，之前遇到的问题是我们php版本有5.5.3升级到5.6.40,结果发送邮件以及http请求都请求不出去了，查看底层才知道是因为ssl版本的问题，所以加了ssl不验证ssl证书，问题解决了\r\n\r\n### 其它\r\n工作中用的最多的就是使用curl发送http请求了，尝试追踪过[guzzle/guzzle](https://github.com/guzzle/guzzle)这个库的源码，她的底层也是用的上面两种方式，不过还有其它请求方式，有兴趣的同学可以去研究下，比如下面几种方式:\r\n- fsockopen\r\n- fopen\r\n- file_get_contents \r\n',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,1046,0),(23,'git之shell脚本一键将代码cherry-pick到多个branch','23',1592629476,1592629476,'<!--markdown-->工作中因为产品以及项目本身的特性，我们同一个项目会存在多个版本，不同客户可能使用不同版本的产品，因此发现bug或者有紧急需求，代码需要合并到多个版本，我们用branch分支管理版本，这时候需要一个一个分支去cherry-pick很是麻烦，所以开发了下面一个shell脚本，再也不需要手动去切换版本cherry-pick代码了，实现简单的一键合并代码，**仅用来替代cherry-pick**\r\n\r\n### 脚本代码\r\n我们命名脚本文件名称是cherry-pick.sh\r\n```shell\r\n#!/usr/bin/bash\r\n\r\nif [ $# -eq 0 ]\r\nthen\r\n    echo \"cherry-pick hashcode can not empty\"\r\n    exit\r\nfi\r\n\r\nbr=`git branch | grep \"*\"`\r\ngit fetch\r\nbranchlist=(20.2.2 20.2.1 20.1.1 19.10.1)   #版本号列表\r\nfor branch in ${branchlist[@]}\r\ndo\r\n    git checkout branch/${branch}\r\n    git reset --hard HEAD #清理工作区内容\r\n    git rebase origin/branch/${branch}\r\n    if [ $? -ne 0 ]\r\n    then\r\n        echo \"git rebase origin/branch/${branch} error\"\r\n        exit\r\n    fi\r\n    \r\n    git cherry-pick $*\r\n    if [ $? -ne 0 ]\r\n    then\r\n        echo \"git cherry-pick {$*} for branch/${branch} error\"\r\n        exit\r\n    fi\r\n    git push origin branch/${branch}\r\ndone\r\n#重新切换到当前分支\r\ngit checkout ${br/* /}\r\n```\r\n### 使用方式\r\n- ./cherry-pick.sh 哈希值,举例如下\r\n```\r\n./cherry-pick.sh 1b40a0ce89\r\n```\r\n- ./cherry-pick.sh 多个连续的哈希值,举例如下\r\n```\r\n./cherry-pick.sh 1b40a0ce89 4b93149554 51533b9f80 c2cbea077f\r\n```\r\n**注意**\r\n- 若合并过程中存在冲突的版本，则会中断合并，需要手动解决冲突\r\n- 合并成功之后会重新切换到执行命令前所在的分支',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,894,0),(24,'Laravel依赖注入容器抽取','24',1592984280,1593942719,'<!--markdown-->### 起因\r\nLaravel是一个很优雅的框架，这一点不容置疑，laravel实现的很松耦合，有些组件库可以在自己的非laravel项目里用(只要你的项目使用composer)，比如illuminate/database这个orm，就是一个独立的repository，我们composer执行下面的命令就可以将laravel的数据库orm安装到自己的项目了\r\n```\r\ncomposer require illuminate/database\r\n```\r\n个人对Laravel的服务容器很感兴趣，想单独拿出来用，高兴的是官方也将Container容器单独抽离出一个仓库illuminate/container，我看了下这个仓库下的composer.json文件，依赖illuminate/contracts仓库，通过阅读Container类我发现其实只依赖illuminate/contracts下的container约定，其它的约定完全不需要，也就是说illuminate/contracts仓库下面的其它契约成了多余的代码，这对我来说完全受不了，容忍不了多余没有用的代码。\r\n\r\n因此我就单独拉了一个仓库，代码完全来自illuminate/container仓库以及illuminate/contracts仓库下Illuminate/Contracts/Container命名空间下的代码，当然为了使用composer，所以我需要改下仓库，因此命名空间变更成了自己的命名空间，其它Laravel服务容器原有相关的方法100%可用；另外有些原有的功能在手册或者教程上并没有，通过阅读代码发现了已有的功能，也罗列出了用法\r\n\r\n### 安装\r\n```shell\r\ncomposer require fanqingxuan/container\r\n```\r\n### demo\r\n看下面的例子\r\n```php\r\nrequire_once \'./vendor/autoload.php\';\r\n\r\nuse JsonContainer\\Container;\r\n\r\n$container = new Container;\r\n\r\nclass HomeController {\r\n\r\n    private $userService;\r\n\r\n    public function __construct(UserService $userService) {\r\n        $this->userService = $userService;\r\n    }\r\n\r\n    public function say() {\r\n        return $this->userService->getUser();\r\n    }\r\n}\r\n\r\ninterface UserService {\r\n\r\n    public function getUser();\r\n}\r\n\r\nclass UserServiceImpl implements UserService {\r\n\r\n    private $userDao;\r\n\r\n    public function __construct(UserDao $userDao) {\r\n        $this->userDao = $userDao;\r\n    }\r\n\r\n    public function getUser() {\r\n        return $this->userDao->getUser();\r\n    }\r\n}\r\n\r\nclass UserDao {\r\n\r\n    public function getUser() {\r\n        return \"this is userdao/getuser\";\r\n    }\r\n}\r\n\r\n$container->bind(HomeController::class,HomeController::class);\r\n$container->bind(UserService::class,UserServiceImpl::class);\r\n$container->bind(UserDao::class,UserDao::class);\r\n\r\n$homeController = $container->make(HomeController::class)->say();\r\nprint($homeController);\r\n```\r\n有没有发现，每一个类不再依赖具体的实现类，通过依赖注入容器实现控制反转\r\n\r\n### 使用\r\n\r\n- bind简单绑定\r\n\r\nbind方法的第一个参数为要绑定的类 / 接口名，第二个参数是一个Closure\r\n\r\n```php\r\nrequire_once \'./vendor/autoload.php\';\r\n\r\nuse JsonContainer\\Container;\r\n\r\n$container = new Container;\r\n\r\nclass Test {\r\n\r\n}\r\n\r\n$container->bind(\"test\",function() {\r\n    return new Test;//返回实例对象\r\n});\r\n\r\n$container->bind(\"hello\",function() {\r\n    return \"hello world\";//返回字符串\r\n});\r\n```\r\n\r\n- singleton单例绑定\r\n\r\nsingleton方法将类或接口只解析一次绑定到容器中。一旦单例绑定被解析，相同的对象实例会在随后的调用中返回到容器中\r\n\r\n```php\r\nrequire_once \'./vendor/autoload.php\';\r\n\r\nuse JsonContainer\\Container;\r\n\r\n$container = new Container;\r\n\r\nclass Test {\r\n\r\n}\r\n\r\n$container->singleton(\"test\",function() {\r\n    return new Test;\r\n});\r\n```\r\n- instance实例绑定\r\n\r\n绑定实例,将现有对象实例绑定到容器中。给定的实例会始终在随后的调用中返回到容器中\r\n\r\n```php\r\nrequire_once \'./vendor/autoload.php\';\r\n\r\nuse JsonContainer\\Container;\r\n\r\n$container = new Container;\r\n\r\nclass Test {\r\n\r\n}\r\n\r\n$container->instance(\"test\",new Test);\r\n```\r\n- 基本值绑定\r\n\r\n当你有一个类不仅需要接受一个注入类，还需要注入一个基本值（比如整数）。你可以使用上下文绑定来轻松注入你的类需要的任何值\r\n\r\n```php\r\nrequire_once \'./vendor/autoload.php\';\r\n\r\nuse JsonContainer\\Container;\r\n\r\n$container = new Container;\r\n\r\nclass HomeController {\r\n\r\n    private $id;\r\n\r\n    public function __construct($id) {\r\n        $this->userService = $userService;\r\n        $this->id = $id;\r\n    }\r\n\r\n    public function say() {\r\n        return $this->id;\r\n    }\r\n}\r\n\r\n$value = 32;\r\n$container->when(HomeController::class)\r\n          ->needs(\'$id\')\r\n          ->give($value);\r\n```\r\n- 绑定接口到实现\r\n\r\nLaravel的服务容器有一个很强大的功能，就是支持绑定接口到给定的实现，这样的好处是某一天你可能有另一种实现，只需要修改绑定接口的实现代码就可用了，而业务代码不需要任何改动。例如，如果有个Cache接口 和一个 RedisCache实现。一旦我们写完了 Cache 接口的 RedisCache 实现，我们就可以在服务容器中注册它，像这样：\r\n\r\n```php\r\n$this->app->bind(\r\n    Cache::class,\r\n    RedisCache::class\r\n);\r\n```\r\n意思是当一个类需要实现 Cache 时，应该注入 RedisCache,注入依赖项时，我们就可以使用注入Cache接口，而不需要注入具体实现，就像上面demo中的注入依赖项UserService接口，而不是具体实现\r\n\r\n```php\r\nclass HomeController {\r\n\r\n    private $userService;\r\n\r\n    public function __construct(UserService $userService) {\r\n        $this->userService = $userService;\r\n    }\r\n\r\n    public function say() {\r\n        return $this->userService->getUser();\r\n    }\r\n}\r\n\r\ninterface UserService {\r\n\r\n    public function getUser();\r\n}\r\n\r\nclass UserServiceImpl implements UserService {\r\n\r\n    private $userDao;\r\n\r\n    public function __construct(UserDao $userDao) {\r\n        $this->userDao = $userDao;\r\n    }\r\n\r\n    public function getUser() {\r\n        return $this->userDao->getUser();\r\n    }\r\n}\r\n```\r\n- 按需绑定\r\n\r\n有时你可能有两个类使用了相同的接口，但你希望各自注入不同的实现。比如一个service可能希望memcache缓存，另一个service希望redis缓存\r\n\r\n```php\r\nrequire_once \'./vendor/autoload.php\';\r\n\r\nuse JsonContainer\\Container;\r\n\r\n$container = new Container;\r\n\r\n\r\nclass Cache {\r\n\r\n}\r\n\r\nclass Memcache extends Cache {\r\n\r\n}\r\n\r\nclass Redis extends Cache {\r\n\r\n}\r\n\r\nclass UserService {\r\n\r\n    private $cache;\r\n\r\n    public function __construct(Cache $cache) {\r\n        $this->cache = $cache;\r\n    }\r\n\r\n    public function say() {\r\n        print_r($this->cache);\r\n    }\r\n}\r\n\r\nclass OrderService {\r\n\r\n    private $cache;\r\n\r\n    public function __construct(Cache $cache) {\r\n        $this->cache = $cache;\r\n    }\r\n\r\n    public function say() {\r\n        print_r($this->cache);\r\n    }\r\n}\r\n\r\n$container->when(UserService::class)\r\n          ->needs(Cache::class)\r\n          ->give(function () {\r\n              return new Memcache;\r\n          });\r\n\r\n$container->when([OrderService::class, ImageService::class])\r\n          ->needs(Cache::class)\r\n          ->give(function () {\r\n              return new Redis;\r\n          });\r\n\r\nprint_r($container->make(UserService::class)->say());\r\nprint_r($container->make(OrderService::class)->say());\r\n```\r\n根据输出可以反省，UserService注入的是Memcache，而OrderService注入的是Redis\r\n\r\n- 标记\r\n\r\n有时候，你可能需要为容器中的服务分类，比如memcache，redis都属于cache，你可以使用 tag 方法给他们分配一个标签,一旦服务被打上标签，你就可以通过 tagged 方法轻松获取标签下的服务\r\n\r\n```php\r\nclass Cache {\r\n\r\n}\r\n\r\nclass Memcache extends Cache {\r\n\r\n}\r\n\r\nclass Redis extends Cache {\r\n\r\n}\r\n\r\n$container->bind(\"memcache\",function() {\r\n    return new Memcache;\r\n});\r\n\r\n$container->bind(\"redis\",function() {\r\n    return new Redis;\r\n});\r\n\r\n$container->tag([\'memcache\',\'redis\'],\'cache\');\r\n\r\n$cachelist = $container->tagged(\'cache\');\r\n\r\nforeach ($cachelist as $cache) {\r\n    print_r($cache);\r\n}\r\n```\r\n- 扩展服务\r\n\r\nextend 方法可以修改已注入到容器中的服务。比如，当一个服务被注入后，你可以添加额外的代码来修饰或者配置它。 extend 方法接受一个闭包，该闭包唯一的参数就是这个服务， 并返回修改过的服务\r\n\r\n```php\r\nclass Cache {\r\n\r\n}\r\n\r\nclass Memcache extends Cache {\r\n\r\n}\r\n\r\nclass Redis extends Cache {\r\n\r\n}\r\n\r\n$container->bind(\"cache\",function() {\r\n    return new Memcache;\r\n});\r\n\r\n$container->extend(\"cache\",function($serivce) {\r\n    //$service是Memcache对象\r\n    return new Redis;\r\n});\r\n\r\nprint_r($container->make(\"cache\"));\r\n```\r\n### 解析服务\r\n\r\n使用 make 方法从容器中解析出类实例。 make 方法接收你想要解析的类或接口的名字\r\n\r\n```php\r\nclass Cache {\r\n\r\n}\r\n\r\nclass Memcache extends Cache {\r\n\r\n}\r\n\r\n$container->bind(Memcache::class,Memcache::class);\r\n\r\nprint_r($container->make(Memcache::class));\r\n```\r\n如果类依赖不能通过容器解析，你可以通过将它们作为关联数组作为 makeWith\r\n、make 方法的参数注入：\r\n\r\n```php\r\nclass Test {\r\n    \r\n}\r\n\r\nclass Cache {\r\n\r\n    private $test;\r\n    private $id;\r\n\r\n    public function __construct(Test $test,$id) {\r\n        $this->test = $test;\r\n        $this->id = $id;\r\n    }\r\n\r\n    public function get() {\r\n        return $this->id;\r\n    }\r\n\r\n}\r\n\r\n$container->bind(Cache::class,Cache::class);\r\n\r\nprint_r($container->makeWith(Cache::class,[\'id\'=>33])->get());\r\nprint_r($container->make(Cache::class,[\'id\'=>33])->get());\r\n\r\n```\r\n### 容器事件\r\n\r\n服务容器每次解析对象会触发一个事件，你可以使用 resolving 方法监听这个事件 :\r\n\r\n```php\r\nrequire_once \'./vendor/autoload.php\';\r\n\r\nuse JsonContainer\\Container;\r\n\r\n$container = new Container;\r\n\r\n\r\nclass Test {\r\n    \r\n}\r\n\r\nclass Cache {\r\n\r\n    private $test;\r\n\r\n    public function __construct(Test $test) {\r\n        $this->test = $test;\r\n    }\r\n\r\n}\r\n\r\n$container->bind(\"test\",Cache::class);\r\n//解析所有服务都会触发这个事件\r\n$container->resolving(function ($object, $container) {\r\n    print_r($object);\r\n    print_r($container);\r\n});\r\n//当解析cache时会触发这个事件\r\n$container->resolving(\"cache\", function ($object, $container) {\r\n   print_r($object);\r\n});\r\n\r\n$container->make(\"test\");\r\n\r\n```\r\n### PSR-11\r\n\r\nLaravel服务容器实现了PSR-11接口，所以可以使用PSR-11接口提供的方法来获取服务\r\n\r\n```php\r\nclass Test {\r\n    \r\n}\r\n\r\nclass Cache {\r\n\r\n    private $test;\r\n\r\n    public function __construct(Test $test) {\r\n        $this->test = $test;\r\n    }\r\n\r\n}\r\n\r\n$container->bind(\"cache\",Cache::class);\r\n\r\nprint_r($container->get(\"cache\"));\r\nprint_r($container->has(\'cache\'));\r\n```\r\n### ArrayAccess\r\n\r\nLaravel服务容器实现了ArrayAccess接口，因此可以像数组一样为容器注入服务，获取服务等操作\r\n\r\n```php\r\n\r\nclass Cache {\r\n\r\n    public function __construct() {\r\n    }\r\n\r\n}\r\n\r\n$container->bind(\"cache\",Cache::class);\r\n\r\nprint_r($container[\'cache\']);\r\nunset($container[\'cache\']);\r\n```\r\n### 魔术方法\r\n\r\nLaravel服务容器还实现了__get,__set魔术方法，因此我们可以用属性的方式进行服务注入和访问\r\n\r\n```php\r\nclass Test {\r\n    private $id;\r\n    public function __construct($id) {\r\n        $this->id = $id;\r\n    }\r\n}\r\n\r\nclass Cache {\r\n    public function __construct(Test $test) {\r\n    }\r\n}\r\n\r\n$container->bind(\"cache\",Cache::class);\r\n$container->Test = function () {\r\n    return new Test(333);\r\n};\r\nvar_dump($container->cache);\r\n```\r\n### Laravel服务容器的其它方法\r\n\r\n- 获取容器单例\r\n\r\n```php\r\n$container = Container::getInstance();\r\n```\r\n- 清除容器中所有服务\r\n```php\r\n$container->flush();\r\n```\r\n- 检查服务是否存在\r\n```php\r\n$container->has(\"cache\");\r\nisset($container[\'cache\'])\r\n```\r\n- 服务是否单例\r\n```php\r\n$container->isShared(\"cache\")\r\n```',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,690,1),(25,'springboot之mybatis plus代码自动生成工具','25',1593243120,1593243365,'<!--markdown-->AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成包括 Entity、Mapper、Mapper XML、Service、Controller 数个模块的代码，可以提升开发效率\r\n\r\n### 安装依赖\r\n```shell\r\n<dependency>\r\n	<groupId>com.baomidou</groupId>\r\n	<artifactId>mybatis-plus-boot-starter</artifactId>\r\n	<version>3.3.2</version>\r\n</dependency>\r\n<dependency>\r\n	<groupId>com.baomidou</groupId>\r\n	<artifactId>mybatis-plus-generator</artifactId>\r\n	<version>3.3.2</version>\r\n</dependency>\r\n<dependency>\r\n	<groupId>org.freemarker</groupId>\r\n	<artifactId>freemarker</artifactId>\r\n	<version>2.3.30</version>\r\n</dependency>\r\n<!-- mysql驱动 -->\r\n<dependency>\r\n	<groupId>mysql</groupId>\r\n	<artifactId>mysql-connector-java</artifactId>\r\n	<version>5.1.47</version>\r\n</dependency>\r\n<dependency>\r\n	<groupId>org.projectlombok</groupId>\r\n	<artifactId>lombok</artifactId>\r\n	<version>1.18.12</version>\r\n	<scope>provided</scope>\r\n</dependency>\r\n```\r\n### 配置mybatis-plus.properties文件\r\n在application.properties同目录重建mybatis-plus.properties文件，文件内容如下\r\n\r\n```shell\r\n#此处为本项目src所在路径(代码生成器输出路径）\r\nOutputDir=E:/demo/src/main/java\r\n\r\n#mapper.xml的生成位置\r\nOutputDirXml=E:/demo/src/main/resources\r\n\r\n#数据库表名(此处切不可为空，如果为空，则默认读取数据库的所有表名)\r\ntableName=tbl_options,tbl_metas,tbl_contents,tbl_relationshops\r\n#表前缀\r\ntablePrefix=tbl_\r\n#存放所生成代码文件的上一级包名\r\n#className=自填\r\n\r\n#设置作者\r\nauthor=Json\r\n\r\n#正常情况下，下面的代码无需修改\r\n#自定义包路径\r\nparent=com.json.demo\r\n\r\n#数据库地址\r\nurl=jdbc:mysql://localhost:3306/typecho?serverTimezone=CTT&characterEncoding=UTF-8&useSSL=false\r\n\r\n#mysql:username & password\r\nuserName=root\r\npassword=root\r\n```\r\n### java代码\r\n注意package改成自己的package\r\n\r\n```java\r\npackage com.json.demo;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.ResourceBundle;\r\nimport com.baomidou.mybatisplus.annotation.DbType;\r\nimport com.baomidou.mybatisplus.core.toolkit.StringPool;\r\nimport com.baomidou.mybatisplus.generator.AutoGenerator;\r\nimport com.baomidou.mybatisplus.generator.InjectionConfig;\r\nimport com.baomidou.mybatisplus.generator.config.DataSourceConfig;\r\nimport com.baomidou.mybatisplus.generator.config.FileOutConfig;\r\nimport com.baomidou.mybatisplus.generator.config.GlobalConfig;\r\nimport com.baomidou.mybatisplus.generator.config.PackageConfig;\r\nimport com.baomidou.mybatisplus.generator.config.StrategyConfig;\r\nimport com.baomidou.mybatisplus.generator.config.TemplateConfig;\r\nimport com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;\r\nimport com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;\r\n\r\npublic class CodeGenerator {\r\n    public static void main(String[] args) throws InterruptedException {\r\n        // 获取Mybatis-Plus.properties文件的配置信息\r\n        final ResourceBundle rb = ResourceBundle.getBundle(\"mybatis-plus\");\r\n\r\n        // 代码生成器\r\n        AutoGenerator mpg = new AutoGenerator();\r\n\r\n        // 全局配置\r\n        GlobalConfig gc = new GlobalConfig();\r\n\r\n        gc.setOutputDir(rb.getString(\"OutputDir\"));\r\n        gc.setOpen(false);\r\n        gc.setBaseResultMap(true);\r\n        gc.setBaseColumnList(true);\r\n        gc.setAuthor(rb.getString(\"author\"));\r\n        gc.setMapperName(\"%sDao\");\r\n        gc.setXmlName(\"%sMapper\");\r\n        gc.setServiceName(\"%sService\");\r\n        gc.setServiceImplName(\"%sServiceImpl\");\r\n        gc.setControllerName(\"%sController\");\r\n        mpg.setGlobalConfig(gc);\r\n\r\n        // dataSource配置\r\n        DataSourceConfig dsc = new DataSourceConfig();\r\n        dsc.setDbType(DbType.MYSQL);\r\n        dsc.setUrl(rb.getString(\"url\"));\r\n        dsc.setDriverName(\"com.mysql.jdbc.Driver\");\r\n        dsc.setUsername(rb.getString(\"userName\"));\r\n        dsc.setPassword(rb.getString(\"password\"));\r\n        mpg.setDataSource(dsc);\r\n\r\n        // package配置\r\n        PackageConfig pc = new PackageConfig();\r\n        pc.setParent(rb.getString(\"parent\"));\r\n\r\n        pc.setController(\"controller\");\r\n        pc.setService(\"service\");\r\n        pc.setServiceImpl(\"service.impl\");\r\n        pc.setEntity(\"entity\");\r\n        pc.setMapper(\"dao\");\r\n        mpg.setPackageInfo(pc);\r\n\r\n        // 自定义配置\r\n        InjectionConfig cfg = new InjectionConfig() {\r\n            @Override\r\n            public void initMap() {\r\n                /* ... */\r\n            }\r\n        };\r\n\r\n        // 如果模板引擎是 freemarker\r\n        String templatePath = \"/templates/mapper.xml.ftl\";\r\n\r\n        // 自定义输出配置\r\n        List<FileOutConfig> focList = new ArrayList<>();\r\n\r\n        // 自定义配置会被优先输出\r\n        focList.add(new FileOutConfig(templatePath) {\r\n            @Override\r\n            public String outputFile(com.baomidou.mybatisplus.generator.config.po.TableInfo tableInfo) {\r\n                // 自定义输入文件名称\r\n                return rb.getString(\"OutputDirXml\") + \"/mapper/\" + tableInfo.getEntityName() + StringPool.DOT_XML;\r\n            }\r\n        });\r\n\r\n        cfg.setFileOutConfigList(focList);\r\n        mpg.setCfg(cfg);\r\n\r\n        TemplateConfig templateConfig = new TemplateConfig();\r\n        templateConfig.setController(\"\");//不生成Controller\r\n        templateConfig.setXml(null);\r\n        mpg.setTemplate(templateConfig);\r\n\r\n        // 策略配置\r\n        StrategyConfig strategy = new StrategyConfig();\r\n\r\n        strategy.setNaming(NamingStrategy.underline_to_camel);\r\n        strategy.setColumnNaming(NamingStrategy.underline_to_camel);\r\n        strategy.setEntityLombokModel(true);\r\n        strategy.setInclude(rb.getString(\"tableName\").split(\",\"));\r\n        strategy.setTablePrefix(rb.getString(\"tablePrefix\"));\r\n        mpg.setStrategy(strategy);\r\n        mpg.setTemplateEngine(new FreemarkerTemplateEngine());\r\n        mpg.execute();\r\n\r\n        System.out.println(\"done successful\");\r\n    }\r\n\r\n}\r\n```',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,890,0),(26,'PHP命名空间那些事儿','26',1593493863,1593493863,'<!--markdown-->##  概述\r\n什么是命名空间？从广义上来说，命名空间是一种封装事物的方法。在很多地方都可以见到这种抽象概念。例如，在操作系统中目录用来将相关文件分组，对于目录中的文件来说，它就扮演了命名空间的角色。具体举个例子，文件 foo.txt 可以同时在目录/home/greg 和 /home/other 中存在，但在同一个目录中不能存在两个 foo.txt 文件。另外，在目录 /home/greg 外访问 foo.txt 文件时，我们必须将目录名以及目录分隔符放在文件名之前得到 /home/greg/foo.txt。这个原理应用到程序设计领域就是命名空间的概念。(引用自php.net)\r\n\r\n命名空间主要用来解决两类问题：\r\n* 用户编写的代码与PHP内部的或第三方的类、函数、常量、接口名字冲突\r\n* 为很长的标识符名称创建一个别名的名称，提高源代码的可读性\r\n\r\nPHP命名空间提供了一种将相关的类、函数、常量和接口组合到一起的途径，不同命名空间的类、函数、常量、接口相互隔离不会冲突，注意：PHP命名空间只能隔离类、函数、常量和接口，不包括全局变量。\r\n\r\n接下来的两节将介绍下PHP命名空间的内部实现，主要从命名空间的定义及使用两个方面分析。\r\n\r\n## 命名空间的定义\r\n### 定义语法\r\n命名空间通过关键字namespace 来声明，如果一个文件中包含命名空间，它必须在其它所有代码之前声明命名空间，除了declare关键字以外，也就是说除declare之外任何代码都不能在namespace之前声明。另外，命名空间并没有文件限制，可以在多个文件中声明同一个命名空间，也可以在同一文件中声明多个命名空间。\r\n```php\r\nnamespace com\\aa;\r\n\r\nconst MY_CONST = 1234;\r\nfunction my_func(){ /* ... */ }\r\nclass my_class { /* ... */ }\r\n```\r\n另外也可以通过{}将类、函数、常量封装在一个命名空间下：\r\n```php\r\nnamespace com\\aa{\r\n    const MY_CONST = 1234;\r\n    function my_func(){ /* ... */ }\r\n    class my_class { /* ... */ }\r\n}\r\n```\r\n但是同一个文件中这两种定义方式不能混用，下面这样的定义将是非法的：\r\n```php\r\nnamespace com\\aa{\r\n    /* ... */\r\n}\r\n\r\nnamespace com\\bb;\r\n/* ... */\r\n```\r\n如果没有定义任何命名空间，所有的类、函数和常量的定义都是在全局空间，与 PHP 引入命名空间概念前一样。\r\n\r\n### 内部说明\r\n命名空间的实现实际比较简单，当声明了一个命名空间后，接下来编译类、函数和常量时会把类名、函数名和常量名统一加上命名空间的名称作为前缀存储，也就是说声明在命名空间中的类、函数和常量的实际名称是被修改过的，这样来看他们与普通的定义方式是没有区别的，只是这个前缀是内核帮我们自动添加的，例如：\r\n```php\r\n//ns_define.php\r\nnamespace com\\aa;\r\n\r\nconst MY_CONST = 1234;\r\nfunction my_func(){ /* ... */ }\r\nclass my_class { /* ... */ }\r\n```\r\n最终MY_CONST、my_func、my_class在EG(zend_constants)、EG(function_table)、EG(class_table)中的实际存储名称被修改为：com\\aa\\MY_CONST、com\\aa\\my_func、com\\aa\\my_class。\r\n\r\n## 命名空间的使用\r\n### 基本用法\r\n我们知道了定义在命名空间中的类、函数和常量只是加上了namespace名称作为前缀，既然是这样那么在使用时加上同样的前缀是否就可以了呢？答案是肯定的，比如上面那个例子：在com\\aa命名空间下定义了一个常量MY_CONST，那么就可以这么使用：\r\n```php\r\ninclude \'ns_define.php\';\r\n\r\necho \\com\\aa\\MY_CONST;\r\n```\r\n这种按照实际类名、函数名、常量名使用的方式很容易理解，与普通的类型没有差别，这种以\"\\\"开头使用的名称称之为：**完全限定名称**，类似于绝对目录的概念，使用这种名称PHP会直接根据\"\\\"之后的名称去对应的符号表中查找(namespace定义时前面是没有加\"\\\"的，所以查找时也会去掉这个字符)。\r\n\r\n除了这种形式的名称之外，还有两种形式的名称：\r\n* __非限定名称:__ 即没有加任何namespace前缀的普通名称，比如my_func()，使用这种名称时如果当前有命名空间则会被解析为：currentnamespace\\my_func，如果当前没有命名空间则按照原始名称my_func解析\r\n* __部分限定名称:__ 即包含namespace前缀，但不是以\"\\\"开始的，比如：aa\\my_func()，类似相对路径的概念，这种名称解析规则比较复杂，如果当前空间没有使用use导入任何namespace那么与非限定名称的解析规则相同，即如果当前有命名空间则会把解析为：currentnamespace\\aa\\my_func，否则解析为aa\\my_func，使用use的情况后面再作说明\r\n\r\n### use导入\r\n使用一个命名空间中的类、函数、常量虽然可以通过完全限定名称的形式访问，但是这种方式需要在每一处使用的地方都加上完整的namespace名称，如果将来namespace名称变更了就需要所有使用的地方都改一遍，这将是很痛苦的一件事，为此，PHP提供了一种命名空间导入/别名的机制，可以通过use关键字将一个命名空间导入或者定义一个别名，然后在使用时就可以通过导入的namespace名称最后一个域或者别名访问，不需要使用完整的名称，比如：\r\n```php\r\n//ns_define.php\r\nnamespace aa\\bb\\cc\\dd;\r\n\r\nconst MY_CONST = 1234;\r\n```\r\n可以采用如下几种方式使用：\r\n```php\r\n//方式1:\r\ninclude \'ns_define.php\';\r\n\r\nuse aa\\bb\\cc\\dd;\r\n\r\necho dd\\MY_CONST;\r\n```\r\n```php\r\n//方式2:\r\ninclude \'ns_define.php\';\r\n\r\nuse aa\\bb\\cc;\r\n\r\necho cc\\dd\\MY_CONST;\r\n```\r\n```php\r\n//方式3:\r\ninclude \'ns_define.php\';\r\n\r\nuse aa\\bb\\cc\\dd as DD;\r\n\r\necho DD\\MY_CONST;\r\n```\r\n```php\r\n//方式4:\r\ninclude \'ns_define.php\';\r\n\r\nuse aa\\bb\\cc as CC;\r\n\r\necho CC\\dd\\MY_CONST;\r\n```\r\n这种机制的实现原理也比较简单：编译期间如果发现use语句 ，那么就将把这个use后的命名空间名称插入一个哈希表：FC(imports)，而哈希表的key就是定义的别名，如果没有定义别名则key使用按\"\\\"分割的最后一节，比如方式2的情况将以cc作为key，即：FC(imports)[\"cc\"] = \"aa\\bb\\cc\\dd\"；接下来在使用类、函数和常量时会把名称按\"\\\"分割，然后以第一节为key查找FC(imports)，如果找到了则将FC(imports)中保存的名称与使用时的名称拼接在一起，组成完整的名称。实际上这种机制是把完整的名称切割缩短然后缓存下来，使用时再拼接成完整的名称，也就是内核帮我们组装了名称，对内核而言，最终使用的都是包括完整namespace的名称。\r\n\r\n\r\nuse除了上面介绍的用法外还可以导入一个类，导入后再使用类就不需要加namespace了，例如：\r\n```php\r\n//ns_define.php\r\nnamespace aa\\bb\\cc\\dd;\r\n\r\nclass my_class { /* ... */ }\r\n```\r\n```php\r\ninclude \'ns_define.php\';\r\n//导入一个类\r\nuse aa\\bb\\cc\\dd\\my_class;\r\n//直接使用\r\n$obj = new my_class();\r\nvar_dump($obj);\r\n```\r\nuse的这两种用法实现原理是一样的，都是在编译时通过查找FC(imports)实现的名称补全。从PHP 5.6起，use又提供了两种针对函数、常量的导入，可以通过`use function xxx`及`use const xxx`\r\n\r\n简单总结下use的几种不同用法：\r\n* __a.导入命名空间:__ 导入的名称保存在FC(imports)中，编译使用的语句时搜索此符号表进行补全\r\n* __b.导入类:__ 导入的名称保存在FC(imports)中，与a不同的是不会根据\"\\\"切割后的最后一节检索，而是直接使用类名查找\r\n* __c.导入函数:__ 通过`use function`导入到FC(imports_function)，补全时先查找FC(imports_function)，如果没有找到则继续按照a的情况处理\r\n* __d.导入常量:__ 通过`use const`导入到FC(imports_const)，补全时先查找FC(imports_const)，如果没有找到则继续按照a的情况处理\r\n\r\n```php\r\nuse aa\\bb;                  //导入namespace\r\nuse aa\\bb\\MY_CLASS;         //导入类\r\nuse function aa\\bb\\my_func; //导入函数\r\nuse const aa\\bb\\MY_CONST;   //导入常量\r\n```\r\n\r\n### 动态用法\r\n前面介绍的这些命名空间的使用都是名称为CONST类型的情况，所有的处理都是在编译环节完成的，PHP是动态语言，能否动态使用命名空间呢？举个例子：\r\n```php\r\n$class_name = \"\\aa\\bb\\my_class\";\r\n$obj = new $class_name;\r\n```\r\n如果类似这样的用法只能用完全限定名称，也就是按照实际存储的名称使用，无法进行自动名称补全。',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,693,0),(27,'redis队列brpop、blpop命令','27',1593579480,1593579711,'<!--markdown-->我们经常用Redis的List结构去做一个轻量级的消息队列\r\n\r\n### 常规做法\r\n一般来说大家都是使用lpush和rpop、rpush和lpop这两对命令实现，具体来说就是用lpush或者rpush向队列里面写数据，然后写一个脚本调用rpop或者lpop弹出消息进行业务处理，最后执行定时任务每间隔一段时间调用一下脚本进行消息的pop处理\r\n### 问题\r\n上面的做法对于实时性要求不高的业务是没有问题的，但是如果要求实时进行消息处理，就有问题了，因为定时任务是每隔一段时间进行处理的，在这一段时间内产生的消息是不能得到及时处理，\r\n需要在定时时间到来的时候才会处理，这时候怎么处理呢，其实redis已经帮我们提供了这样的命令\r\n### 新方案\r\n- brpop\r\n  brpop命令移出并获取列表的右侧第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止  \r\n- blpop\r\nblpop命令移出并获取列表的左侧第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止\r\n**注意** brpop,blpop都是阻塞命令，也就是说brpop是rpop的阻塞版本，blpop是lpop的阻塞版本，当list中没有数据时,命令会阻塞等待\r\n综上，我们可以用brpop或者blpop来实现实时消费的目的，demo代码如下\r\n\r\n```php\r\n<?php\r\n$redis = new Redis();\r\n\r\n$redis->connect(\'127.0.0.1\',6379);\r\n\r\nwhile($data = $redis->brpop(\'test\',3600)) {\r\n    var_dump($data);\r\n}\r\n```\r\n上面的例子是，获取key名是test的list的数据，没有数据的话会阻塞3600秒，可是在实际应用中发现，大约1分钟左右脚本就报错并终止了\r\n\r\n```shell\r\nFatal error: Uncaught exception \'RedisException\' with message \'read error on connection\' in /opt/lnmp/scm/a.php:6\r\nStack trace:\r\n#0 /opt/lnmp/scm/a.php(6): Redis->brPop(\'test\', 3600)\r\n#1 {main}\r\n  thrown in /opt/lnmp/scm/a.php on line 6\r\n\r\n```\r\n查询资料发现：**php的redis扩展是基于php的socket方式实现的，如果php本身配置了socket read超时时间，那么超时会报错退出**\r\n查看php.ini,发现是php.ini文件中的socket默认超时实际配置项导致：\r\n\r\n```\r\ndefault_socket_timeout = 60\r\n```\r\n\r\n找到了问题，就好解决了，我们可以通过两种方式修改这个参数\r\n- 修改php.ini文件，一般不建议\r\n- 通过ini_set函数修改，推荐这种方式，只对当前脚本有效，不对其他脚本产生影响\r\n因此上面的例子可以写成下面的方式，真正实现阻塞3600秒:\r\n\r\n```php\r\nini_set(\'default_socket_timeout\', -1); //不超时\r\n\r\n$redis = new Redis();\r\n\r\n$redis->connect(\'127.0.0.1\',6379);\r\n\r\nwhile($data = $redis->brpop(\'test\',3600)) {\r\n    var_dump($data);\r\n}\r\n```\r\n如果需要无限阻塞，只需要将\r\n\r\n```php\r\n$data = $redis->brpop(\'test\',3600)\r\n```\r\n改成\r\n\r\n```php\r\n$data = $redis->brpop(\'test\',0)\r\n```',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,1221,0),(28,'php异常以及错误捕获','28',1593776100,1593776356,'<!--markdown-->写过几年php代码的同学应该见识了php的异常以及错误，有些exception我们可以通过代码捕获，有时候浏览器会报500错误，这时候我们直接的做法是看php的error log文件，一般都是出现了Fatal error错误，但是我们使用过框架的同学应该都知道了，Fatal error错误框架也都捕获并做了漂亮的突出美好，便于我们调试，感觉好高级的样子，怎么捕获的Fatal error错误呢，带着这种疑惑我们一起来学习下\r\n\r\n### php中的error级别\r\n\r\n```shell\r\nFatal Error:致命错误（脚本终止运行）\r\n    E_ERROR         // 致命的运行错误，错误无法恢复，暂停执行脚本\r\n    E_CORE_ERROR    // PHP启动时初始化过程中的致命错误\r\n    E_COMPILE_ERROR // 编译时致命性错，就像由Zend脚本引擎生成了一个E_ERROR\r\n    E_USER_ERROR    // 自定义错误消息。像用PHP函数trigger_error（错误类型设置为：E_USER_ERROR）\r\n\r\nParse Error：编译时解析错误，语法错误（脚本终止运行）\r\n    E_PARSE  //编译时的语法解析错误\r\n\r\nWarning Error：警告错误（仅给出提示信息，脚本不终止运行）\r\n    E_WARNING         // 运行时警告 (非致命错误)。\r\n    E_CORE_WARNING    // PHP初始化启动过程中发生的警告 (非致命错误) 。\r\n    E_COMPILE_WARNING // 编译警告\r\n    E_USER_WARNING    // 用户产生的警告信息\r\n\r\nNotice Error：通知错误（仅给出通知信息，脚本不终止运行）\r\n    E_NOTICE      // 运行时通知。表示脚本遇到可能会表现为错误的情况.\r\n    E_USER_NOTICE // 用户产生的通知信息。\r\n```\r\n\r\n我们可以看到有E_ERROR | E_CORE_ERROR |  E_COMPILE_ERROR | E_USER_ERROR | E_PARSE这5中错误会导致程序终止并退出\r\n\r\n### PHP异常处理的特技\r\n其实也没什么，就是用了3个php提供的函数\r\n- set_error_handler    这个函数用于设置一个用户自定义的错误处理函数\r\n\r\n当程序出现错误的时候自动调用此方法，不过需要注意一下两点：第一，如果存在该方法，相应的error_reporting()就不能在使用了。所有的错误都会交给自定义的函数处理。第二，此方法不能处理以下级别的错误：E_ERROR、 E_PARSE、 E_CORE_ERROR、 E_CORE_WARNING、 E_COMPILE_ERROR、 E_COMPILE_WARNING，set_error_handler() 函数所在文件中产生的E_STRICT，该函数只能捕获系统产生的一些Warning、Notice级别的错误\r\n\r\n```php\r\n<?php\r\n\r\nset_error_handler(\"errorHandler\");\r\n\r\nfunction errorHandler($type, $message, $file, $line) \r\n{\r\n    var_dump(\'<b>set_error_handler: \' . $type . \':\' . $message . \' in \' . $file . \' on \' . $line . \' line .</b><br />\');\r\n}\r\n\r\necho 1/0;\r\n```\r\n**注意:**\r\n这个函数可以支持注册函数和实例方法两种方式\r\n\r\n```php\r\n<?php\r\n // 直接传函数名 NonClassFunction\r\n set_error_handler(\'function_name\');\r\n\r\n // 传 class_name && function_name\r\n set_error_handler(array(\'class_name\', \'method_name\'));\r\n?>\r\n```\r\n- register_shutdown_function()  这个函数用于注册一些自定义函数，这些函数会在PHP脚本执行结束前调用，比如脚本错误、die()、exit、异常、正常结束后都会调用被register_shutdown_function注册的自定义函数\r\n\r\n这个函数很厉害，即使代码里有exit、die等暴力操作,只要我们在die之前通过register_shutdown_function注册了自定义函数，那自定义函数就可以在程序结束之前被调用。基于这个特点，我们可以借助于error_get_last()函数(这个函数可以拿到本次执行产生的所有错误)，捕获一些像Fatal Error、Parse Error等set_error_handler捕获不到的错误。\r\n\r\nerror_get_last()返回的信息：\r\n\r\n```shell\r\n　　[type]           - 错误类型\r\n　　[message]        - 错误消息\r\n　　[file]           - 发生错误所在的文件\r\n　　[line]           - 发生错误所在的行\r\n```\r\n\r\ndemo示例:\r\n```php\r\n<?php\r\n\r\nregister_shutdown_function(\'shutdownHandler\');\r\n\r\nfunction shutdownHandler()\r\n{\r\n    if ($error = error_get_last()) {\r\n        var_dump(\'<b>register_shutdown_function: Type:\' . $error[\'type\'] . \' Msg: \' . $error[\'message\'] . \' in \' . $error[\'file\'] . \' on line \' . $error[\'line\'] . \'</b>\');\r\n    }\r\n}\r\n\r\necho 4++;\r\n?>\r\n```\r\n\r\n如果你没敲什么的代码，认为这个demo没问题，就被带进坑里了，这个例子目的很明显是要抛出php语法错误，真正运行下代码会发现，并不能捕获错误,依然由php抛出错误\r\n\r\n```shell\r\nPHP Parse error:  syntax error, unexpected \'++\' (T_INC), expecting \',\' or \';\' in E:\\project\\demo\\index.php on line 12\r\n```\r\n\r\n很奇怪，我们用laravel或者其它框架的时候，这种错误是可以捕获的，什么原因呢? 其实原因很简单，只在parse-time出错时是不会调用本函数的，只有在run-time出错的时候，才会调用register_shutdown_function函数。\r\n\r\n框架中一般会有统一的入口index.php，然后每个类库文件都会通过include ** 的方式加载到index.php中，相当与所有的程序都会在index.php中聚集，同样，你写的具有语法错误的文件也会被引入到入口文件中，这样的话，调用框架，执行index.php，index.php本身并没有语法错误，也就不会产生parse-time错误，而是 include 文件出错了，是run-time的时候出错了，所以框架执行完之后就会触发register_shutdown_function()\r\n\r\n现在可以试一下这个写法，这样就会触发register_shutdown_function()函数了：\r\n```php\r\n//a.php\r\n<?php\r\necho 3++;\r\n?>\r\n\r\n//index.php\r\n<?php\r\n\r\nerror_reporting(0);\r\nregister_shutdown_function(\'shutdownHandler\');\r\n\r\nfunction shutdownHandler()\r\n{\r\n    if ($error = error_get_last()) {\r\n        var_dump(\'<b>register_shutdown_function: Type:\' . $error[\'type\'] . \' Msg: \' . $error[\'message\'] . \' in \' . $error[\'file\'] . \' on line \' . $error[\'line\'] . \'</b>\');\r\n    \r\n    }\r\n}\r\n\r\nrequire (\'a.php\');\r\n?>\r\n```\r\n\r\n- set_exception_handler() 设置默认的异常处理程序，用在没有用try/catch块来捕获的异常，也就是说不管你抛出的异常有没有人捕获，如果没有人捕获就会进入到该方法中，并且在回调函数调用后异常会中止。\r\n\r\n```php\r\n<?php\r\n\r\nerror_reporting(0);\r\nset_exception_handler(\'exceptionHandler\');\r\n\r\nfunction exceptionHandler($exception)\r\n{\r\n    var_dump(\"<b>set_exception_handler: Exception: \" . $exception->getMessage()  . \'</b>\');\r\n}\r\n\r\nthrow new Exception(\"手动报错\");\r\n\r\n?>\r\n```\r\n### 综合技巧\r\n根据上面的说明我们，可以知道set_exception_handler可以捕获异常；set_error_handler可以捕获一些错误，但不是所有错误；可以利用register_shutdown_function的最后被调用的函数这个特点，捕获set_error_handler捕获不到的错误；\r\n\r\n因此我们可以综合使用，自定义异常以及输出了\r\n```php\r\n<?php\r\n\r\nerror_reporting(0);\r\n\r\nclass MyException {\r\n\r\n    public function init() \r\n    {\r\n        set_exception_handler([$this, \'exceptionHandler\']);\r\n\r\n        set_error_handler([$this, \'errorHandler\']);\r\n\r\n        register_shutdown_function([$this, \'shutdownHandler\']);\r\n    }\r\n    \r\n    public function exceptionHandler(Throwable $exception) \r\n    {\r\n        print_r($exception->getMessage());\r\n        print_r($exception->getLine());\r\n        print_r($exception->getTrace());\r\n    }\r\n    \r\n    public function errorHandler(int $severity, string $message, string $file = null, int $line = null)\r\n    {\r\n        if (! (error_reporting() & $severity))\r\n        {\r\n            return;\r\n        }\r\n\r\n        throw new ErrorException($message, 0, $severity, $file, $line);\r\n    }\r\n    \r\n    public function shutdownHandler()\r\n    {\r\n        $error = error_get_last();\r\n\r\n        if (! is_null($error))\r\n        {\r\n            // Fatal Error?\r\n            if (in_array($error[\'type\'], [E_ERROR, E_CORE_ERROR, E_COMPILE_ERROR, E_PARSE]))\r\n            {\r\n                $this->exceptionHandler(new ErrorException($error[\'message\'], $error[\'type\'], 0, $error[\'file\'], $error[\'line\']));\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n(new MyException)->init();\r\n\r\ntest();\r\n?>\r\n```',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,679,0),(32,'exception.jpg','exception-jpg',1593840768,1593840768,'a:5:{s:4:\"name\";s:13:\"exception.jpg\";s:4:\"path\";s:33:\"/usr/uploads/2020/07/69169028.jpg\";s:4:\"size\";i:26394;s:4:\"type\";s:3:\"jpg\";s:4:\"mime\";s:10:\"image/jpeg\";}',1,2,NULL,'attachment','publish',NULL,0,'1','0','1',33,0,0),(33,'Codeigniter4学习之漂亮的异常页面','33',1593840780,1594036409,'<!--markdown-->### 起因\r\n\r\nCodeIgniter一直是我喜欢的一个框架，因为他轻量小巧，可是随着环境的变化，这个框架没有及时的更新，似乎有些没有赶上时代，但因为他小巧轻量的特点，仍然有无数的开发者在使用。\r\n\r\n据说Codeigniter4出来了，引入命名空间，整个框架都脱胎换骨，这让我很兴奋，于是根据官方文档，上去就写了个hello world程序，发现框架提供了漂亮的异常页面，exception抛出来可以理解，fatal error和parse error的语法错误都可以提示出来，哎呀，像发现了新大陆一样兴奋，带着喜欢和好奇感赶紧研究了一番，研究之后就想据为己有，于是就想把这个异常抛出的操作提取出来，一方面是为了研究学习，一方面是想更灵活一些，在任何项目中都可以使用\r\n\r\n### 提取完整代码\r\n\r\nJsonExceptionHandler.php文件代码\r\n\r\n```php\r\n<?php\r\n\r\nnamespace Json\\Exception;\r\n\r\nuse function error_reporting;\r\nuse ErrorException;\r\nuse Throwable;\r\n\r\n/**\r\n * Exceptions manager\r\n */\r\nclass JsonExceptionHandler\r\n{\r\n\r\n	const EXIT_SUCCESS 		= 	0;		// no errors\r\n	const EXIT_ERROR 		= 	1;		// generic error\r\n	const EXIT__AUTO_MIN 	= 	9;		// lowest automatically-assigned error code\r\n	const EXIT__AUTO_MAX 	= 	125;	// highest automatically-assigned error code\r\n\r\n						\r\n	use RenderTrait;\r\n\r\n	public static function register() \r\n	{\r\n		$_this = new self();\r\n		$_this->initialize();\r\n	}\r\n\r\n\r\n	/**\r\n	 * Responsible for registering the error, exception and shutdown\r\n	 * handling of our application.\r\n	 */\r\n	public function initialize()\r\n	{	\r\n		error_reporting(E_ALL);\r\n\r\n		//Set the Exception Handler\r\n		set_exception_handler([$this, \'exceptionHandler\']);\r\n\r\n		// Set the Error Handler\r\n		set_error_handler([$this, \'errorHandler\']);\r\n\r\n		// Set the handler for shutdown to catch Parse errors\r\n		// Do we need this in PHP7?\r\n		register_shutdown_function([$this, \'shutdownHandler\']);\r\n	}\r\n\r\n	//--------------------------------------------------------------------\r\n\r\n	/**\r\n	 * Catches any uncaught errors and exceptions, including most Fatal errors\r\n	 * (Yay PHP7!). Will log the error, display it if display_errors is on,\r\n	 * and fire an event that allows custom actions to be taken at this point.\r\n	 *\r\n	 * @param \\Throwable $exception\r\n	 */\r\n	public function exceptionHandler(Throwable $exception)\r\n	{\r\n		// @codeCoverageIgnoreStart\r\n		$codes      = $this->determineCodes($exception);\r\n		$statusCode = $codes[0];\r\n		$exitCode   = $codes[1];\r\n\r\n		$this->render($exception, $statusCode);\r\n\r\n		exit($exitCode);\r\n	}\r\n\r\n	//--------------------------------------------------------------------\r\n\r\n	/**\r\n	 * Even in PHP7, some errors make it through to the errorHandler, so\r\n	 * convert these to Exceptions and let the exception handler log it and\r\n	 * display it.\r\n	 *\r\n	 * This seems to be primarily when a user triggers it with trigger_error().\r\n	 *\r\n	 * @param integer      $severity\r\n	 * @param string       $message\r\n	 * @param string|null  $file\r\n	 * @param integer|null $line\r\n	 *\r\n	 * @throws \\ErrorException\r\n	 */\r\n	public function errorHandler(int $severity, string $message, string $file = null, int $line = null)\r\n	{\r\n		if (! (error_reporting() & $severity))\r\n		{\r\n			return;\r\n		}\r\n\r\n		// Convert it to an exception and pass it along.\r\n		throw new ErrorException($message, 0, $severity, $file, $line);\r\n	}\r\n\r\n	//--------------------------------------------------------------------\r\n\r\n	/**\r\n	 * Checks to see if any errors have happened during shutdown that\r\n	 * need to be caught and handle them.\r\n	 */\r\n	public function shutdownHandler()\r\n	{\r\n		$error = error_get_last();\r\n\r\n		// If we\'ve got an error that hasn\'t been displayed, then convert\r\n		// it to an Exception and use the Exception handler to display it\r\n		// to the user.\r\n		if (! is_null($error))\r\n		{\r\n			// Fatal Error?\r\n			if (in_array($error[\'type\'], [E_ERROR, E_CORE_ERROR, E_COMPILE_ERROR, E_PARSE]))\r\n			{\r\n				$this->exceptionHandler(new ErrorException($error[\'message\'], $error[\'type\'], 0, $error[\'file\'], $error[\'line\']));\r\n			}\r\n		}\r\n	}\r\n\r\n\r\n	//--------------------------------------------------------------------\r\n\r\n	/**\r\n	 * Gathers the variables that will be made available to the view.\r\n	 *\r\n	 * @param \\Throwable $exception\r\n	 * @param integer    $statusCode\r\n	 *\r\n	 * @return array\r\n	 */\r\n	protected function collectVars(Throwable $exception, int $statusCode): array\r\n	{\r\n		return [\r\n			\'title\'   => get_class($exception),\r\n			\'type\'    => get_class($exception),\r\n			\'code\'    => $statusCode,\r\n			\'message\' => $exception->getMessage() ?? \'(null)\',\r\n			\'file\'    => $exception->getFile(),\r\n			\'line\'    => $exception->getLine(),\r\n			\'trace\'   => $exception->getTrace(),\r\n		];\r\n	}\r\n\r\n	/**\r\n	 * Determines the HTTP status code and the exit status code for this request.\r\n	 *\r\n	 * @param \\Throwable $exception\r\n	 *\r\n	 * @return array\r\n	 */\r\n	protected function determineCodes(Throwable $exception): array\r\n	{\r\n		$statusCode = abs($exception->getCode());\r\n\r\n		if ($statusCode < 100 || $statusCode > 599)\r\n		{\r\n			$exitStatus = $statusCode + self::EXIT__AUTO_MIN; // 9 is EXIT__AUTO_MIN\r\n			if ($exitStatus > self::EXIT__AUTO_MAX) // 125 is EXIT__AUTO_MAX\r\n			{\r\n				$exitStatus = self::EXIT_ERROR; // EXIT_ERROR\r\n			}\r\n			$statusCode = 500;\r\n		}\r\n		else\r\n		{\r\n			$exitStatus = 1; // EXIT_ERROR\r\n		}\r\n\r\n		return [\r\n			$statusCode ?? 500,\r\n			$exitStatus,\r\n		];\r\n	}\r\n\r\n	//--------------------------------------------------------------------\r\n	//--------------------------------------------------------------------\r\n	// Display Methods\r\n	//--------------------------------------------------------------------\r\n\r\n	/**\r\n	 * Clean Path\r\n	 *\r\n	 * This makes nicer looking paths for the error output.\r\n	 *\r\n	 * @param string $file\r\n	 *\r\n	 * @return string\r\n	 */\r\n	public static function cleanPath(string $file): string\r\n	{\r\n		return $file;\r\n	}\r\n\r\n\r\n	//--------------------------------------------------------------------\r\n\r\n	/**\r\n	 * Creates a syntax-highlighted version of a PHP file.\r\n	 *\r\n	 * @param string  $file\r\n	 * @param integer $lineNumber\r\n	 * @param integer $lines\r\n	 *\r\n	 * @return boolean|string\r\n	 */\r\n	public static function highlightFile(string $file, int $lineNumber, int $lines = 15)\r\n	{\r\n		if (empty($file) || ! is_readable($file))\r\n		{\r\n			return false;\r\n		}\r\n\r\n		// Set our highlight colors:\r\n		if (function_exists(\'ini_set\'))\r\n		{\r\n			ini_set(\'highlight.comment\', \'#767a7e; font-style: italic\');\r\n			ini_set(\'highlight.default\', \'#c7c7c7\');\r\n			ini_set(\'highlight.html\', \'#06B\');\r\n			ini_set(\'highlight.keyword\', \'#f1ce61;\');\r\n			ini_set(\'highlight.string\', \'#869d6a\');\r\n		}\r\n\r\n		try\r\n		{\r\n			$source = file_get_contents($file);\r\n		}\r\n		catch (Throwable $e)\r\n		{\r\n			return false;\r\n		}\r\n\r\n		$source = str_replace([\"\\r\\n\", \"\\r\"], \"\\n\", $source);\r\n		$source = explode(\"\\n\", highlight_string($source, true));\r\n		$source = str_replace(\'<br />\', \"\\n\", $source[1]);\r\n\r\n		$source = explode(\"\\n\", str_replace(\"\\r\\n\", \"\\n\", $source));\r\n\r\n		// Get just the part to show\r\n		$start = $lineNumber - (int) round($lines / 2);\r\n		$start = $start < 0 ? 0 : $start;\r\n\r\n		// Get just the lines we need to display, while keeping line numbers...\r\n		$source = array_splice($source, $start, $lines, true);\r\n\r\n		// Used to format the line number in the source\r\n		$format = \'% \' . strlen(sprintf(\'%s\', $start + $lines)) . \'d\';\r\n\r\n		$out = \'\';\r\n		// Because the highlighting may have an uneven number\r\n		// of open and close span tags on one line, we need\r\n		// to ensure we can close them all to get the lines\r\n		// showing correctly.\r\n		$spans = 1;\r\n\r\n		foreach ($source as $n => $row)\r\n		{\r\n			$spans += substr_count($row, \'<span\') - substr_count($row, \'</span\');\r\n			$row    = str_replace([\"\\r\", \"\\n\"], [\'\', \'\'], $row);\r\n\r\n			if (($n + $start + 1) === $lineNumber)\r\n			{\r\n				preg_match_all(\'#<[^>]+>#\', $row, $tags);\r\n				$out .= sprintf(\"<span class=\'line highlight\'><span class=\'number\'>{$format}</span> %s\\n</span>%s\", $n + $start + 1, strip_tags($row), implode(\'\', $tags[0])\r\n				);\r\n			}\r\n			else\r\n			{\r\n				$out .= sprintf(\'<span class=\"line\"><span class=\"number\">\' . $format . \'</span> %s\', $n + $start + 1, $row) . \"\\n\";\r\n			}\r\n		}\r\n\r\n		if ($spans > 0)\r\n		{\r\n			$out .= str_repeat(\'</span>\', $spans);\r\n		}\r\n\r\n		return \'<pre><code>\' . $out . \'</code></pre>\';\r\n	}\r\n\r\n}\r\n\r\n\r\ntrait RenderTrait\r\n{\r\n	/**\r\n	 * Given an exception and status code will display the error to the client.\r\n	 *\r\n	 * @param \\Throwable $exception\r\n	 * @param integer    $statusCode\r\n	 */\r\n	protected function render(Throwable $exception, int $statusCode)\r\n	{\r\n		\r\n		// Prepare the vars\r\n		$vars = $this->collectVars($exception, $statusCode);\r\n		extract($vars);\r\n\r\n		ob_start();\r\n\r\n\r\n		$error_id = uniqid(\'error\', true);\r\n		echo	\'<!doctype html>\';\r\n		echo	\'<html>\';\r\n		echo 	\'<head>\';\r\n		echo 		\'<meta charset=\"UTF-8\">\';\r\n		echo 		\'<meta name=\"robots\" content=\"noindex\">\';\r\n		echo 		\'<title>\'.htmlspecialchars($title, ENT_SUBSTITUTE, \'UTF-8\').\'</title>\';\r\n		echo 		\'<style type=\"text/css\">\';\r\n		$css = \'\r\n			body {\r\n			    height: 100%;\r\n			    background: #fafafa;\r\n			    font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif;\r\n			    color: #777;\r\n			    font-weight: 300;\r\n			    margin: 0;\r\n			    padding: 0;\r\n			}\r\n			h1 {\r\n			    font-weight: lighter;\r\n			    letter-spacing: 0.8;\r\n			    font-size: 3rem;\r\n			    color: #222;\r\n			    margin: 0;\r\n			}\r\n			h1.headline {\r\n			    margin-top: 20%;\r\n			    font-size: 5rem;\r\n			}\r\n			.text-center {\r\n			    text-align: center;\r\n			}\r\n			p.lead {\r\n			    font-size: 1.6rem;\r\n			}\r\n			.container {\r\n			    max-width: 75rem;\r\n			    margin: 0 auto;\r\n			    padding: 1rem;\r\n			}\r\n			.header {\r\n			    background: #85271f;\r\n			    color: #fff;\r\n			}\r\n			.header h1 {\r\n			    color: #fff;\r\n			}\r\n			.header p {\r\n			    font-size: 1.2rem;\r\n			    margin: 0;\r\n			    line-height: 2.5;\r\n			}\r\n			.header a {\r\n			    color: rgba(255,255,255,0.5);\r\n			    margin-left: 2rem;\r\n			    display: none;\r\n			    text-decoration: none;\r\n			}\r\n			.header:hover a {\r\n			    display: inline;\r\n			}\r\n\r\n			.footer .container {\r\n			    border-top: 1px solid #e7e7e7;\r\n			    margin-top: 1rem;\r\n			    text-align: center;\r\n			}\r\n\r\n			.source {\r\n			    background: #333;\r\n			    color: #c7c7c7;\r\n			    padding: 0.5em 1em;\r\n			    border-radius: 5px;\r\n			    font-family: Menlo, Monaco, Consolas, \"Courier New\", monospace;\r\n			    margin: 0;\r\n			}\r\n			.source span.line {\r\n			    line-height: 1.4;\r\n			}\r\n			.source span.line .number {\r\n			    color: #666;\r\n			}\r\n			.source .line .highlight {\r\n			    display: block;\r\n			    background: #555;\r\n			    color: #fff;\r\n			}\r\n			.source span.highlight .number {\r\n			    color: #fff;\r\n			}\r\n\r\n			.tabs {\r\n			    list-style: none;\r\n			    list-style-position: inside;\r\n			    margin: 0;\r\n			    padding: 0;\r\n			    margin-bottom: -1px;\r\n			}\r\n			.tabs li {\r\n			    display: inline;\r\n			}\r\n			.tabs a:link,\r\n			.tabs a:visited {\r\n			    padding: 0rem 1rem;\r\n			    line-height: 2.7;\r\n			    text-decoration: none;\r\n			    color: #a7a7a7;\r\n			    background: #f1f1f1;\r\n			    border: 1px solid #e7e7e7;\r\n			    border-bottom: 0;\r\n			    border-top-left-radius: 5px;\r\n			    border-top-right-radius: 5px;\r\n			    display: inline-block;\r\n			}\r\n			.tabs a:hover {\r\n			    background: #e7e7e7;\r\n			    border-color: #e1e1e1;\r\n			}\r\n			.tabs a.active {\r\n			    background: #fff;\r\n			}\r\n			.tab-content {\r\n			    background: #fff;\r\n			    border: 1px solid #efefef;\r\n			}\r\n			.content {\r\n			    padding: 1rem;\r\n			}\r\n			.hide {\r\n			    display: none;\r\n			}\r\n\r\n			.alert {\r\n			    margin-top: 2rem;\r\n			    display: block;\r\n			    text-align: center;\r\n			    line-height: 3.0;\r\n			    background: #d9edf7;\r\n			    border: 1px solid #bcdff1;\r\n			    border-radius: 5px;\r\n			    color: #31708f;\r\n			}\r\n			ul, ol {\r\n			    line-height: 1.8;\r\n			}\r\n\r\n			table {\r\n			    width: 100%;\r\n			    overflow: hidden;\r\n			}\r\n			th {\r\n			    text-align: left;\r\n			    border-bottom: 1px solid #e7e7e7;\r\n			    padding-bottom: 0.5rem;\r\n			}\r\n			td {\r\n			    padding: 0.2rem 0.5rem 0.2rem 0;\r\n			}\r\n			tr:hover td {\r\n			    background: #f1f1f1;\r\n			}\r\n			td pre {\r\n			    white-space: pre-wrap;\r\n			}\r\n\r\n			.trace a {\r\n			    color: inherit;\r\n			}\r\n			.trace table {\r\n			    width: auto;\r\n			}\r\n			.trace tr td:first-child {\r\n			    min-width: 5em;\r\n			    font-weight: bold;\r\n			}\r\n			.trace td {\r\n			    background: #e7e7e7;\r\n			    padding: 0 1rem;\r\n			}\r\n			.trace td pre {\r\n			    margin: 0;\r\n			}\r\n			.args {\r\n			    display: none;\r\n			}\r\n		\';\r\n		echo 	preg_replace(\'#[\\r\\n\\t ]+#\', \' \', $css);	\r\n		echo 		\'</style>\';\r\n		echo 	\'</head>\';\r\n\r\n		echo 	\'<body>\';\r\n\r\n		echo 		\'<div class=\"header\">\';\r\n		echo 			\'<div class=\"container\">\';\r\n		echo 				\'<h1>\'.htmlspecialchars($title, ENT_SUBSTITUTE, \'UTF-8\'). ($exception->getCode() ? \' #\' . $exception->getCode() : \'\').\'</h1>\';\r\n		echo 				\'<p>\'.$exception->getMessage().\'</p>\';\r\n		echo			\'</div>\';\r\n		echo 		\'</div>\';\r\n\r\n		echo 		\'<div class=\"container\">\';\r\n		echo 			\'<p><b>\'.static::cleanPath($file, $line).\'</b> at line <b>\'. $line.\'</b></p>\';\r\n\r\n		if (is_file($file)) {\r\n			echo 		\'<div class=\"source\">\';\r\n			echo 		static::highlightFile($file, $line, 15);\r\n			echo 		\'</div>\';\r\n		}\r\n		echo 		\'</div>\';\r\n\r\n		echo		\'<div class=\"container\">\';\r\n\r\n		echo 			\'<ul class=\"tabs\" id=\"tabs\">\';\r\n		echo 				\'<li><a href=\"#backtrace\">Backtrace</a></li>\';	\r\n		echo 			\'</ul>\';\r\n		echo 			\'<div class=\"tab-content\">\';\r\n\r\n		echo 				\'<div class=\"content\" id=\"backtrace\">\';\r\n\r\n		echo					\'<ol class=\"trace\">\';\r\n									foreach ($trace as $index => $row) {\r\n		echo						\'<li>\';\r\n		echo							\'<p>\';\r\n											//Trace info\r\n											if (isset($row[\'file\']) && is_file($row[\'file\'])){\r\n												if (isset($row[\'function\']) && in_array($row[\'function\'], [\'include\', \'include_once\', \'require\', \'require_once\']))\r\n												{\r\n		echo 										$row[\'function\'] .\' \' . static::cleanPath($row[\'file\']);\r\n												}\r\n												else\r\n												{\r\n		echo 										static::cleanPath($row[\'file\']).\' : \'.$row[\'line\'];\r\n												}\r\n											}else {\r\n		echo 									\'{PHP internal code}\';\r\n											}\r\n\r\n											//Class/Method\r\n											if (isset($row[\'class\'])) {\r\n		echo									\'&nbsp;&nbsp;&mdash;&nbsp;&nbsp;\'.$row[\'class\'] . $row[\'type\'] . $row[\'function\'];\r\n												if (! empty($row[\'args\'])) {\r\n													$args_id = $error_id . \'args\' . $index;\r\n		echo										\'( <a href=\"#\" onclick=\"return toggle(\\\'\'.$args_id.\'\\\');\">arguments</a> )\';\r\n		echo										\'<div class=\"args\" id=\"\'.$args_id.\'\">\';\r\n		echo											\'<table cellspacing=\"0\">\';\r\n\r\n														$params = null;\r\n														// Reflection by name is not available for closure function\r\n														if (substr( $row[\'function\'], -1 ) !== \'}\')\r\n														{\r\n															$mirror = isset( $row[\'class\'] ) ? new \\ReflectionMethod( $row[\'class\'], $row[\'function\'] ) : new \\ReflectionFunction( $row[\'function\'] );\r\n															$params = $mirror->getParameters();\r\n														}\r\n														foreach ($row[\'args\'] as $key => $value) {\r\n		echo												\'<tr>\';\r\n		echo													\'<td><code>\'. htmlspecialchars(isset($params[$key]) ? \'$\' . $params[$key]->name : \"#$key\", ENT_SUBSTITUTE, \'UTF-8\').\'</code></td>\';\r\n		echo													\'<td><pre>\'. print_r($value, true) .\'</pre></td>\';\r\n		echo												\'</tr>\';\r\n														}\r\n		echo											\'</table>\';\r\n		echo										\'</div>\';\r\n												} else{\r\n		echo										\'()\';\r\n												}\r\n											}\r\n\r\n											if (! isset($row[\'class\']) && isset($row[\'function\'])) {\r\n		echo									\'&nbsp;&nbsp;&mdash;&nbsp;&nbsp;\'.$row[\'function\'].\'()\';\r\n											}\r\n		echo							\'</p>\';\r\n\r\n										if (isset($row[\'file\']) && is_file($row[\'file\']) &&  isset($row[\'class\'])) {\r\n		echo								\'<div class=\"source\">\';\r\n		echo 									static::highlightFile($row[\'file\'], $row[\'line\']);\r\n		echo								\'</div>\';\r\n										}\r\n		echo 						\'</li>\';\r\n									}\r\n		echo					\'</ol>\';\r\n		echo 				\'</div>\';\r\n		echo 			\'</div>\';\r\n		echo 		\'</div>\';\r\n\r\n		echo 		\'<div class=\"footer\">\';\r\n		echo 			\'<div class=\"container\">\';\r\n		echo 				\'<p>\';\r\n		echo					\'Displayed at \'.date(\'H:i:sa\').\' &mdash;\';\r\n		echo					\'PHP:\'.phpversion();\r\n		echo 				\'</p>\';\r\n\r\n		echo 			\'</div>\';\r\n		echo 		\'</div>\';\r\n\r\n		echo 	\'</body>\';\r\n		echo 	\'</html>\';\r\n\r\n		$buffer = ob_get_contents();\r\n		ob_end_clean();\r\n		echo $buffer;\r\n	}\r\n}\r\n```\r\n\r\n### 使用方法\r\n提取出来之后，只需要一个文件，只需要三步，就可以使用了\r\n\r\n1. 引入文件\r\n2. 使用命名空间下的类\r\n3. 注册\r\n\r\n```php\r\n<?php\r\nuse Json\\Exception\\JsonExceptionHandler;\r\n\r\nrequire \'./JsonExceptionHandler.php\';//引入文件\r\n\r\nJsonExceptionHandler::register();//注册异常、错误处理函数\r\n\r\n//调用一个不存在的函数\r\ntest();\r\n```\r\n### 异常效果图\r\n![exception.jpg](/usr/uploads/2020/07/69169028.jpg)\r\n\r\n是不是很漂亮，赶紧在自己的电脑上试试吧,**只需要把上面的源码复制到自己的项目文件里面就可用啦**\r\n\r\n### 其它\r\n如果你项目中使用composer，可以使用composer进行安装和使用\r\n```shell\r\ncomposer require fanqingxuan/exception\r\n```\r\n\r\n```php\r\n<?php\r\n\r\nrequire \'vendor/autoload.php\';//引入文件\r\n\r\nuse Json\\Exception\\JsonExceptionHandler;\r\n\r\nJsonExceptionHandler::register();//注册异常、错误处理函数\r\n\r\n//调用一个不存在的函数\r\nvar_dump(test());\r\n```',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,885,1),(29,'Desert.jpg','Desert-jpg',1593837296,1593837296,'a:5:{s:4:\"name\";s:10:\"Desert.jpg\";s:4:\"path\";s:34:\"/usr/uploads/2020/07/826695618.jpg\";s:4:\"size\";i:845941;s:4:\"type\";s:3:\"jpg\";s:4:\"mime\";s:10:\"image/jpeg\";}',1,2,NULL,'attachment','publish',NULL,0,'1','0','1',34,0,0),(34,'Redis获取分布式锁的完整例子','34',1593860760,1593861017,'<!--markdown-->Redis的分布式锁网上有各种各样的实现方式，就像那句话:错误的方式各有不同，正确的方式只有一个。代码也一样，外层代码封装看着各有不同，其实底层锁的实现方式都是一个思路：\r\n\r\n- 使用redis的set或者setnx命令上锁，set命令的话需要加参数NX、EX\r\n\r\n- 通过redis提供的eval函数调用lua脚本，以实现解锁的原子性\r\n\r\n### 完整源码\r\n\r\n下面是加锁和解锁的全部源码\r\n\r\n```php\r\n<?php\r\n\r\nclass RedisLock {\r\n\r\n	/**\r\n     * The key of the lock.\r\n     *\r\n     * @var string\r\n     */\r\n	private $key;\r\n\r\n	//redis value\r\n	private $value;\r\n\r\n	/**\r\n     * The redis object\r\n     *\r\n     * @var Redis\r\n     */\r\n	private $redis;\r\n\r\n	/**\r\n     * The number of seconds the lock should be maintained.\r\n     *\r\n     * @var int\r\n     */\r\n	private $seconds;\r\n\r\n	public function __construct(Redis $redis, $key, $seconds = 180) {\r\n\r\n		$this->redis 	= $redis;\r\n		$this->key   	= $key;\r\n		$this->value 	= uniqid();\r\n		$this->seconds 	= $seconds;\r\n\r\n	}\r\n\r\n	/**\r\n     * Attempt to acquire the lock.\r\n     *\r\n     * @return bool\r\n     */\r\n	public function acquire() {\r\n		return (bool)$this->redis->set($this->key, $this->value, [\'NX\', \'EX\' => $this->seconds]);\r\n	}\r\n\r\n	/**\r\n     * Release the lock.\r\n     *\r\n     * @return bool\r\n     */\r\n	public function release()\r\n    {\r\n        $script = \'\r\n            if redis.call(\"GET\", KEYS[1]) == ARGV[1] then\r\n                return redis.call(\"DEL\", KEYS[1])\r\n            else\r\n                return 0\r\n            end\r\n        \';\r\n        return (bool)$this->redis->eval($script, [$this->key, $this->value], 1);\r\n    }\r\n}\r\n```\r\n\r\n### 用法\r\n\r\n```php\r\n$redis = new Redis();\r\n$redis->connect(\'127.0.0.1\', 6379);\r\n\r\n$lockObj = new RedisLock($redis,\"test\");\r\n\r\nif($lockObj->acquire()) {\r\n	echo \'do something\';\r\n	$lockObj->release();\r\n}\r\n```\r\n',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,656,0),(35,'提取laravel中的限流类','35',1593866280,1593942601,'<!--markdown-->### 概念\r\n\r\n所谓限流，指的是在指定时间单个用户对某个路由资源的访问次数限制，该功能有两个使用场景，一个是在某些需要验证/认证的页面限制用户失败尝试次数，提高系统的安全性，另一个是避免非正常用户（比如爬虫）对路由的过度频繁访问，从而提高系统的可用性，此外，在流量高峰期还可以借助此功能进行有效的限流。\r\n\r\n### 说明\r\n特别喜欢laravel这个优秀的框架，当今大紫大红必有其原因，过于喜欢以至于总喜欢研究laravel框架引入的一些特性，遇到好的特性总想提取出来，以备自己的项目中使用，之所以想把好的特性提取出来一个最重要的原因是我觉得laravel太重量级了，我表示不喜欢复杂的东西，所以想把好的东西按功能一个个提取出来，将来按需使用需要的特性。今天又手抖提取了laravel中的限流组件，下面是源码全部代码，限流依赖于缓存组件，我提取的代码缓存组件是redis和memcache，所以你要想使用的话，麻烦检查服务器安装了redis或者memcache，php安装了phpredis扩展或者memcache扩展，**注意是memcache扩展而不是memcached扩展**\r\n\r\n### 源码\r\n```php\r\n<?php\r\n\r\nclass Cache {\r\n\r\n	/**\r\n     * The cache store implementation.\r\n     *\r\n     */\r\n	private $store;\r\n\r\n	/**\r\n     * Create a new cache cache instance.\r\n     *\r\n     * @return void\r\n     */\r\n	public function __construct($store) {\r\n		$this->store = $store;\r\n	}\r\n\r\n	/**\r\n     * Determine if an item exists in the cache.\r\n     *\r\n     * @param  string  $key\r\n     * @return bool\r\n     */\r\n    public function has($key)\r\n    {\r\n        return ! is_null($this->get($key));\r\n    }\r\n\r\n	/**\r\n     * Store an item in the cache if the key does not exist.\r\n     *\r\n     * @param  string  $key\r\n     * @param  mixed  $value\r\n     * @param  int|null  $seconds\r\n     * @return bool\r\n     */\r\n    public function add($key, $value, $seconds = null)\r\n    {\r\n        if ($seconds !== null) {\r\n            if ($seconds <= 0) {\r\n                return false;\r\n            }\r\n\r\n            // If the store has an \"add\" method we will call the method on the store so it\r\n            // has a chance to override this logic. Some drivers better support the way\r\n            // this operation should work with a total \"atomic\" implementation of it.\r\n            if (method_exists($this->store, \'add\')) {\r\n                return $this->store->add($key, $value, $seconds);\r\n            }\r\n        }\r\n\r\n        // If the value did not exist in the cache, we will put the value in the cache\r\n        // so it exists for subsequent requests. Then, we will return true so it is\r\n        // easy to know if the value gets added. Otherwise, we will return false.\r\n        if (is_null($this->get($key))) {\r\n            return $this->put($key, $value, $seconds);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n	/**\r\n     * Increment the value of an item in the cache.\r\n     *\r\n     * @param  string  $key\r\n     * @param  mixed  $value\r\n     * @return int|bool\r\n     */\r\n    public function increment($key, $value = 1)\r\n    {\r\n        return $this->store->increment($key, $value);\r\n    }\r\n\r\n	/**\r\n     * Store an item in the cache.\r\n     *\r\n     * @param  string  $key\r\n     * @param  mixed  $value\r\n     * @param  int|null  $seconds\r\n     * @return bool\r\n     */\r\n    public function put($key, $value, $seconds = null)\r\n    {\r\n\r\n        if ($seconds === null) {\r\n            return $this->forever($key, $value);\r\n        }\r\n\r\n        if ($seconds <= 0) {\r\n            return $this->forget($key);\r\n        }\r\n\r\n        $result = $this->store->put($key, $value, $seconds);\r\n\r\n        return $result;\r\n    }\r\n\r\n    /**\r\n     * Store an item in the cache indefinitely.\r\n     *\r\n     * @param  string  $key\r\n     * @param  mixed  $value\r\n     * @return bool\r\n     */\r\n    public function forever($key, $value)\r\n    {\r\n        $result = $this->store->forever($key, $value);\r\n\r\n        return $result;\r\n    }\r\n\r\n	/**\r\n     * Retrieve an item from the cache by key.\r\n     *\r\n     * @param  string  $key\r\n     * @param  mixed  $default\r\n     * @return mixed\r\n     */\r\n    public function get($key, $default = null)\r\n    {\r\n \r\n        $value = $this->store->get($key);\r\n\r\n        if (is_null($value)) {\r\n            $value = $default;\r\n        }\r\n\r\n        return $value;\r\n    }\r\n\r\n	/**\r\n     * Remove an item from the cache.\r\n     *\r\n     * @param  string  $key\r\n     * @return bool\r\n     */\r\n    public function forget($key)\r\n    {\r\n        return $this->store->forget($key);\r\n    }\r\n}\r\n\r\n\r\nclass RedisStore {\r\n\r\n	private $redis;\r\n	private $prefix = \'\';\r\n\r\n	public function __construct(Redis $redis,$prefix = \'\') {\r\n		$this->redis = $redis;\r\n		$this->setPrefix($prefix);\r\n	}\r\n	/**\r\n     * Retrieve an item from the cache by key.\r\n     *\r\n     * @param  string|array  $key\r\n     * @return mixed\r\n     */\r\n    public function get($key)\r\n    {\r\n        $value = $this->redis->get($this->prefix.$key);\r\n\r\n        return ! is_null($value) ? $this->unserialize($value) : null;\r\n    }\r\n\r\n    /**\r\n     * Store an item in the cache for a given number of seconds.\r\n     *\r\n     * @param  string  $key\r\n     * @param  mixed  $value\r\n     * @param  int  $seconds\r\n     * @return bool\r\n     */\r\n    public function put($key, $value, $seconds)\r\n    {\r\n        return (bool) $this->redis->setex(\r\n            $this->prefix.$key, (int) max(1, $seconds), $this->serialize($value)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Store an item in the cache if the key doesn\'t exist.\r\n     *\r\n     * @param  string  $key\r\n     * @param  mixed  $value\r\n     * @param  int  $seconds\r\n     * @return bool\r\n     */\r\n    public function add($key, $value, $seconds)\r\n    {\r\n        $lua = \"return redis.call(\'exists\',KEYS[1])<1 and redis.call(\'setex\',KEYS[1],ARGV[2],ARGV[1])\";\r\n\r\n        return (bool) $this->redis->eval(\r\n            $lua, [$this->prefix.$key,\'expire\', $this->serialize($value),(int) max(1, $seconds)],2\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Increment the value of an item in the cache.\r\n     *\r\n     * @param  string  $key\r\n     * @param  mixed  $value\r\n     * @return int\r\n     */\r\n    public function increment($key, $value = 1)\r\n    {\r\n        return $this->redis->incrby($this->prefix.$key, $value);\r\n    }\r\n\r\n    /**\r\n     * Store an item in the cache indefinitely.\r\n     *\r\n     * @param  string  $key\r\n     * @param  mixed  $value\r\n     * @return bool\r\n     */\r\n    public function forever($key, $value)\r\n    {\r\n        return (bool) $this->redis->set($this->prefix.$key, $this->serialize($value));\r\n    }\r\n\r\n    /**\r\n     * Remove an item from the cache.\r\n     *\r\n     * @param  string  $key\r\n     * @return bool\r\n     */\r\n    public function forget($key)\r\n    {\r\n        return (bool) $this->redis->del($this->prefix.$key);\r\n    }\r\n\r\n     /**\r\n     * Set the cache key prefix.\r\n     *\r\n     * @param  string  $prefix\r\n     * @return void\r\n     */\r\n    public function setPrefix($prefix)\r\n    {\r\n        $this->prefix = ! empty($prefix) ? $prefix.\':\' : \'\';\r\n    }\r\n\r\n    /**\r\n     * Serialize the value.\r\n     *\r\n     * @param  mixed  $value\r\n     * @return mixed\r\n     */\r\n    protected function serialize($value)\r\n    {\r\n        return is_numeric($value) && ! in_array($value, [INF, -INF]) && ! is_nan($value) ? $value : serialize($value);\r\n    }\r\n\r\n    /**\r\n     * Unserialize the value.\r\n     *\r\n     * @param  mixed  $value\r\n     * @return mixed\r\n     */\r\n    protected function unserialize($value)\r\n    {\r\n        return is_numeric($value) ? $value : unserialize($value);\r\n    }\r\n	\r\n}\r\n\r\nclass RateLimiter\r\n{\r\n\r\n    /**\r\n     * The cache store implementation.\r\n     *\r\n     */\r\n    protected $cache;\r\n\r\n    /**\r\n     * Create a new rate limiter instance.\r\n     *\r\n     * @param  $cache\r\n     * @return void\r\n     */\r\n    public function __construct(Cache $cache)\r\n    {\r\n        $this->cache = $cache;\r\n    }\r\n\r\n    /**\r\n     * Determine if the given key has been \"accessed\" too many times.\r\n     *\r\n     * @param  string  $key\r\n     * @param  int  $maxAttempts\r\n     * @return bool\r\n     */\r\n    public function tooManyAttempts($key, $maxAttempts)\r\n    {\r\n        if ($this->attempts($key) >= $maxAttempts) {\r\n            if ($this->cache->has($key.\':timer\')) {\r\n                return true;\r\n            }\r\n\r\n            $this->resetAttempts($key);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Increment the counter for a given key for a given decay time.\r\n     *\r\n     * @param  string  $key\r\n     * @param  int  $decaySeconds\r\n     * @return int\r\n     */\r\n    public function hit($key, $decaySeconds = 60)\r\n    {\r\n        $this->cache->add(\r\n            $key.\':timer\', time()+$decaySeconds, $decaySeconds\r\n        );\r\n\r\n        $added = $this->cache->add($key, 0, $decaySeconds);\r\n\r\n        $hits = (int) $this->cache->increment($key);\r\n\r\n        if (! $added && $hits == 1) {\r\n            $this->cache->put($key, 1, $decaySeconds);\r\n        }\r\n\r\n        return $hits;\r\n    }\r\n\r\n    /**\r\n     * Get the number of attempts for the given key.\r\n     *\r\n     * @param  string  $key\r\n     * @return mixed\r\n     */\r\n    public function attempts($key)\r\n    {\r\n        return $this->cache->get($key, 0);\r\n    }\r\n\r\n    /**\r\n     * Reset the number of attempts for the given key.\r\n     *\r\n     * @param  string  $key\r\n     * @return mixed\r\n     */\r\n    public function resetAttempts($key)\r\n    {\r\n        return $this->cache->forget($key);\r\n    }\r\n\r\n    /**\r\n     * Get the number of retries left for the given key.\r\n     *\r\n     * @param  string  $key\r\n     * @param  int  $maxAttempts\r\n     * @return int\r\n     */\r\n    public function retriesLeft($key, $maxAttempts)\r\n    {\r\n        $attempts = $this->attempts($key);\r\n\r\n        return $maxAttempts - $attempts;\r\n    }\r\n\r\n    /**\r\n     * Clear the hits and lockout timer for the given key.\r\n     *\r\n     * @param  string  $key\r\n     * @return void\r\n     */\r\n    public function clear($key)\r\n    {\r\n        $this->resetAttempts($key);\r\n\r\n        $this->cache->forget($key.\':timer\');\r\n    }\r\n\r\n    /**\r\n     * Get the number of seconds until the \"key\" is accessible again.\r\n     *\r\n     * @param  string  $key\r\n     * @return int\r\n     */\r\n    public function availableIn($key)\r\n    {\r\n        return $this->cache->get($key.\':timer\') - time();\r\n    }\r\n}\r\n\r\n\r\n$redis = new Redis;\r\n$redis->connect(\'127.0.0.1\', 6379);\r\n\r\n$redisCache = new RedisStore($redis,\'lock\');\r\n$cache = new Cache($redisCache);\r\n/**\r\n$memcache = new Memcache;\r\n$memcache->connect(\'127.0.0.1\', 11211);\r\n\r\n$memcacheStore = new MemcacheStore($memcache,\'lock\');\r\n$cache = new Cache($memcacheStore);\r\n**/\r\n$rateLimter = new RateLimiter($cache);\r\n\r\n$key = \'hello\';\r\n$maxAttempts = 10;\r\n$seconds = 60;\r\n\r\nif($rateLimter->tooManyAttempts(\"hello\",$maxAttempts)) {\r\n	var_dump($rateLimter->availableIn($key).\'秒后可用\');\r\n	throw new Exception(\"超次数了\");\r\n}\r\n\r\n$rateLimter->hit($key, $seconds);\r\n\r\nvar_dump(\"剩余次数:\".$rateLimter->retriesLeft($key,$maxAttempts));\r\n\r\n```\r\n\r\n### composer安装\r\n\r\n```shell\r\ncomposer require fanqingxuan/ratelimiter\r\n```\r\n\r\n### composer方式使用\r\n```php\r\n\r\n<?php\r\n\r\nrequire \'./vendor/autoload.php\';\r\n\r\nuse Json\\RateLimiter\\Cache;\r\nuse Json\\RateLimiter\\RedisStore;\r\nuse Json\\RateLimiter\\MemcacheStore;\r\nuse Json\\RateLimiter\\RateLimiter;\r\n\r\n\r\n$redis = new Redis;\r\n$redis->connect(\'127.0.0.1\', 6379);\r\n\r\n$redisCache = new RedisStore($redis,\'lock\');\r\n$cache = new Cache($redisCache);\r\n/**\r\n$memcache = new Memcache;\r\n$memcache->connect(\'127.0.0.1\', 11211);\r\n\r\n$memcacheStore = new MemcacheStore($memcache,\'lock\');\r\n$cache = new Cache($memcacheStore);\r\n**/\r\n$rateLimter = new RateLimiter($cache);\r\n\r\n$key = \'hello\';\r\n$maxAttempts = 10;\r\n$seconds = 60;\r\n\r\nif($rateLimter->tooManyAttempts(\"hello\",$maxAttempts)) {\r\n	var_dump($rateLimter->availableIn($key).\'秒后可用\');\r\n	throw new Exception(\"超次数了\");\r\n}\r\n\r\n$rateLimter->hit($key, $seconds);\r\n\r\nvar_dump(\"剩余次数:\".$rateLimter->retriesLeft($key,$maxAttempts));\r\n\r\n\r\n```\r\n',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,754,1),(36,'巧用parse_ini_file函数解析ini文件','36',1593939060,1593939235,'<!--markdown-->parse_ini_file函数是php内置的一个解析ini文件的函数，解析成功时以关联数组 array 返回结果，失败时返回 FALSE\r\n\r\n###常规用法\r\n\r\n```php\r\n//config.ini\r\none = 1\r\nfive = 5\r\nanimal = BIRD\r\n\r\n;这是注释\r\nlist[] = 1\r\nlist[] = 2\r\nlist[] = 3\r\n\r\ndebug = false\r\nopenLock=on\r\n\r\n```\r\n```php\r\n$arr = parse_ini_file(\'./config.ini\');\r\nprint_r($arr);\r\n//输出Array ( [one] => 1 [five] => 5 [animal] => BIRD [list] => Array ( [0] => 1 [1] => 2 [2] => 3 ) [debug] => 1 [openLock] => 1 )\r\n```\r\n**注意**\r\n- 如果 ini 文件中的值包含任何非字母数字的字符，需要将其括在双引号中（\"）\r\n\r\n- 有些保留字不能作为 ini 文件中的键名，包括：null，yes，no，true 和 false。值为 null，no,off 和 false 等效于 \"\"，值为 yes,on, true 等效于 \"1\"。字符 {}|&~![()\" 也不能用在键名的任何地方，而且这些字符在选项值中有着特殊的意义。\r\n\r\n### 进一步用法\r\n\r\n- 常量可以在 ini 文件中被解析，因此如果在运行 parse_ini_file() 之前定义了常量作为 ini 的值，将会被集成到结果中去\r\n\r\n```php\r\ndefine(\'BIRD\',\'this is bird\');\r\n$arr = parse_ini_file(\'./config.ini\');\r\nprint_r($arr);\r\n```\r\n可以看到config.ini的BIRD的值被解析成this is bird字符串了\r\n\r\n- 支持第二个参数，获取多维数组\r\n\r\n```php\r\n//config.ini\r\n\r\n[base]\r\n\r\nurl = 127.0.0.1\r\n[local] \r\nurl = localhost\r\n\r\n[product]\r\n\r\nurl = http://www.fxjson.com\r\n```\r\n\r\n```php\r\n<?php\r\n\r\n$arr = parse_ini_file(\'./config.ini\',true);\r\n\r\nprint_r($arr);\r\n\r\n```\r\n输出结果\r\n\r\n```php\r\nArray\r\n(\r\n    [base] => Array\r\n        (\r\n            [url] => 127.0.0.1\r\n        )\r\n\r\n    [local] => Array\r\n        (\r\n            [url] => localhost\r\n        )\r\n\r\n    [product] => Array\r\n        (\r\n            [url] => http://www.fxjson.com\r\n        )\r\n\r\n)\r\n```\r\n\r\n### 活学活用\r\n根据上面的基本用法，我们可以用ini作为配置文件，实现配置的继承和差异化,使用过yaf的大佬应该都知道application.ini的配置继承，我们也可以实现类似yaf解析配置的效果\r\n```php\r\n//config.ini\r\n[base]\r\nhost=localhost\r\nuser=root\r\npass=root123\r\ndatabase=default\r\ndebug=on\r\n\r\n[development:base]\r\ndatabase=fxjson\r\n\r\n[product : base]\r\ndatabase=wcshop\r\ndebug = off\r\n```\r\n```php\r\n<?php\r\n\r\n/**\r\n * @param string $filename\r\n * @return array\r\n */\r\nfunction parse_ini_file_extended($filename) {\r\n    $p_ini = parse_ini_file($filename, true);\r\n    $config = array();\r\n    foreach($p_ini as $namespace => $properties){\r\n        list($name, $extends) = explode(\':\', $namespace);\r\n        $name = trim($name);\r\n        $extends = trim($extends);\r\n        // create namespace if necessary\r\n        if(!isset($config[$name])) $config[$name] = array();\r\n        // inherit base namespace\r\n        if(isset($p_ini[$extends])){\r\n            foreach($p_ini[$extends] as $prop => $val)\r\n                $config[$name][$prop] = $val;\r\n        }\r\n        // overwrite / set current namespace values\r\n        foreach($properties as $prop => $val)\r\n        $config[$name][$prop] = $val;\r\n    }\r\n    return $config;\r\n}\r\n\r\nprint_r(parse_ini_file_extended(\'./config.ini\'));\r\n?>\r\n```\r\n最后得到结果\r\n```php\r\n\r\nArray\r\n(\r\n    [base] => Array\r\n        (\r\n            [host] => localhost\r\n            [user] => root\r\n            [pass] => root123\r\n            [database] => default\r\n            [debug] => 1\r\n        )\r\n\r\n    [development] => Array\r\n        (\r\n            [host] => localhost\r\n            [user] => root\r\n            [pass] => root123\r\n            [database] => fxjson\r\n            [debug] => 1\r\n        )\r\n\r\n    [product] => Array\r\n        (\r\n            [host] => localhost\r\n            [user] => root\r\n            [pass] => root123\r\n            [database] => wcshop\r\n            [debug] => \r\n        )\r\n\r\n)\r\n```\r\n我们看到了，product作为我们的生产配置继承了基础设置，也可以重写修改成自己的配置\r\n\r\n### 总结\r\n\r\n巧用官方提供的内置函数，也能干很多有意思的事情，多查手册，怀有好奇心，一定会有收获',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,702,0),(37,'CodeIgniter4学习之限流类提取','37',1594099680,1594101322,'<!--markdown-->限流最常用于对 API 进行速率限制，或限制用户针对表单进行的尝试次数，以帮助防止暴力攻击。\r\n\r\nCI4限流类不会自发地做任何的请求速率限制或对请求进行限流，但却是限流功能得以实现的关键\r\n\r\nCI4限流跟Laravel还是不太一样的，Laravel限流其实是熔断，一旦到达限流的阈值，则时间段内一直阻断后面的处理，但是CI4的限流模式是限流常用的方式，采用令牌桶算法，时间段内可以限制流量，实现降级，不会暴力的完全阻断\r\n\r\n### 代码\r\n抽取的限流代码如下，限流数据存储依赖于缓存，我只抽取了Redis方式相关的代码，如果你需要用其它的存储方式的话，存储类实现CacheInterface接口即可\r\n\r\n```php\r\n<?php\r\n\r\n/**\r\n * Cache interface\r\n */\r\ninterface CacheInterface {\r\n\r\n	/**\r\n	 * Attempts to fetch an item from the cache store.\r\n	 *\r\n	 * @param string $key Cache item name\r\n	 *\r\n	 * @return mixed\r\n	 */\r\n	public function get($key);\r\n\r\n	//--------------------------------------------------------------------\r\n\r\n	/**\r\n	 * Saves an item to the cache store.\r\n	 *\r\n	 * @param string  $key   Cache item name\r\n	 * @param mixed   $value The data to save\r\n	 * @param integer $ttl   Time To Live, in seconds (default 60)\r\n	 *\r\n	 * @return mixed\r\n	 */\r\n	public function save($key, $value, $ttl = 60);\r\n}\r\n\r\n/**\r\n * Redis cache handler\r\n */\r\nclass RedisHandler implements CacheInterface {\r\n\r\n	/**\r\n	 * Redis connection\r\n	 *\r\n	 * @var Redis\r\n	 */\r\n	protected $redis;\r\n\r\n	/**\r\n	 * Constructor\r\n	 */\r\n	public function __construct($host = \'127.0.0.1\',$port = 6379) {\r\n		$this->redis = new Redis;\r\n		$this->redis->connect($host,$port);\r\n	}\r\n\r\n		/**\r\n	 * Attempts to fetch an item from the cache store.\r\n	 *\r\n	 * @param string $key Cache item name\r\n	 *\r\n	 * @return mixed\r\n	 */\r\n	public function get($key)\r\n	{\r\n\r\n		return $this->redis->get($key);\r\n	}\r\n\r\n\r\n	/**\r\n	 * Saves an item to the cache store.\r\n	 *\r\n	 * @param string  $key   Cache item name\r\n	 * @param mixed   $value The data to save\r\n	 * @param integer $ttl   Time To Live, in seconds (default 60)\r\n	 *\r\n	 * @return mixed\r\n	 */\r\n	public function save($key, $value, $ttl = 60)\r\n	{\r\n		return $this->redis->set($key, $value, $ttl);\r\n	}\r\n}\r\n\r\nclass RateLimiter\r\n{\r\n\r\n	/**\r\n	 * Container for throttle counters.\r\n	 *\r\n	 */\r\n	protected $cache;\r\n\r\n	/**\r\n	 * The prefix applied to all keys to\r\n	 * minimize potential conflicts.\r\n	 *\r\n	 * @var string\r\n	 */\r\n	protected $prefix = \'ratelimiter_\';\r\n\r\n\r\n	//--------------------------------------------------------------------\r\n\r\n	/**\r\n	 * Constructor.\r\n	 *\r\n	 * @param  type $cache\r\n	 * @throws type\r\n	 */\r\n	public function __construct(CacheInterface $cache)\r\n	{\r\n		$this->cache = $cache;\r\n	}\r\n\r\n	//--------------------------------------------------------------------\r\n\r\n	/**\r\n	 * Restricts the number of requests made by a single IP address within\r\n	 * a set number of seconds.\r\n	 *\r\n	 * Example:\r\n	 *\r\n	 *  if (! $throttler->check($request->ipAddress(), 60, MINUTE))\r\n	 * {\r\n	 *      die(\'You submitted over 60 requests within a minute.\');\r\n	 * }\r\n	 *\r\n	 * @param string  $key      The name to use as the \"bucket\" name.\r\n	 * @param integer $capacity The number of requests the \"bucket\" can hold\r\n	 * @param integer $seconds  The time it takes the \"bucket\" to completely refill\r\n	 * @param integer $cost     The number of tokens this action uses.\r\n	 *\r\n	 * @return   boolean\r\n	 * @internal param int $maxRequests\r\n	 */\r\n	public function check($key, $capacity, $seconds = 60, $cost = 1)\r\n	{\r\n		$tokenName = $this->prefix . $key;\r\n\r\n		$nowTime = time();\r\n		// Check to see if the bucket has even been created yet.\r\n		if (($tokens = $this->cache->get($tokenName)) === null)\r\n		{\r\n			// If it hasn\'t been created, then we\'ll set it to the maximum\r\n			// capacity - 1, and save it to the cache.\r\n			$this->cache->save($tokenName, $capacity - $cost, $seconds);\r\n			$this->cache->save($tokenName . \'Time\', $nowTime, $seconds);\r\n\r\n			return true;\r\n		}\r\n\r\n		// If $tokens > 0, then we need to replenish the bucket\r\n		// based on how long it\'s been since the last update.\r\n		$throttleTime = $this->cache->get($tokenName . \'Time\');\r\n		$elapsed      = time() - $throttleTime;\r\n\r\n		// Number of tokens to add back per second\r\n		$rate = $capacity / $seconds;\r\n\r\n		// Add tokens based up on number per second that\r\n		// should be refilled, then checked against capacity\r\n		// to be sure the bucket didn\'t overflow.\r\n		$tokens += $rate * $elapsed;\r\n		$tokens  = $tokens > $capacity ? $capacity : $tokens;\r\n\r\n		// If $tokens > 0, then we are safe to perform the action, but\r\n		// we need to decrement the number of available tokens.\r\n		if ($tokens > 0)\r\n		{\r\n			$this->cache->save($tokenName, $tokens - $cost, $seconds);\r\n			$this->cache->save($tokenName . \'Time\', time(), $seconds);\r\n			return true;\r\n		}\r\n		return false;\r\n	}\r\n\r\n}\r\n```\r\n\r\n### 使用方法\r\n\r\n```php\r\n$cache = new RedisHandler;\r\n\r\n$rateLimiter = new RateLimiter($cache);\r\n\r\nif(!$rateLimiter->check($_SERVER[\'REMOTE_ADDR\'],30)) {\r\n	echo \'限流了\';\r\n} else {\r\n	echo \'正常访问\';\r\n}\r\n```\r\n例子的意思是，限制每个ip的QPS为30/min，因为使用的是令牌桶算法，所以并不是绝对限制每分钟接收30个请求，意思是当达到30个请求每分钟时，会进行降级处理，仍然可以请求，只不过单位请求量降低了\r\n\r\n### 限流方法说明\r\n\r\n限流方法只有一个check方法，参数一共有4个\r\n- $key (string) – 储存桶的名称\r\n- $capacity (int) – 储存桶中持有的令牌数量\r\n- $seconds (int) – 储存桶完全填满的秒数\r\n- $cost (int) – 此操作将会花费的令牌数量，默认一个\r\n\r\n如果可以正常执行则函数返回 TRUE，否则返回 FALSE\r\n\r\n调用该 check() 方法时，你要告诉它存储桶的大小， 可以容纳多少令牌以及时间间隔。在默认情况下，每个 check() 的调用请求将会使用1个可用令牌。\r\n\r\n假设我们希望限制每个客户端每分钟120请求，则参考代码如下\r\n\r\n```php\r\n$cache = new RedisHandler;\r\n\r\n$rateLimiter = new RateLimiter($cache);\r\n\r\nif(!$rateLimiter->check($_SERVER[\'REMOTE_ADDR\'],120,60)) {\r\n	echo \'限流了\';\r\n} else {\r\n	echo \'正常访问\';\r\n}\r\n```\r\n### 算法说明\r\n- 当前key是第一次请求，则校验通过，同时存储当前请求时间和剩余允许请求次数\r\n- 非第一次请求\r\n	1. 获取上次请求时间\r\n	2. 计算当前时间与上次请求时间差=当前时间-上次请求时间\r\n	3. 计算速率=函数参数传递的容量次数(令牌数)/参数传递的时间\r\n	4. 计算产生的新令牌=速率*时间差\r\n	5. 合计令牌数=桶内剩余令牌数目+产生的新令牌\r\n	6. 重置桶内令牌数:若合计令牌数>桶允许的令牌数，则桶内令牌数为桶允许的令牌数，否则为5计算出的合计令牌数\r\n	7. 校验重置后桶内令牌数是否>0，大于0则校验通过，存储当前时间和桶内令牌剩余数，否则校验失败，即认为应该限流了\r\n\r\n',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,1110,1),(38,'git之.gitignore和.gitkeep文件','38',1594183200,1594183665,'<!--markdown-->### .gitignore\r\n\r\n用过git版本工具的同学应该都见过.gitignore文件了，那这个文件是干什么的呢，一句话:**.gitignore文件是用来让git去忽略你版本控制系统中不需要的文件的**。也就是说，用于列出那些让git忽略，不被跟踪的文件，即排除在git的版本控制外。\r\n\r\n- 忽略指定名称的文件\r\n\r\n```shell\r\n# .gitignore示例，忽略test.txt文件 \r\ntest.txt\r\n```\r\n- 忽略指定后缀的文件\r\n\r\n```shell\r\n# .gitignore示例，忽略后缀为.txt的文件 \r\n###################\r\n*.txt\r\n```\r\n\r\n- 忽略文件夹\r\n\r\n```shell\r\n# .gitignore示例，忽略后缀为mydir文件夹以及文件夹中的内容\r\n###################\r\nmydir/\r\n```\r\n\r\n### .gitkeep\r\n\r\n在github上看开源源码的时候，经常看到有的项目文件夹里有.gitkeep文件，也不知道是有什么用，出于好奇查阅了下资料。原来.gitkeep是一个占位文件,什么意思呢？**git不会追踪和提交一个完全空的文件夹到版本库**，为了让空文件夹被跟踪，常规做法是在空文件夹里添加.gitkeep, .gitkeep并不是git的特性，git没有对占位文件名有要求，你可以放README、.nofile或者其他的占位文件，只要保证文件夹内不空即可，业内人员已经习惯使用.gitkeep作为占位文件，已经达成了共识，所以当我们项目中有需要的话，还是保持国际惯例的好。\r\n\r\n**千万不要把.gitkeep写到.gitignore里，这样的话，所有的空目录都不会被追踪了，也就提交不了了**',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,702,0),(40,'CodeIgniter4学习之Kint库','40',1594562820,1595034997,'<!--markdown-->我不是大牛，我只是代码的搬运工，上周末学习了下CodeIgniter4，首先看了下composer.json的依赖库，其中require里面有kint-php/kint，这是什么鬼，于是搜索了一番资料。\r\n\r\n### 介绍\r\nKint是一个免费开源，用来替代系统内置的比如var_dump(),print_r(),debug_backtrace()等相关函数的调试利器,方便的很，谁用谁知道，不过当前像laravel、symfony等开源项目都有自己的调试规则，一般用不到，但是对自研项目还是有可取之处的。话不多说，直接看效果图\r\n![1.jpg](http://39.103.150.24/usr/uploads/2020/07/3110350317.jpg)\r\n\r\n### 安装\r\n```php\r\ncomposer require kint-php/kint\r\n```\r\n\r\n### 使用\r\n```php\r\n<?php\r\n\r\nrequire_once \'./vendor/autoload.php\';\r\nKint\\Renderer\\RichRenderer::$theme = \'aante-light.css\';\r\n\r\n//Kint::$enabled_mode = false;\r\nKint\\Renderer\\RichRenderer::$folder	= false;\r\nd($_SERVER,$GLOBALS);\r\n```\r\n### 配置说明\r\n\r\n- 设置主题\r\n\r\n支持四种样式的主题original.css、solarized.css、solarized-dark.css、aante-light.css,默认是original.css,可以使用下面的方法修改主题\r\n\r\n```php\r\nKint\\Renderer\\RichRenderer::$theme = \'aante-light.css\';\r\n```\r\n- 展开输出调试\r\n组件默认将调试输出折叠在浏览单底部，如果需要默认展开显示可设置如下\r\n\r\n```php\r\nKint\\Renderer\\RichRenderer::$folder	= false;//true折叠，false不折叠\r\n```\r\n\r\n- 关闭输出\r\n有时候，我们只想在开发环境进行调试输出，可以通过配置 Kint::$enabled_mode = false;来将相应的代码不输出\r\n\r\n### 方法说明\r\n\r\n```php\r\n\r\n//输出\r\nKint::dump($_SERVER,$GLOBALS);\r\nd($_SERVER,$GLOBALS);//Kint::dump的简写方式\r\n\r\n//跟踪调试信息:\r\nKint::trace();\r\nKint::dump( 1 );//同Kint::trace()\r\n\r\n//文本方式输出\r\ns($_SERVER);\r\n\r\n```\r\n\r\n### 其它\r\n\r\n更多使用上的用法可以参考[Kint官网](https://kint-php.github.io/kint)，我这里只是抛转引用，借用github上看到的一句话:想学习的人总会找到目录，我改成想学习的人总会找到入口。\r\n',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,778,0),(41,'1.jpg','1-jpg',1594563078,1594563078,'a:5:{s:4:\"name\";s:5:\"1.jpg\";s:4:\"path\";s:35:\"/usr/uploads/2020/07/3110350317.jpg\";s:4:\"size\";i:74157;s:4:\"type\";s:3:\"jpg\";s:4:\"mime\";s:10:\"image/jpeg\";}',1,2,NULL,'attachment','publish',NULL,0,'1','0','1',40,0,0),(42,'常用魔术方法','42',1594615860,1594616209,'<!--markdown-->\\__construct、\\__destruct、\\__toString大家已经非常熟悉，这里不再做介绍\r\n\r\n### 说明\r\n- __get:**访问不存在或者没有权限访问**的属性，会调用\r\n- __set:**修改不存在或者没有权限**的属性时，会调用\r\n- __call:**访问实例不存在或者没有权限访问**的方法时，会调用\r\n- __callStatic:**访问类不存在或者没有权限**的静态方法时，会调用\r\n- __invoke:把实例**当作函数**使用，会调用\r\n\r\n为什么会使用这些魔术方法:\r\n- 做更好的逻辑控制，比如将所有属性定义成private,然后\\__get,\\__set可以更好控制代码逻辑\r\n- 访问一个不确定的方法，或者方法参数不确定时，\\__call方法，然后使用call_user_func_array()调用实际方法\r\n- \\__callStatic动态访问静态方法，也可以更好的控制逻辑代码以及参数，laravel中门面模式使用的就是这种方法，比如laravel中Route::get、Route::post实际上是通过静态访问，调用\\__callStatic方法，然后访问底层实际类的方法，而不是Route类的get或者post方法\r\n\r\n实例demo如下:\r\n\r\n```php\r\n<?php\r\n\r\nclass Container {\r\n\r\n    public $name = \'hello\';\r\n\r\n    private $name1 = \'private\';\r\n\r\n    public function __get($name) {//访问不存在或者没有权限访问的属性时，会调用该方法\r\n        var_dump($name);\r\n    }\r\n\r\n    public function __set($name,$value) {//修改不存在或者没有权限访问的属性时，会调用该方法\r\n        var_dump($name,$value);\r\n    }\r\n\r\n    public function say() {\r\n        echo \"say\";\r\n    }\r\n\r\n    protected function p() {\r\n        echo \"p\";\r\n    }\r\n\r\n    public function __call($method,$arguments) {//调用不存在或者没有权限访问的实例方法时会调用\r\n        var_dump(\"__call\",$method,$arguments);\r\n    }\r\n\r\n    public static function dd() {\r\n        echo \"static dd\";\r\n    }\r\n\r\n    public static function __callStatic($method,$arguments) {//调用不存在或者没有权限访问的静态方法时会调用\r\n        var_dump(\'__callStatic\',$method,$arguments);\r\n    }\r\n\r\n    public function __invoke($a,$b,$c) {//把实例对象当作方法调用，会自动调用到 __invoke() 方法\r\n        echo \"__invoke\";\r\n    }\r\n}\r\n\r\n$obj = new Container;\r\n\r\n$obj->name; //public属性，不会调用__get\r\n$obj->name1;//private属性，类外没权限访问，会调用__get\r\n$obj->age;//不存在的属性,会调用__get\r\n\r\n$obj->name= \'aaaa\';//修改public属性，不会调用__set\r\n$obj->name1=\'111111\';//修改private属性，会调用__set\r\n$obj->age=30;//修改不存在的属性，会调用__set\r\n\r\n$obj->say();//访问public实例方法不会调用__call\r\n$obj->p();//访问protected实例方法，会调用__call\r\n$obj->hello();//访问不存在的实例方法，会调用__call\r\n\r\nContainer::dd();//调用public的静态方法，不会调用__callStatic\r\nContainer::hello();//不存在的静态方法\r\n\r\n$obj(11,22,33);//把实例方法当作函数调用\r\n```',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,693,0),(43,'设计模式之单例模式','43',1594619280,1594688185,'<!--markdown-->### 概念\r\n\r\n单例模式，顾名思义就是只有一个实例。单例模式确保某一个类在代码运行过程中只存在一个实例，不能重复创建实例。\r\n\r\n### 优点\r\n\r\n使用单例模式的好处很大，以数据库操作为例，若不采用单例模式，当程序中出现大量数据库操作时，每次都要执行new操作，\r\n每次都会消耗大量的内存资源和系统资源，而且每次打开和关闭数据库连接都是对数据库的一种极大考验和浪费。使用了单例模式，只需要实例化一次，不需要每次都执行new操作，极大降低了资源的耗费。一句话，减少资源的消耗。\r\n\r\n### 要素\r\n- 需要一个保存类的唯一实例的静态成员变量\r\n- 构造函数和克隆函数必须声明为私有的，防止外部程序创建或复制实例副本。\r\n- 必须提供一个访问这个实例的公共静态方法，从而返回唯一实例的一个引用\r\n上面三条，简称**三私一公**：私有化静态属性，私有化构造方法，私有化克隆方法，公有化静态方法\r\n\r\n### 三私一公\r\n\r\n面试过一些同行，问他们怎么实现一个单例模式，都会说三私一共，我再问能具体说下实现逻辑吗，有的说私有的属性，但是却忽略了静态修饰符。还有的人忽略了构造方法的私有性，我问他们那我new会怎么样，他们一时无法回答上来。\r\n\r\n所谓三私一公，必须先声明一个静态私有属性:用来保存当前类的实例\r\n- 为什么必须是静态的?因为静态成员属于类,并被类所有实例所共享，可以用该属性去判断类是否被实例化过\r\n- 为什么必须是私有的?不允许外部直接访问,仅允许通过类方法控制方法，避免类外进行类以及属性信息修改\r\n\r\n必须将构造方法修饰为private私有方法，因为new始终会返回一个类的新实例，如果不修饰为private，则无法避免用户不去new，也就无法实现单例\r\n\r\n必须将\\__clone魔术方法修饰成private,用来禁止克隆。因为对象之间进行克隆可生成不同的对象,而对象克隆时会自动调用类的\\__conle方法，因此将克隆方法设置为private属性\r\n\r\n### 实现代码\r\n\r\n综上我们可以实现一个基本的单例模式\r\n```php\r\n<?php\r\n\r\nclass Database {\r\n\r\n    private static $instance = null; //私有静态属性，存放该类的实例\r\n\r\n    private function __construct() { //私有构造方法，防止在类的外部实例化\r\n\r\n    }\r\n\r\n    private function __clone() {//私有克隆方法，防止克隆\r\n\r\n    }\r\n\r\n    public static function getInstance() {//公共的静态方法，实例化该类本身，只实例化一次\r\n\r\n        if(!self::$instance instanceof self) {\r\n            self::$instance = new self;\r\n        }\r\n        return self::$instance;\r\n    }\r\n}\r\n```\r\n\r\n使用方式\r\n\r\n```php\r\n$db = Database::getInstance();\r\nprint_r($db);\r\n```\r\n\r\n### 说明\r\n\r\n- 类外使用new Database会报错\r\n\r\n```shell\r\nFatal error: Call to private Database::__construct() from invalid context in E:\\project\\chain\\logistics\\d.php on line 23\r\n```\r\n- 类外使用clone报错\r\n\r\n```php\r\n$db = Database::getInstance();\r\n$db1 = clone $db;\r\n```\r\n```shell\r\nFatal error: Call to private Database::__clone() from context \'\' in E:\\project\\chain\\logistics\\d.php on line 25\r\n```\r\n\r\n- 证明单例\r\n\r\n```php\r\n$db = Database::getInstance();\r\n$db1 = Database::getInstance();\r\n\r\n$db->name = \'Json\';\r\nprint_r($db);\r\nprint_r($db1);\r\n```\r\n\r\n输出\r\n```shell\r\nDatabase Object ( [name] => Json ) Database Object ( [name] => Json )\r\n```\r\n证明db1和db指向的是同一个对象，实现了单例\r\n\r\n',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,636,0),(44,'设计模式之注册树模式','44',1594794328,1594794328,'<!--markdown-->### 概念\r\n\r\n注册树模式就是将对象或者元素注册到一棵全局的对象树上，需要的时候从对象树上获取的一种模式设计方法，也叫注册模式、注册器模式\r\n\r\n### 优点\r\n\r\n- 便于对象或元素的统一管理调度\r\n- 减少重复代码，需要的时候从树上获取元素即可\r\n\r\n### 实现\r\n```php\r\n<?php\r\n\r\nclass Registry {\r\n\r\n    private static $_elements = array();\r\n    \r\n    //挂载元素节点\r\n    public static function set($key,$value) {\r\n        self::$_elements[$key] = $value;\r\n    }\r\n    \r\n    //获取元素\r\n    public static function get($key) {\r\n        return self::$_elements[$key];\r\n    }\r\n    \r\n    //摘除节点\r\n    public static function del($key) {\r\n        unset(self::$_elements[$key]);\r\n    }\r\n    \r\n    //检查节点是否存在\r\n    public static function has($key) {\r\n        return array_key_exists($key,self::$_elements);\r\n    }\r\n}\r\n```\r\n\r\n### 使用\r\n```php\r\nclass DB {\r\n}\r\n\r\nRegistry::set(\'db\',new DB);\r\n\r\nif(Registry::has(\'db\')) {\r\n    print_r(Registry::get(\'db\'));\r\n} else {\r\n    echo \"节点不存在\";\r\n}\r\n```\r\n\r\n### 其它\r\n\r\n在许多开源框架比如Laravel、Yii等框架中，都使用了服务容器，其实服务容器也包含了注册树模式思想，将所有对象注册到容器中，需要的时候从容器里面获取就好了，而不需要自己从别的地方获取对象或者元素\r\n\r\n',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,720,0),(45,'redisphp.png','redisphp-png',1594825240,1594825240,'a:5:{s:4:\"name\";s:12:\"redisphp.png\";s:4:\"path\";s:35:\"/usr/uploads/2020/07/2632389623.png\";s:4:\"size\";i:25749;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',1,2,NULL,'attachment','publish',NULL,0,'1','0','1',46,0,0),(46,'phpredis自动完成插件','46',1594825380,1595035527,'<!--markdown-->### 前言\r\n\r\n之前很少使用phpstorm进行项目开发,习惯了使用vscode、sublime,后来由于项目需要,sublime、vscode有些代码不能友好的提示出来，也不能很好的自动补全，多有不方便之处，最终还是安装了phpstorm，一个偶然的尝试,发现phpstorm竟然可以自动提示phpredis、memcached、yaf等的方法，phpstorm这个ide果真强大啊，通过ctrl+鼠标左键自动追溯跳转到函数或者方法定义之处。发现phpstorm集成内置了常用扩展的原型定义，在phpstorm安装目录/plugins/php/lib/php.jar包里面，于是通过函数跳转我发现了集成的phpredis的stub原来来源于[https://github.com/ukko/phpredis-phpdoc](https://github.com/ukko/phpredis-phpdoc).\r\n\r\n### 插件下载\r\n- 通过composer进行安装\r\n```php\r\ncomposer require ukko/phpredis-phpdoc\r\n```\r\n\r\n- 直接通过[github](https://github.com/ukko/phpredis-phpdoc)下载源码\r\n\r\n### 使用方式\r\n比较新的phpstorm已经集成了这个插件，不需要再设置什么,如果不自动提示，可手动设置\r\n\r\n```shell\r\nMenu \"File\" -> \"Settings\" -> \"PHP\" -> Select path to folder \"phpredis-phpdoc\"\r\n```\r\n\r\n### 插件作用\r\n\r\n可以自动提示并完成phpredis的方法,并带有方法参数说明\r\n\r\n![redisphp.png](http://www.fxjson.com/usr/uploads/2020/07/2632389623.png)\r\n\r\n### 举例\r\n\r\n```php\r\n$redis = new Redis();\r\n$redis->con<press Tab or press Ctrl+Space>\r\n```\r\n### 其它\r\n\r\n这个插件的src/Redis.php文件里每一个方法都有方法注释，以及使用的example，大大方便了我们使用。更多细节和注意事项，大家可以通过作者的[github](https://github.com/ukko/phpredis-phpdoc)进行查看\r\n```php\r\n/**\r\n* Set the string value in argument as value of the key.\r\n*\r\n* @since If you\'re using Redis >= 2.6.12, you can pass extended options as explained in example\r\n*\r\n* @param string       $key\r\n* @param string|mixed $value string if not used serializer\r\n* @param int|array    $timeout [optional] Calling setex() is preferred if you want a timeout.<br>\r\n* Since 2.6.12 it also supports different flags inside an array. Example [\'NX\', \'EX\' => 60]<br>\r\n*  - EX seconds -- Set the specified expire time, in seconds.<br>\r\n*  - PX milliseconds -- Set the specified expire time, in milliseconds.<br>\r\n*  - PX milliseconds -- Set the specified expire time, in milliseconds.<br>\r\n*  - NX -- Only set the key if it does not already exist.<br>\r\n*  - XX -- Only set the key if it already exist.<br>\r\n* <pre>\r\n* // Simple key -> value set\r\n* $redis->set(\'key\', \'value\');\r\n*\r\n* // Will redirect, and actually make an SETEX call\r\n* $redis->set(\'key\',\'value\', 10);\r\n*\r\n* // Will set the key, if it doesn\'t exist, with a ttl of 10 seconds\r\n* $redis->set(\'key\', \'value\', [\'nx\', \'ex\' => 10]);\r\n*\r\n* // Will set a key, if it does exist, with a ttl of 1000 milliseconds\r\n* $redis->set(\'key\', \'value\', [\'xx\', \'px\' => 1000]);\r\n* </pre>\r\n*\r\n* @return bool TRUE if the command is successful\r\n*\r\n* @link     https://redis.io/commands/set\r\n*/\r\npublic function set($key, $value, $timeout = null)\r\n{\r\n}\r\n```',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,1075,1),(47,'设计模式之空对象模式','47',1594961400,1594961753,'<!--markdown-->### 情景分析\r\n\r\n在项目开发过程中，经常会使用各种各样的日志记录系统，根据业务场景有的日志写到文件，有的存储到Database，还有的存储到es或者mongodb里面,这时候经常定义一个接口规范，然后各种日志驱动类去实现这个接口，代码如下:\r\n\r\n```php\r\n<?php\r\n//logger接口\r\ninterface Logger {\r\n\r\n    public function info($message);\r\n\r\n    public function error($message);\r\n}\r\n\r\n//实现logger接口的file log类\r\nclass FileLogger implements Logger {\r\n\r\n    public function info($message) {\r\n        echo \'这是file的info方法\';\r\n    }\r\n\r\n    public function error($message) {\r\n        echo \'这是file的error方法\';\r\n    }\r\n}\r\n//实现logger接口的database log类\r\nclass DatabaseLogger implements Logger {\r\n\r\n    public function info($message) {\r\n        echo \'这是database的info方法\';\r\n    }\r\n\r\n    public function error($message) {\r\n        echo \'这是database的error方法\';\r\n    }\r\n}\r\n```\r\n然后定义一个工厂方法，从工厂里面拿需要的缓存组件，代码如下:\r\n\r\n```php\r\nfunction getLogger($name) {\r\n\r\n    $logger = null;\r\n    switch($name) {\r\n        case \'file\':\r\n            $logger = new FileLogger;\r\n            break;\r\n        case \'db\':\r\n            $logger = new DatabaseLogger;\r\n            break;\r\n    }\r\n    return $logger;\r\n}\r\n```\r\n使用logger的方式大概如下:\r\n\r\n```php\r\n$logger = getLogger(\'file\');\r\n\r\n$logger ->info(\'基本信息内容\');\r\necho \"<br/>\";\r\n$logger ->error(\'错误信息内容\');\r\n```\r\n运行结果显然是输出了\r\n\r\n```shell\r\n这是file的info方法:基本信息内容\r\n这是file的error方法:错误信息内容\r\n```\r\n然后我们把使用方式的$logger = getLogger(\'file\')改成getLogger(\'db\')也可以正常输出，那我们改成getLogger(\'database\')或者getLogger(\'mongodb\')会怎么样呢?\r\n\r\n```php\r\n$logger = getLogger(\'database\');\r\n\r\n$logger ->info(\'基本信息内容\');\r\necho \"<br/>\";\r\n$logger ->error(\'错误信息内容\');\r\n```\r\n结果是...报错了\r\n\r\n```text\r\n\r\nFatal error: Call to a member function info() on null in E:\\project\\chain\\logistics\\d.php on line 50\r\n```\r\n写过几年代码的同行应该都遇到过这种错误，错误原因很简单:\r\n我们通过getLogger函数获取Logger对象的时候，如果我们传入的参数字符串非file和db时，就会返回null，表示我们暂时没有logger驱动支持。这时logger变量为null,再调用info、error就会报fatal error错误了。\r\n\r\n我们比较常规的做法就是在使用logger时加一个判断，判断是否为null,如果为null的话，就不再调用info、error方法。如果不为null再调用方法。更改如下：\r\n\r\n```php\r\n$logger = getLogger(\'database\');\r\n\r\nif($logger) {\r\n    $logger ->info(\'基本信息内容\');\r\n    echo \"<br/>\";\r\n    $logger ->error(\'错误信息内容\');\r\n}\r\n```\r\n这时候再运行，就不会报错了。\r\n\r\n---\r\n这样做，确实消除了报错，但是这样做真的好吗？你想如果在一段程序中有很多处调用getLogger写日志，岂不是很多处都要判断logger对象是否为null？稍有不注意可能程序代码就报错了。最重要的是，永远都不要太相信方法使用者或者说客户端，不要把整个程序的稳定性寄托在使用者身上。还有，像上面的处理方法，当获取对象为null的时候，输出的提示信息是有调用者来定制的，这样主动权交给了使用者，而不是logger所有者。\r\n\r\n有的人通常会给一个默认实现方式，比如不存在mongodb的实现方式时，我提供file的方式，如下：\r\n\r\n```php\r\nfunction getLogger($name) {\r\n\r\n    $logger = null;\r\n    switch($name) {\r\n        case \'file\':\r\n            $logger = new FileLogger;\r\n            break;\r\n        case \'db\':\r\n            $logger = new DatabaseLogger;\r\n            break;\r\n        default:\r\n            $logger = new FileLogger;\r\n            break;\r\n    }\r\n    return $logger;\r\n}\r\n```\r\n这样的话，工厂方法永远会返回一个实现Logger接口的示例，调用者也不需要添加不必要的if判断了，似乎没什么问题。但是你觉得这样合理吗，就像我给你要一个苹果，然后你没苹果，你给我一个梨，反正都是水果。\r\n\r\n那究竟应该如何实现才会更加合适呢？那就要用到我们今天要介绍的空对象模式\r\n\r\n### 空对象模式\r\n\r\n定义一个实现Logger接口的空类\r\n\r\n```php\r\nclass NullLogger implements Logger {\r\n    public function info($message) {\r\n    }\r\n\r\n    public function error($message) {\r\n    }\r\n}\r\n```\r\n修改后的工厂方法如下:\r\n```php\r\nfunction getLogger($name) {\r\n\r\n    $logger = null;\r\n    switch($name) {\r\n        case \'file\':\r\n            $logger = new FileLogger;\r\n            break;\r\n        case \'db\':\r\n            $logger = new DatabaseLogger;\r\n            break;\r\n        default:\r\n            $logger = new NullLogger;\r\n            break;\r\n    }\r\n    return $logger;\r\n}\r\n```\r\n调用方式如下：\r\n\r\n```php\r\n$logger = getLogger(\'database\');\r\n\r\n$logger ->info(\'基本信息内容\');\r\necho \"<br/>\";\r\n$logger ->error(\'错误信息内容\');\r\n\r\n```\r\n运行一下，我们发现，即使传入工厂方法的参数是非法值或者不存在的值时，也不会报错了，这是空对象模式的第一个好处。但是现在不报错，也没有任何输出，肯定不够友好，不够人性化。此时，在NullLogger类的info、error方法中，我们可以定制我们的输出提醒，当用户调用空对象的方法时，就会输出我们定制的提醒。这样我们可以实现一处定制，处处输出，主动权在我们手里，而不是在调用者手里。这是空对象模式的第二个好处,定制代码如下:\r\n```php\r\nclass NullLogger implements Logger {\r\n    public function info($message) {\r\n        throw new Exception(\"我还没有实现这个方法，我自己定制了输出\");\r\n    }\r\n\r\n    public function error($message) {\r\n    }\r\n}\r\n```\r\n\r\n空对象最重要的特点是，不需要添加if逻辑判断是否为null了，减少了调用者的代码量，当然有时候调用方根据自己的业务，确实需要知道工厂方法里面是否实现了具体logger驱动，来定制自己的log输出，那可以提供一个isNull方法给调用方，完整代码如下:\r\n\r\n```php\r\n<?php\r\n\r\ninterface Logger {\r\n\r\n    public function isNull();\r\n\r\n    public function info($message);\r\n\r\n    public function error($message);\r\n}\r\n\r\nclass FileLogger implements Logger {\r\n\r\n    public function isNull() {\r\n        return false;\r\n    }\r\n\r\n    public function info($message) {\r\n        echo \'这是file的info方法:\'.$message;\r\n    }\r\n\r\n    public function error($message) {\r\n        echo \'这是file的error方法:\'.$message;\r\n    }\r\n}\r\n\r\nclass DatabaseLogger implements Logger {\r\n\r\n    public function isNull() {\r\n        return false;\r\n    }\r\n\r\n    public function info($message) {\r\n        echo \'这是database的info方法:\'.$message;\r\n    }\r\n\r\n    public function error($message) {\r\n        echo \'这是database的error方法:\'.$message;\r\n    }\r\n}\r\n\r\nclass NullLogger implements Logger {\r\n\r\n    public function isNull() {\r\n        return true;\r\n    }\r\n\r\n    public function info($message) {\r\n        throw new Exception(\"我还没有实现这个方法，我自己定制了输出\");\r\n    }\r\n\r\n    public function error($message) {\r\n    }\r\n}\r\n\r\nfunction getLogger($name) {\r\n\r\n    $logger = null;\r\n    switch($name) {\r\n        case \'file\':\r\n            $logger = new FileLogger;\r\n            break;\r\n        case \'db\':\r\n            $logger = new DatabaseLogger;\r\n            break;\r\n        default:\r\n            $logger = new NullLogger;\r\n            break;\r\n    }\r\n    return $logger;\r\n}\r\n```\r\n调用方代码如下\r\n```php\r\n$logger = getLogger(\'database\');\r\n\r\nif($logger->isNull()) {\r\n    echo \"空对象\";\r\n}\r\n$logger ->info(\'基本信息内容\');\r\necho \"<br/>\";\r\n$logger ->error(\'错误信息内容\');\r\n```\r\n$logger->isNull()比$logger == null更加优雅一点,有面向对象的感觉了\r\n\r\n### 空对象模式作用\r\n\r\n- 减少不必要的if为null判断,从而加强系统的稳固性\r\n- 避免Fatal error,防止空指针报错对整个系统的影响\r\n- 实现对空对象情况的定制化控制，能够掌握处理空对象的主动权\r\n',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,1096,0),(48,'composer库推荐之doctrine/inflector','48',1595034120,1595034379,'<!--markdown-->composer似乎在今天已经成为phper安装第三方扩展包的标准方式了,不用composer安装似乎已经落伍了，那今天就给大家推荐一个composer库，那就是doctrine/inflector\r\n\r\n### 介绍\r\ndoctrine/inflector是转换单词大小写、单复数格式的一个小型类库，什么意思呢,简单举例如下:\r\n\r\n- 将category转成categories\r\n- 将users转成user\r\n- 将post转成Post,将post_category转成PostCategory\r\n- 将Post转成post,PostCategory转成post_category\r\n\r\n### 使用场景\r\n- 用于数据表名称和model名称的转换\r\n用过一些开源框架的同学应该都知道，表名称一般都是小写，有的关系表还是table_name这种格式的，但我们的model名称习惯都是驼峰式User,UserModel这种格式；还有的项目规范要求表名称都是复数格式，model都是单数形式，这时候这个类库就发挥作用了。\r\n\r\n### 安装\r\n```php\r\ncomposer require doctrine/inflector\r\n```\r\n\r\n### 使用\r\n```php\r\n<?php\r\nrequire_once \'./vendor/autoload.php\';\r\n\r\nuse Doctrine\\Inflector\\InflectorFactory;\r\n\r\n$inflector = InflectorFactory::create()->build();\r\n\r\n//Converts ModelName to model_name\r\n\r\necho $inflector->tableize(\'UserCategory\'); // user_category\r\n\r\n//Converts model_name to ModelName:\r\necho $inflector->classify(\'user_category\'); // UserCategory\r\n\r\n//This method uses Classify and then converts the first character to lowercase:\r\necho $inflector->camelize(\'model_name\'); // modelName\r\n\r\n//Returns a word in plural form.\r\necho $inflector->pluralize(\'category\'); // categories\r\n\r\n//Returns a word in singular form.\r\necho $inflector->singularize(\'users\'); // user\r\n```\r\n\r\n### 常用方法说明\r\n- tableize(string $word)\r\n\r\n```php\r\n//将ModelName格式转成model_name格式\r\necho $inflector->tableize(\'ModelName\'); // model_name\r\n```\r\n- classify(string $word)\r\n\r\n```php\r\n//将model_name转成驼峰ModelName格式\r\necho $inflector->classify(\'model_name\'); // ModelName\r\n```\r\n\r\n- camelize(string $word)\r\n\r\n```php\r\n//将model_name转成首字母小写的驼峰格式modelName\r\necho $inflector->camelize(\'model_name\'); // modelName\r\n```\r\n\r\n- pluralize(string $word)\r\n\r\n```php\r\n//将category单数形式转成复数形式\r\necho $inflector->pluralize(\'category\'); // categories\r\n```\r\n\r\n- singularize(string $word)\r\n\r\n```php\r\n//复数users形式转成user单数形式\r\necho $inflector->singularize(\'users\'); // user\r\n```\r\n\r\n### 其它\r\n当然doctrine/inflector类库还提供其它用途的函数方法，不过用的最多的应该就是这几个了，更多方法可以参考[doctrine/inflector](https://github.com/doctrine/inflector)的github仓库',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,1513,0),(49,'一个不太常用的php异步调用方式','49',1595038500,1595038967,'<!--markdown-->php异步调用基本上都是结合消息队列来实现的，但是有时候现实是很骨感的，服务端没有安装消息队列服务，那这时候怎么实现异步呢；还有一个策略是结合存储中间件+crontab轮询，但是这难免会有时间差的影响，不能实时触发，笔者就遇到了这种困境，项目早期没有消息队列的引入，又要实时触发，要优化当前请求的效率，怎么办呢，就引入了今天的一个不太常用的异步方式。\r\n\r\n### 异步好处\r\n\r\n- 解耦代码\r\n- 减少客户端的响应时间，提高吞吐量\r\n\r\n### 代码\r\n```php\r\n<?php\r\npclose(popen(\"/usr/bin/php /home/web/task.php &\",\'r\'));\r\n```\r\n### 代码说明\r\n\r\n对的你没有看错,用popen+pclose函数就可以实现异步执行代码了\r\n\r\n- popen\r\n1. popen()函数通过创建一个管道，调用fork()产生一个子进程\r\n2. popen(command,mode)有两个参数，第一个是执行的命令，第二个是连接模式\r\n\r\n- pclose\r\n关闭由popen()打开的管道\r\n\r\n*注意popen中command中的异步是有条件的，需要在command后面加上“&”，表示后台执行，这样才不会对PHP造成阻塞*\r\n\r\n### 缺点\r\n\r\n- popen只能在本机执行\r\n- command不能传递大数据量的参数\r\n- 高并发时会创建很多进程\r\n- 根据服务器自身情况会出现fork出的进程执行不完就被kill掉\r\n\r\n### 其它\r\n\r\n使用popen、pclose函数前需要检查php.ini里面disable_functions参数有没有禁用掉这些函数,有的服务器配置考虑到系统安全性是禁用这些函数的\r\n```shell\r\ndisable_functions => passthru,exec,system,chroot,chgrp,chown,shell_exec,proc_open,proc_get_status,popen,ini_alter,ini_restore,dl,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server => passthru,exec,system,chroot,chgrp,chown,shell_exec,proc_open,proc_get_status,popen,ini_alter,ini_restore,dl,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server\r\n```\r\n如果禁用的话，使用函数会出现错误\r\n```shell\r\nPHP Warning:  popen() has been disabled for security reasons\r\nPHP Warning:  pclose() expects parameter 1 to be resource, null given in \r\n```\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,1129,0),(50,'php容器推荐之Pimple','50',1595080320,1595081174,'<!--markdown-->Pimple是一个简单的php版本依赖注入容器，官网地址是[https://pimple.symfony.com/](https://pimple.symfony.com/)，当前pimple最新版本是3.0，我们用3.0进行使用讲解\r\n### 安装\r\n- composer\r\n```shell\r\n  composer require pimple/pimple ~3.0\r\n```\r\n- c extension\r\nPimple容器也提供了c扩展形式的安装方式，性能应该比php原生的要好\r\n```shell\r\n$ git clone https://github.com/silexphp/Pimple\r\n$ cd Pimple/ext/pimple\r\n$ phpize\r\n$ ./configure\r\n$ make\r\n$ make install\r\n```\r\n\r\n### 使用\r\n- 创建容器实例\r\n\r\n	```shell\r\n	<?php\r\n\r\n	require_once(__DIR__ . \'/vendor/autoload.php\');\r\n\r\n	use Pimple\\Container;\r\n\r\n	$container = new Container();\r\n	```\r\n- 容器注入服务\r\n	服务是一个对象实例，作为庞大系统的一部分,比如数据连接、缓存中间件、模板引擎、邮件等都可以成为一项服务。\r\n	Pimple中通过匿名函数返回实例对象的方式来注册服务，如下代码:\r\n\r\n	```php\r\n	$container[\'test\'] = function() {\r\n		return new StdClass;\r\n	};\r\n\r\n	class Cache {\r\n	}\r\n\r\n	$container[\'cache\'] = function() {\r\n		return new Cache;\r\n	};\r\n	```\r\n	请注意，匿名函数中可以访问当前容器实例，允许引用其他服务作为参数，由于只有在获取对象时才创建对象，因此定义的顺序并不重要。例子代码如下:\r\n\r\n	```php\r\n	class Cache {\r\n		private $test;\r\n		public function __construct($test) {\r\n			$this->test = $test;\r\n		}\r\n	}\r\n	//使用container容器作为参数，获取容器中的test服务传递给Cache类的构造函数\r\n	$container[\'cache\'] = function($container) {\r\n		return new Cache($container[\'test\']);\r\n	};\r\n	$container[\'test\'] = function() {\r\n		return new StdClass;\r\n	};\r\n	```\r\n- 获取服务\r\n获取服务很简单，如下\r\n\r\n	```php\r\n	//获取cache实例对象\r\n	$cache = $container[\'cache\'];\r\n```\r\n- 工厂服务\r\n默认情况下，Pimple获取相同服务时，返回的是同一个实例，也就是实现的单例模式。演示代码如下:\r\n\r\n	```php\r\n	class Cache {\r\n		public function __construct() {\r\n			echo \'实例化了一次\';\r\n		}\r\n	}\r\n\r\n	$container[\'cache\'] = function() {\r\n		return new Cache();\r\n	};\r\n\r\n	$container[\'cache\'];\r\n	$container[\'cache\'];\r\n	$container[\'cache\'];\r\n	```\r\n	界面输出\r\n\r\n	```shell\r\n	实例化了一次\r\n	```\r\n	证明只实例化了一次，也就是同一个实例。如果想每次获取服务返回不同的实例，则需要使用factory方法包装匿名函数,代码如下:\r\n\r\n	```php\r\n	class Cache {\r\n		public function __construct() {\r\n			echo \'实例化了一次\';\r\n		}\r\n	}\r\n\r\n	$container[\'cache\'] = $container->factory(function() {\r\n	  return new Cache;  \r\n	});\r\n\r\n	$container[\'cache\'];\r\n	$container[\'cache\'];\r\n	$container[\'cache\'];\r\n	```\r\n	界面输出\r\n\r\n	```shell\r\n	实例化了一次实例化了一次实例化了一次\r\n	```\r\n	证明实例化了3次，是不同的实例\r\n\r\n- 容器注入非对象简单数据\r\n\r\n	```php\r\n	$container[\'dbname\'] = \'demo\';\r\n	$container[\'app_name\'] = \'Json\';\r\n	```\r\n\r\n- 修改已经注入容器的服务\r\n修改已经注入容器的服务，可以使用extend方法\r\n\r\n	```php\r\n	class Cache {\r\n		public function __construct() {\r\n			echo \'实例化了一次\';\r\n		}\r\n	}\r\n\r\n	$container[\'cache\'] = function() {\r\n	  return new Cache;  \r\n	};\r\n\r\n	$container->extend(\'cache\',function($cache,$container){\r\n		$cache->name = \'Json\';\r\n		return $cache;\r\n	});\r\n	```\r\n	extend方法的第一个参数是注入容器的服务名称，第二个参数是一个匿名函数，匿名函数第一个参数是当前服务实例，匿名函数第二个参数是容器实例，注意匿名函数需要返回修改后的实例\r\n\r\n- 服务提供者\r\n使用过laravel开源框架的应该都知道服务提供者是什么，怎么用，Pimple跟laravel的使用方式类似,但是需要实现Pimple\\ServiceProviderInterface接口\r\n\r\n	```php\r\n	class CacheProvider implements Pimple\\ServiceProviderInterface {\r\n\r\n		public function register(Container $container) {\r\n			$container[\'cache\'] = function() {\r\n				return new Cache;\r\n			};\r\n		}\r\n	}\r\n\r\n	class Cache {\r\n		public function __construct() {\r\n			echo \'实例化了一次\';\r\n		}\r\n	}\r\n	$container->register(new CacheProvider);\r\n	```',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,1103,0),(51,'11.jpg','11-jpg',1595338133,1595338133,'a:5:{s:4:\"name\";s:6:\"11.jpg\";s:4:\"path\";s:35:\"/usr/uploads/2020/07/2050173822.jpg\";s:4:\"size\";i:47827;s:4:\"type\";s:3:\"jpg\";s:4:\"mime\";s:10:\"image/jpeg\";}',1,2,NULL,'attachment','publish',NULL,0,'1','0','1',52,0,0),(52,'php开发调试利器只whoops库','52',1595339880,1595339933,'<!--markdown-->### 介绍\r\n![11.jpg](http://www.fxjson.com/usr/uploads/2020/07/2050173822.jpg)\r\n\r\n使用过laravel框架的同学对这个友好的错误提示页面应该不陌生，其实这个也是有开源库的，laravel正是集成了这个库，这个库名字叫whoops,你可以在github上面很轻松的搜索到它。\r\n\r\n### 安装\r\n\r\n```shell\r\ncomposer require filp/whoops\r\n```\r\n\r\n### demo代码\r\n\r\n```php\r\n<?php\r\n\r\nrequire_once(__DIR__ . \'/vendor/autoload.php\');\r\n\r\nuse Whoops\\Run;\r\nuse Whoops\\Handler\\PrettyPageHandler;\r\n\r\n$whoops = new Run;\r\n$whoops->pushHandler(new PrettyPageHandler);  \r\n$whoops->register();\r\n\r\nrequire_once \'./demo.php\';\r\n\r\n```\r\n其中demo.php文件演示代码比较简单，只有一行\r\n\r\n```php\r\n<?php\r\narray()+33;\r\n```\r\n\r\n### 其它\r\n\r\n使用就这么简单，如果你想定制化输出内容，或者添加更多信息，可以参考[github](https://github.com/filp/whoops),我这只是抛转引玉，还是那句:想学的人总能找到资源\r\n\r\n',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,773,0),(53,'设计模式之适配器模式','53',1595395049,1595395049,'<!--markdown-->适配器模式，顾名思义，就是把原本不兼容的接口，通过适配，使之兼容。无需修改原有代码，只需要添加适配器类去适配接口即可。\r\n\r\n举例来说，比如现在有个消息类、有个发送邮件的类，消息类跟邮件类有不同的方法，现在想实现像发送邮件一样的方式发送消息，那怎么办，就有了适配器模式，通过适配邮件实现的方法，来发送短信。\r\n\r\n### 分类\r\n适配器模式一般分为三类：\r\n- 类适配器模式\r\n- 对象适配器模式\r\n- 接口适配器模式\r\n### 具体实现\r\n- 类适配器模式\r\n一句话就是用一个类去适配其它类或者接口，如下代码：\r\n\r\n```php\r\n<?php\r\n\r\ninterface Message {\r\n\r\n    public function sendText();\r\n\r\n    public function sendAttachment();\r\n\r\n}\r\n\r\nclass  Email implements Message {\r\n\r\n    public function sendText() {\r\n        echo \"发送邮件\";\r\n    }\r\n\r\n    public function sendAttachment() {\r\n        echo \'发送附件邮件\';\r\n    }\r\n}\r\n\r\nclass Sms {\r\n\r\n    public function send() {\r\n        echo \'发送文本消息\';\r\n    }\r\n}\r\n```\r\n现在希望发短信也像邮件一样，调用obj->sendText或者obj->sendAttachment即可发送短信,注意Sms类只有send方法，适配器模式代码如下:\r\n\r\n```php\r\nclass SmsAdapter extends Sms implements Message {\r\n\r\n    public function sendText() {\r\n        $this->send();\r\n    }\r\n\r\n    public function sendAttachment() {\r\n\r\n    }\r\n}\r\n```\r\n就这么简单，这就是一个实现了类适配器模式的代码，需要注意的是继承Sms类并且实现了Message接口，测试代码如下:\r\n\r\n```php\r\n$adapter = new SmsAdapter();\r\n$adapter->sendText();\r\n```\r\n\r\n- 对象适配器模式\r\n让一个已知的对象去适配其它类或者接口\r\n如上面的代码我们有一个Sms类的实例$sms,适配器全部代码如下\r\n\r\n```php\r\n\r\n<?php\r\n\r\ninterface Message {\r\n\r\n    public function sendText();\r\n\r\n    public function sendAttachment();\r\n\r\n}\r\n\r\nclass  Email implements Message {\r\n\r\n    public function sendText() {\r\n        echo \"发送邮件\";\r\n    }\r\n\r\n    public function sendAttachment() {\r\n        echo \'发送附件邮件\';\r\n    }\r\n}\r\n\r\nclass Sms {\r\n\r\n    public function send() {\r\n        echo \'发送文本消息\';\r\n    }\r\n}\r\n\r\n\r\nclass SmsAdapter implements Message {\r\n\r\n    private $sms;\r\n\r\n    public function __construct($sms) {\r\n        $this->sms = $sms;\r\n    }\r\n\r\n    public function sendText() {\r\n        $this->sms->send();\r\n    }\r\n\r\n    public function sendAttachment() {\r\n\r\n    }\r\n}\r\n```\r\n\r\n测试使用代码如下:\r\n\r\n```php\r\n$sms = new Sms();//模拟已知的对象\r\n$adapter = new SmsAdapter($sms);\r\n\r\n$adapter->sendText();\r\n```\r\n\r\n- 接口适配器模式\r\n接口适配器模式常用在接口有很多方法，但是需要实现的或者说业务只关心的是一部分方法，而不需要全部实现。\r\n\r\n```php\r\n<?php\r\n\r\ninterface Message {\r\n\r\n    public function sendText();\r\n\r\n    public function sendAttachment();\r\n\r\n}\r\n\r\nclass  Email implements Message {\r\n\r\n    public function sendText() {\r\n        echo \"发送邮件\";\r\n    }\r\n\r\n    public function sendAttachment() {\r\n        echo \'发送附件邮件\';\r\n    }\r\n}\r\n\r\nclass Sms {\r\n\r\n    public function send() {\r\n        echo \'发送文本消息\';\r\n    }\r\n}\r\n\r\n//空实现Message接口的所有方法\r\nclass DefaultAdapter implements Message {\r\n\r\n    public function sendText() {\r\n\r\n    }\r\n\r\n    public function sendAttachment() {\r\n\r\n    }\r\n}\r\n\r\nclass SmsAdapter extends DefaultAdapter {\r\n\r\n    private $sms;\r\n\r\n    public function __construct($sms) {\r\n        $this->sms = $sms;\r\n    }\r\n\r\n    public function sendText() {\r\n        $this->sms->send();\r\n    }\r\n}\r\n\r\n$sms = new Sms();//模拟已知的对象\r\n$adapter = new SmsAdapter($sms);\r\n\r\n$adapter->sendText();\r\n```\r\n接口适配器模式利用一个空实现了接口所有方法的适配器，然后结合对象适配器模式，在对象适配器中实现具体关心的方法。\r\n\r\n### 优点\r\n- 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。\r\n- 增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。\r\n- 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。\r\n\r\n### 总结\r\n- 类适配器模式，继承源类，实现目标接口。\r\n- 对象适配器模式，持有源类的对象，把继承关系改变为组合关系。\r\n- 接口适配器模式，借助中间类空实现目标接口所有方法，适配器选择性重写。\r\n\r\n\r\n',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,645,0),(54,'设计模式之策略模式','54',1595481831,1595481831,'<!--markdown-->### 定义\r\n策略模式定义了一系列的算法，并将每一个算法封装起来，使每个算法可以相互替代。注意是可以**互相替代**\r\n\r\n举个例子，我们每天上班，可以步行上班，可以坐公交上班，可以打车上班，也可以自己开车上班，但是因为环境的不同我们会选择不同的出行方式，公司就在家门口我们可能选择步行，没在家门口上班快要迟到了我们可能打车，每一个出行方式都能实现我们的目的，但是可能环境的变化我们会选择不同的方式。策略模式也是如此，可以根据动态变化选择不同的策略，但是每一个策略最终都会实现我们的目的，只是可能不是最优策略而已。\r\n\r\n### 代码实例\r\n\r\n```php\r\n<?php\r\n\r\ninterface WorkStrategy {\r\n    public function handle();\r\n}\r\n\r\nclass WalkStrategy implements WorkStrategy {\r\n\r\n    public function handle() {\r\n        echo \'我步行去上班了，已经到公司\';\r\n    }\r\n}\r\n\r\nclass BicycleStrategy implements WorkStrategy {\r\n\r\n    public function handle() {\r\n        echo \'我骑车去上班了\';\r\n    }\r\n}\r\n\r\nclass DriveStrategy implements WorkStrategy {\r\n\r\n    public function handle() {\r\n        echo \'快要迟到了，我开车去上班了\';\r\n    }\r\n}\r\n\r\nclass Person {\r\n\r\n    private $workStrategy;\r\n\r\n    public function __construct(WorkStrategy $workStrategy) {\r\n        $this->workStrategy = $workStrategy;\r\n    }\r\n\r\n    //出行方式\r\n    public function travelMethod() {\r\n        $this->workStrategy->handle();\r\n    }\r\n}\r\n```\r\n模拟根据路途不同选择不同的策略:\r\n\r\n```php\r\n$miles = 12000;\r\nif($miles<2000) {//短途，步行\r\n    $strategy = new WalkStrategy;\r\n} else {//骑车\r\n    $strategy = new BicycleStrategy;\r\n}\r\n\r\n$person = new Person($strategy);\r\n\r\n$person->travelMethod();\r\n```\r\n\r\n### 优点\r\n- 算法可以自由切换\r\n- 扩展性良好，增加一个策略只需实现接口即可\r\n- 避免使用多重条件判断（如果不用策略模式我们可能会使用多重条件语句，不利于维护）\r\n',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,623,0),(55,'php对象的链式调用','55',1595568660,1595568733,'<!--markdown-->链式调用给使用者非常好的体验,很多优秀的框架中都有提供这样的接口,使用过Laravel框架的应该都使用过类似下面的代码：\r\n\r\n```php\r\nDB::table(\'lgt_good\')->select([\'lgid\'],\'name\')->where(\'lgid>44\')->get()->toArray();\r\n```\r\n\r\n其实这个很简单，借助$this关键字返回实例对象，我们写个demo代码如下:\r\n\r\n```php\r\n<?php\r\n\r\nclass Db {\r\n    \r\n    private static $_instance = null;\r\n    private $_where = array();\r\n    private $_fields = null;\r\n    private $_table = null;\r\n    \r\n    private function __construct(){}\r\n    \r\n    private function __clone(){}\r\n    \r\n    //单例模式\r\n    public static function getInstance() {\r\n        if (!self::$_instance instanceof self) {\r\n            self::$_instance = new self();\r\n        }\r\n        return self::$_instance;\r\n    }\r\n    \r\n    public function table($table) {\r\n        $this->_table = $table;\r\n        return $this;\r\n    }\r\n    \r\n    public function where($where) {\r\n        $this->_where = $where;\r\n        return $this;\r\n    }\r\n    \r\n    public function fields($fields) {\r\n        $this->_fields = $fields;\r\n        return $this;\r\n    }\r\n    \r\n    public function getAll() {\r\n        $sql = \'SELECT \';\r\n        if(is_array($this->_fields)) {\r\n            $sql .= implode(\',\',$this->_fields);\r\n        } else {\r\n            $sql .= $this->_fields;\r\n        }\r\n        $sql .= \' FROM \'.$this->_table;\r\n        $sql .= \' WHERE \'.$this->_where;\r\n        return $sql;\r\n    }\r\n}\r\n```\r\n结合单例模式，进行类的实例化,使用方式如下:\r\n```php\r\nDb::getInstance()\r\n    ->table(\'users\')\r\n    ->fields([\'id\',\'username\',\'create_time\'])\r\n    ->where(\"age>23 and salary>4000\")\r\n    ->getAll();\r\n```',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,628,0),(56,'宝石之数据库迁移工具Phinx','56',1595602380,1596250405,'<!--markdown-->### 介绍\r\n\r\n使用过Laravel框架的同学应该都用过 php artisan migrate命令，这个命令是进行数据库迁移的，个人特别喜欢，通过翻阅各种资料，发现了Phinx这个红宝石，可以在自己的项目中直接使用的数据库迁移工具。Phinx是一个数据库迁移工具，用数据库迁移工具的优点，个人总结如下\r\n\r\n- 避免了手写sql语句\r\n- 支持多种数据库系统之间的迁移\r\n- 引入版本了概念，已经执行过的会自动跳过\r\n- 可以进行回滚\r\n\r\n### Phinx环境要求\r\n\r\nPHP 7.2+\r\n\r\n### 安装\r\n\r\n```shell\r\ncomposer require robmorgan/phinx\r\n```\r\n\r\n### 配置\r\n\r\n- 项目根目录执行命令,生成配置文件phinx.php,进行数据库的配置\r\n\r\n  ```php\r\n   ./vendor/bin/phinx init\r\n  ```\r\n\r\n  phinx.php文件代码如下\r\n\r\n  ```php\r\n  <?php\r\n  \r\n  return\r\n  [\r\n      \'paths\' => [\r\n          \'migrations\' => \'%%PHINX_CONFIG_DIR%%/db/migrations\',\r\n          \'seeds\' => \'%%PHINX_CONFIG_DIR%%/db/seeds\'\r\n      ],\r\n      \'environments\' => [\r\n          \'default_migration_table\' => \'phinxlog\',\r\n          \'default_environment\' => \'development\',//默认环境\r\n          \'production\' => [//生产环境数据库配置\r\n              \'adapter\' => \'mysql\',\r\n              \'host\' => \'localhost\',\r\n              \'name\' => \'production_db\',\r\n              \'user\' => \'root\',\r\n              \'pass\' => \'\',\r\n              \'port\' => \'3306\',\r\n              \'charset\' => \'utf8\',\r\n          ],\r\n          \'development\' => [//开发环境数据库配置\r\n              \'adapter\' => \'mysql\',\r\n              \'host\' => \'localhost\',\r\n              \'name\' => \'development_db\',\r\n              \'user\' => \'root\',\r\n              \'pass\' => \'\',\r\n              \'port\' => \'3306\',\r\n              \'charset\' => \'utf8\',\r\n          ],\r\n          \'testing\' => [//测试环境数据库配置\r\n              \'adapter\' => \'mysql\',\r\n              \'host\' => \'localhost\',\r\n              \'name\' => \'testing_db\',\r\n              \'user\' => \'root\',\r\n              \'pass\' => \'\',\r\n              \'port\' => \'3306\',\r\n              \'charset\' => \'utf8\',\r\n          ]\r\n      ],\r\n      \'version_order\' => \'creation\'\r\n  ];\r\n  \r\n  ```\r\n\r\n  \r\n\r\n- 创建目录db/migrations\r\n\r\n  生成的迁移文件将会存储到这个目录，所以目录权限要可读可写\r\n\r\n### 迁移\r\n\r\n#### 创建迁移\r\n\r\n- 生成文件\r\n\r\n  使用create命令创建迁移文件\r\n\r\n  ```\r\n  ./vendor/bin/phinx create AddTableLgtGood\r\n  ```\r\n\r\n  **注意:**迁移文件名需要是驼峰格式,生成的文件格式是`YYYYMMDDHHMMSS_add_table_lgt_good.php`，前面14个日期格式的时间戳+驼峰文件名转成长蛇格式,生成的文件代码如下:\r\n\r\n  ```php\r\n  <?php\r\n  declare(strict_types=1);\r\n  \r\n  use Phinx\\Migration\\AbstractMigration;\r\n  \r\n  final class AddTableLgtGood extends AbstractMigration\r\n  {\r\n      /**\r\n       * Change Method.\r\n       *\r\n       * Write your reversible migrations using this method.\r\n       *\r\n       * More information on writing migrations is available here:\r\n       * https://book.cakephp.org/phinx/0/en/migrations.html#the-change-method\r\n       *\r\n       * Remember to call \"create()\" or \"update()\" and NOT \"save()\" when working\r\n       * with the Table class.\r\n       */\r\n      public function change(): void\r\n      {\r\n  \r\n      }\r\n  }\r\n  ```\r\n\r\n- change方法\r\n\r\n  ```php\r\n  <?php\r\n  declare(strict_types=1);\r\n  \r\n  use Phinx\\Migration\\AbstractMigration;\r\n  \r\n  final class AddTableLgtGood extends AbstractMigration\r\n  {\r\n      public function change(): void\r\n      {\r\n          $this->table(\'lgt_good\')\r\n              ->addColumn(\'lgid\',\'integer\')\r\n              ->addColumn(\'name\',\'string\')\r\n              ->addColumn(\'ctime\',\'datetime\')\r\n              ->create();\r\n      }\r\n  }\r\n  ```\r\n\r\n  Phinx将自动创建lgt_good表，**注意**如果change方法存在，会忽略存在的up()、down()方法;change方法会自动识别怎么回滚表，使用change方法的前提是使用table的create()、update()方法，下面的这些操作change方法会自动识别如何回滚。\r\n\r\n  - 创建表\r\n  - 重命名表\r\n  - 添加列\r\n  - 重命名列\r\n  - 添加索引\r\n  - 添加外键\r\n\r\n  如果在change()方法中使用不能回滚的操作时，回滚时将触发IrreversibleMigrationException异常，所以在change()方法中为了防止出现异常报错，可以使用$this->isMigratingUp()方法\r\n\r\n  ```php\r\n  <?php\r\n  declare(strict_types=1);\r\n  \r\n  use Phinx\\Migration\\AbstractMigration;\r\n  \r\n  final class AddTableLgtGood extends AbstractMigration\r\n  {\r\n      public function change(): void\r\n      {\r\n          $table = $this->table(\'lgt_good\');\r\n          $table->addColumn(\'lgid\',\'integer\')\r\n              ->addColumn(\'name\',\'string\')\r\n              ->addColumn(\'ctime\',\'datetime\')\r\n              ->create();\r\n         if($this->isMigratingUp()) {\r\n             $this->table(\'tbl_users\')->insert([[\'name\'=>\'hello\']])->save();\r\n         }\r\n      }\r\n  }\r\n  ```\r\n\r\n- up()方法\r\n\r\n  当执行migrate命令时，会自动检测没有执行的文件并执行up()方法，up()方法里面定义数据库的升级\r\n\r\n- down()方法\r\n\r\n  当执行rollback命令时，会自动检测之前执行的文件的down()方法，down()方法里面定义数据库升级的逆操作。\r\n\r\n- init()方法\r\n\r\n  执行migrate或者rollback迁移时，在之前up()或者down()方法之前都会执行的方法，常用来初始公共属性，方便up()或者down()方法里面使用\r\n\r\n#### 执行sql\r\n\r\nexecute()方法返回受影响的行数，query()方法返回PDOStatement对象\r\n\r\n```php\r\n<?php\r\ndeclare(strict_types=1);\r\n\r\nuse Phinx\\Migration\\AbstractMigration;\r\n\r\nfinal class AddTableLgtGood extends AbstractMigration\r\n{\r\n    public function up(): void\r\n    {\r\n        // execute()\r\n        $count = $this->execute(\'UPDATE lgt_good set name=\"hello\"\'); // returns the number of affected rows\r\n        var_dump($count);\r\n        // query()\r\n        $stmt = $this->query(\'SELECT * FROM lgt_good\'); // returns PDOStatement\r\n        $rows = $stmt->fetchAll(); // returns the result as an array\r\n        print_r($rows);\r\n    }\r\n}\r\n```\r\n\r\n#### 查询行\r\n\r\nfetchRow()返回单行数据\r\n\r\nfetchAll()返回多行数据\r\n\r\n```php\r\n<?php\r\ndeclare(strict_types=1);\r\n\r\nuse Phinx\\Migration\\AbstractMigration;\r\n\r\nfinal class AddTableLgtGood extends AbstractMigration\r\n{\r\n    public function up(): void\r\n    {\r\n        // execute()\r\n        $row = $this->fetchRow(\'SELECT * FROM lgt_good\'); // returns array\r\n        var_dump($row);\r\n        // query()\r\n        $list = $this->fetchAll(\'SELECT * FROM lgt_good\'); // returns array list\r\n        print_r($list);\r\n    }\r\n\r\n    public function down():void {\r\n        \r\n    }\r\n}\r\n```\r\n\r\n#### 写入数据\r\n\r\n使用insert()进行写入数据\r\n\r\n```php\r\n<?php\r\ndeclare(strict_types=1);\r\n\r\nuse Phinx\\Migration\\AbstractMigration;\r\n\r\nfinal class AddTableLgtGood extends AbstractMigration\r\n{\r\n    public function up(): void\r\n    {\r\n        // inserting only one row\r\n        $singleRow = [\r\n            \'lgid\'  => 1,\r\n            \'name\'  => \'货品1\',\r\n            \'ctime\' =>  date(\'Y-m-d H:i:s\')\r\n        ];\r\n\r\n        $table = $this->table(\'lgt_good\');\r\n        $table->insert($singleRow);\r\n        $table->saveData();\r\n\r\n        // inserting multiple rows\r\n        $rows = [\r\n            [\r\n                \'lgid\'  => 22,\r\n                \'name\'  => \'货品22\',\r\n                \'ctime\' =>  date(\'Y-m-d H:i:s\')\r\n            ],\r\n            [\r\n                \'lgid\'  => 33,\r\n                \'name\'  => \'货品33\',\r\n                \'ctime\' =>  date(\'Y-m-d H:i:s\')\r\n            ]\r\n        ];\r\n\r\n        $table->insert($rows)->save();\r\n    }\r\n\r\n    public function down():void {\r\n        $this->execute(\"DELETE FROM lgt_good\");\r\n    }\r\n}\r\n```\r\n\r\n**注意:**不要在cange()方法中使用insert进行数据写入,请使用up()、down()进行数据的写入\r\n\r\n#### 操作表\r\n\r\n- table()方法获取表对象\r\n\r\n  ```php\r\n  $this->table(\"lgt_good\");\r\n  ```\r\n\r\n- 保存表对象的变化\r\n\r\n  - create()方法先创建表然后执行修改的变化\r\n  - update()方法只执行修改，常用在表已经存在，然后对表进行操作的场景\r\n  - save()方法智能的检测，如果表不存在自动执行create()方法，如果表存在则执行save方法\r\n\r\n  **注意:**change()方法中只能用create()、update()方法，不能用save()方法，就是因为save()方法智能检测存在则会执行update()方法，不存在则执行create()方法\r\n\r\n- 创建表\r\n\r\n  ```php\r\n  <?php\r\n  declare(strict_types=1);\r\n  \r\n  use Phinx\\Migration\\AbstractMigration;\r\n  \r\n  final class AddTableLgtGood extends AbstractMigration\r\n  {\r\n     public function change():void {\r\n         $table = $this->table(\'lgt_good\');\r\n         $table->addColumn(\'name\',\'string\',[\'length\'=>30,\'null\'=>false])\r\n             ->addColumn(\'status\',\'integer\',[\'limit\'=>11,\'default\'=>0,\'null\'=>false])\r\n             ->addIndex(\'name\')\r\n             ->create();\r\n     }\r\n  }\r\n  ```\r\n\r\n  addColumn()用来添加列，addIndex()用来添加索引，注意系统自动创建了一个列名为id的主键。\r\n\r\n  最终创建的表是:\r\n\r\n  ```sql\r\n  CREATE TABLE `lgt_good` (\r\n    `id` int(11) NOT NULL AUTO_INCREMENT,\r\n    `name` varchar(30) NOT NULL,\r\n    `status` int(11) NOT NULL DEFAULT \'0\',\r\n    PRIMARY KEY (`id`),\r\n    KEY `name` (`name`)\r\n  ) ENGINE=InnoDB DEFAULT CHARSET=utf8\r\n  ```\r\n\r\n  如果我们想修改主键列名，则可以使用primary_key属性，同时id字段值改为false\r\n\r\n  ```php\r\n  <?php\r\n  declare(strict_types=1);\r\n  \r\n  use Phinx\\Migration\\AbstractMigration;\r\n  \r\n  final class AddTableLgtGood extends AbstractMigration\r\n  {\r\n     public function change():void {\r\n         $table = $this->table(\'lgt_good\',[\'id\'=>false,\'primary_key\'=>[\'lgid\']]);//更改主键列为lgid\r\n         $table->addColumn(\'lgid\',\'integer\',[\'length\'=>11])\r\n             ->addColumn(\'name\',\'string\',[\'length\'=>30,\'null\'=>false])\r\n             ->addColumn(\'status\',\'integer\',[\'limit\'=>11,\'default\'=>0,\'null\'=>false])\r\n             ->addIndex(\'name\')\r\n             ->create();\r\n     }\r\n  }\r\n  ```\r\n\r\n  生成的表为:\r\n\r\n  ```sql\r\n  CREATE TABLE `lgt_good` (\r\n    `lgid` int(11) NOT NULL,\r\n    `name` varchar(30) NOT NULL,\r\n    `status` int(11) NOT NULL DEFAULT \'0\',\r\n    PRIMARY KEY (`lgid`),\r\n    KEY `name` (`name`)\r\n  ) ENGINE=InnoDB DEFAULT CHARSET=utf8\r\n  ```\r\n\r\n  我们可以发现设置primary_key属性的方式生成的主键不是自增的，所以最简单的修改方式如下:\r\n\r\n  ```php\r\n  <?php\r\n  declare(strict_types=1);\r\n  \r\n  use Phinx\\Migration\\AbstractMigration;\r\n  \r\n  final class AddTableLgtGood extends AbstractMigration\r\n  {\r\n     public function change():void {\r\n         $table = $this->table(\'lgt_good\',[\'id\'=>\'lgid\']);\r\n         $table->addColumn(\'name\',\'string\',[\'length\'=>30,\'null\'=>false])\r\n             ->addColumn(\'status\',\'integer\',[\'limit\'=>11,\'default\'=>0,\'null\'=>false])\r\n             ->addIndex(\'name\')\r\n             ->addColumn(\'created\', \'timestamp\', [\'default\' => \'CURRENT_TIMESTAMP\'])\r\n             ->create();\r\n     }\r\n  }\r\n  ```\r\n\r\n  生成的表如下:\r\n\r\n  ```sql\r\n  CREATE TABLE `lgt_good` (\r\n    `lgid` int(11) NOT NULL AUTO_INCREMENT,\r\n    `name` varchar(30) NOT NULL,\r\n    `status` int(11) NOT NULL DEFAULT \'0\',\r\n    `created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\r\n    PRIMARY KEY (`lgid`),\r\n    KEY `name` (`name`)\r\n  ) ENGINE=InnoDB DEFAULT CHARSET=utf8\r\n  ```\r\n\r\n  lgid字段主键自增了，**注意:**lgid字段不需要addColumn()方法添加了。\r\n\r\n  mysql的表创建还支持以下属性:\r\n\r\n  - engine 存储引擎,默认*InnoDB*\r\n  - comment 表的备注\r\n  - signed 表主键是否是signed，默认true\r\n\r\n  ```php\r\n  <?php\r\n  declare(strict_types=1);\r\n  \r\n  use Phinx\\Migration\\AbstractMigration;\r\n  \r\n  final class AddTableLgtGood extends AbstractMigration\r\n  {\r\n     public function change():void {\r\n         $table = $this->table(\'lgt_good\',[\'id\'=>\'lgid\',\'comment\'=>\'货品表\']);\r\n         $table->addColumn(\'name\',\'string\',[\'length\'=>30,\'null\'=>false])\r\n             ->addColumn(\'status\',\'integer\',[\'limit\'=>11,\'default\'=>0,\'null\'=>false])\r\n             ->addIndex(\'name\')\r\n             ->addColumn(\'created\', \'timestamp\', [\'default\' => \'CURRENT_TIMESTAMP\'])\r\n             ->create();\r\n     }\r\n  }\r\n  ```\r\n\r\n- 支持的有效列类型\r\n  - biginteger\r\n  - binary\r\n  - boolean\r\n  - date\r\n  - datetime\r\n  - decimal\r\n  - float\r\n  - double\r\n  - integer\r\n  - smallinteger\r\n  - string\r\n  - text\r\n  - time\r\n  - timestamp\r\n  - uuid\r\n\r\n- 检查表是否存在\r\n\r\n  使用$this->hasTable(\'表名\')方法检查表是否存在\r\n\r\n  ```php\r\n  <?php\r\n  declare(strict_types=1);\r\n  \r\n  use Phinx\\Migration\\AbstractMigration;\r\n  \r\n  final class AddTableLgtGood extends AbstractMigration\r\n  {\r\n     public function change():void {\r\n         if(!$this->hasTable(\'lgt_good\')){\r\n             $table = $this->table(\'lgt_good\',[\'id\'=>\'lgid\',\'comment\'=>\'货品表\']);\r\n             $table->addColumn(\'name\',\'string\',[\'length\'=>30,\'null\'=>false])\r\n                 ->addColumn(\'status\',\'integer\',[\'limit\'=>11,\'default\'=>0,\'null\'=>false])\r\n                 ->addIndex(\'name\')\r\n                 ->addColumn(\'created\', \'timestamp\', [\'default\' => \'CURRENT_TIMESTAMP\'])\r\n                 ->create();\r\n         }\r\n     }\r\n  }\r\n  ```\r\n\r\n- 删除表\r\n\r\n  使用drop()方法删除表，drop()方法后通常跟一个save()方法，以保证涉及多个表时phinx智能的进行迁移\r\n\r\n  ```php\r\n  $this->table(\'lt_good\')->drop()->save();\r\n  ```\r\n\r\n- 重命名表\r\n\r\n  ```php\r\n  $this->table(\'lgt_good\')->rename(\'lgt_goods\')->update();\r\n  ```\r\n\r\n- 修改表备注\r\n\r\n  ```php\r\n  $this->table(\'lgt_good\')->changeComment(\"货品档案表\");\r\n  ```\r\n\r\n\r\n#### 操作列\r\n\r\n\r\n\r\n- 列可选项\r\n\r\n  - 通用可选项\r\n\r\n  	- limit 字符串或者整数长度\r\n	\r\n	- length limit的别名\r\n	- default 默认值                            \r\n	- null   是否允许为空，默认false  \r\n	- after   列放到哪个列后面，目前仅支持MySQL\r\n	- comment 列备注 \r\n\r\n  - decimal类型选项\r\n    - precision decimal(M,N)中的M\r\n	\r\n   - scale decimal(M,N)中的N                   \r\n   - signed 是否有符号，false无符号，true有符号，仅支持MySQL\r\n   \r\n  - enum类型选项\r\n    - values 可以是逗号隔开的字符串或者是数组 \r\n  - integer、biginteger类型选项\r\n\r\n    - identity 是否自增，true或者false\r\n    - signed  是否有符号，仅支持MySQL\r\n\r\n  - timestamp类型选项\r\n\r\n    - default 默认值，可以使用`CURRENT_TIMESTAMP`\r\n	- update 当行更新是触发变更，值是`CURRENT_TIMESTAMP`，仅支持MySQL\r\n\r\n    Phinx提供了快速创建create_at、update_at字段的方法\r\n\r\n    ```php\r\n    $this->table(\'lgt_good\')->addTimestamps();//自动创建timestamp类型的create_at、update_at字段\r\n    \r\n    $this->table(\'lgt_good\')->addTimestamps(\'ctime\',\'utime\');//create_at列名改成ctime、update_at列改成utime\r\n    ```\r\n\r\n  - boolean类型选项\r\n   - signed 是否有符号，仅支持MySQL\r\n\r\n    ```php\r\n    <?php\r\n    declare(strict_types=1);\r\n    \r\n    use Phinx\\Migration\\AbstractMigration;\r\n    \r\n    final class AddTableLgtGood extends AbstractMigration\r\n    {\r\n       public function change():void {\r\n           $table = $this->table(\'lgt_good\',[\'id\'=>\'lgid\',\'comment\'=>\'货品表\']);\r\n           $table->addColumn(\'name\',\'string\',[\'length\'=>30,\'null\'=>false])\r\n               ->addIndex(\'name\')\r\n               ->addColumn(\'rate\',\'decimal\',[\'precision\'=>5,\'scale\'=>2,\'signed\'=>false])\r\n               ->addColumn(\'created\', \'timestamp\', [\'default\' => \'CURRENT_TIMESTAMP\'])\r\n               ->addTimestamps(\'ctime\',null)\r\n               ->addColumn(\'status\',\'boolean\')\r\n               ->create();\r\n       }\r\n    }\r\n    ```\r\n\r\n    实际创建的是一个tinyint类型\r\n\r\n  - 外键选项\r\n \r\n   - update 设置更新行时触发的事件\r\n   - delete 设置删除行时触发的事件\r\n\r\n- getColumns()方法获取表所有列元数据\r\n\r\n  ```php\r\n  <?php\r\n  declare(strict_types=1);\r\n  \r\n  use Phinx\\Migration\\AbstractMigration;\r\n  \r\n  final class AddTableLgtGood extends AbstractMigration\r\n  {\r\n     public function up():void {\r\n         $columns = $this->table(\'lgt_good\')->getColumns();\r\n         print_r($columns);\r\n     }\r\n  \r\n     public function down():void {\r\n  \r\n     }\r\n  }\r\n  \r\n  ```\r\n\r\n- getColumn()获取表某一列元数据信息\r\n\r\n  ```php\r\n  <?php\r\n  declare(strict_types=1);\r\n  \r\n  use Phinx\\Migration\\AbstractMigration;\r\n  \r\n  final class AddTableLgtGood extends AbstractMigration\r\n  {\r\n     public function up():void {\r\n         $column = $this->table(\'lgt_good\')->getColumn(\'status\');\r\n         print_r($column);\r\n     }\r\n  \r\n     public function down():void {\r\n  \r\n     }\r\n  }\r\n  ```\r\n\r\n- hasColumn()检测列是否存在\r\n\r\n  ```php\r\n  <?php\r\n  declare(strict_types=1);\r\n  \r\n  use Phinx\\Migration\\AbstractMigration;\r\n  \r\n  final class AddTableLgtGood extends AbstractMigration\r\n  {\r\n     public function up():void {\r\n         $ret = $this->table(\'lgt_good\')->hasColumn(\'status\');\r\n         print_r($ret);\r\n     }\r\n  \r\n     public function down():void {\r\n  \r\n     }\r\n  }\r\n  ```\r\n\r\n- renameColumn()重命名列名\r\n\r\n  ```php\r\n  <?php\r\n  declare(strict_types=1);\r\n  \r\n  use Phinx\\Migration\\AbstractMigration;\r\n  \r\n  final class AlterLgtGood extends AbstractMigration\r\n  {\r\n     public function up():void {\r\n         $table = $this->table(\'lgt_good\');\r\n         $table->renameColumn(\'status\',\'lstatus\')->update();\r\n     }\r\n  \r\n     public function down():void {\r\n         $table = $this->table(\'lgt_good\');\r\n         $table->renameColumn(\'lstatus\',\'status\')->update();\r\n     }\r\n  }\r\n  ```\r\n\r\n- removeColumn()删除列\r\n\r\n  ```php\r\n  <?php\r\n  declare(strict_types=1);\r\n  \r\n  use Phinx\\Migration\\AbstractMigration;\r\n  \r\n  final class AlterLgtGood extends AbstractMigration\r\n  {\r\n     public function up():void {\r\n         $table = $this->table(\'lgt_good\');\r\n         $table->removeColumn(\'status\')\r\n             ->update();\r\n     }\r\n  \r\n     public function down():void {\r\n         $table = $this->table(\'lgt_good\');\r\n         $table->addColumn(\'status\',\'boolean\',[\'default\'=>1])\r\n             ->update();\r\n     }\r\n  }\r\n  ```\r\n\r\n- changeColumn()修改列属性\r\n\r\n  ```php\r\n  <?php\r\n  declare(strict_types=1);\r\n  \r\n  use Phinx\\Migration\\AbstractMigration;\r\n  \r\n  final class AlterLgtGood extends AbstractMigration\r\n  {\r\n     public function up():void {\r\n         $table = $this->table(\'lgt_good\');\r\n         $table->changeColumn(\'status\',\'integer\')\r\n             ->update();\r\n     }\r\n  \r\n     public function down():void {\r\n         $table = $this->table(\'lgt_good\');\r\n         $table->changeColumn(\'status\',\'boolean\',[\'default\'=>1])\r\n             ->update();\r\n     }\r\n  }\r\n  ```\r\n\r\n  \r\n\r\n#### 操作索引\r\n\r\n- addIndex()添加索引\r\n\r\n- removeIndex()删除索引\r\n\r\n  ```php\r\n  <?php\r\n  declare(strict_types=1);\r\n  \r\n  use Phinx\\Migration\\AbstractMigration;\r\n  \r\n  final class AlterLgtGood extends AbstractMigration\r\n  {\r\n     public function up():void {\r\n         $table = $this->table(\'lgt_good\');\r\n         $table->addIndex(\'name\')\r\n             ->update();\r\n     }\r\n  \r\n     public function down():void {\r\n         $table = $this->table(\'lgt_good\');\r\n         $table->removeIndex(\'name\')\r\n             ->update();\r\n     }\r\n  }\r\n  ```\r\n\r\n  addIndex()默认创建普通索引，创建唯一索引需要加参数unique\r\n\r\n  ```php\r\n  <?php\r\n  declare(strict_types=1);\r\n  \r\n  use Phinx\\Migration\\AbstractMigration;\r\n  \r\n  final class AlterLgtGood extends AbstractMigration\r\n  {\r\n     public function up():void {\r\n         $table = $this->table(\'lgt_good\');\r\n         $table->addIndex(\'name\',[\r\n             \'unique\' =>  true,\r\n             \'name\'   =>  \'name_index\'\r\n         ])\r\n             ->update();\r\n     }\r\n  \r\n     public function down():void {\r\n         $table = $this->table(\'lgt_good\');\r\n         $table->removeIndex(\'name\')\r\n             ->update();\r\n     }\r\n  }\r\n  ```\r\n\r\n  上面创建了一个索引名称是name_index的唯一索引。\r\n\r\n  也可以创建组合索引，如下\r\n\r\n  ```php\r\n  $table->->addIndex([\'email\',\'username\'])\r\n  ```\r\n\r\n  也可以给字段的指定长度创建索引，如下:\r\n\r\n  ```php\r\n  $table->->addIndex(\'name\',[\'limit\'=>10])\r\n  ```\r\n\r\n  \r\n\r\n#### 使用查询生成器\r\n\r\n查询生成器用来操作负载的SELECT、UPDATE、DELETE、INSERT,\r\n\r\n使用如下代码获取生成器对象:\r\n\r\n```php\r\n$builder = $this->getQueryBuilder();\r\n```\r\n\r\n- 查询字段\r\n\r\n  ```php\r\n  $builder->select([\'id\', \'title\', \'body\']);\r\n  \r\n  // Results in SELECT id AS pk, title AS aliased_title, body ...\r\n  $builder->select([\'pk\' => \'id\', \'aliased_title\' => \'title\', \'body\']);\r\n  \r\n  // Use a closure\r\n  $builder->select(function ($builder) {\r\n      return [\'id\', \'title\', \'body\'];\r\n  });\r\n  ```\r\n\r\n- where条件\r\n\r\n  ```php\r\n  // WHERE id = 1\r\n  $builder->where([\'id\' => 1]);\r\n  \r\n  // WHERE id > 1\r\n  $builder->where([\'id >\' => 1]);\r\n  \r\n  $builder->where([\'id >\' => 1])->andWhere([\'title\' => \'My Title\']);\r\n  \r\n  // Equivalent to\r\n  $builder->where([\'id >\' => 1, \'title\' => \'My title\']);\r\n  \r\n  // WHERE id > 1 OR title = \'My title\'\r\n  $builder->where([\'OR\' => [\'id >\' => 1, \'title\' => \'My title\']]);\r\n  ```\r\n\r\n  更复杂的查询\r\n\r\n  ```php\r\n  // Coditions are tied together with AND by default\r\n  $builder\r\n      ->select(\'*\')\r\n      ->from(\'articles\')\r\n      ->where(function ($exp) {\r\n          return $exp\r\n              ->eq(\'author_id\', 2)\r\n              ->eq(\'published\', true)\r\n              ->notEq(\'spam\', true)\r\n              ->gt(\'view_count\', 10);\r\n      });\r\n  ```\r\n\r\n  等价于下面的sql:\r\n\r\n  ```sql\r\n  SELECT * FROM articles\r\n  WHERE\r\n      author_id = 2\r\n      AND published = 1\r\n      AND spam != 1\r\n      AND view_count > 10\r\n  ```\r\n\r\n  组合查询\r\n\r\n  ```php\r\n  $builder\r\n      ->select(\'*\')\r\n      ->from(\'articles\')\r\n      ->where(function ($exp) {\r\n          $orConditions = $exp->or_([\'author_id\' => 2])\r\n              ->eq(\'author_id\', 5);\r\n          return $exp\r\n              ->not($orConditions)\r\n              ->lte(\'view_count\', 10);\r\n      });\r\n  ```\r\n\r\n  生成的sql如下:\r\n\r\n  ```php\r\n  SELECT *\r\n  FROM articles\r\n  WHERE\r\n      NOT (author_id = 2 OR author_id = 5)\r\n      AND view_count <= 10\r\n  ```\r\n\r\n  支持where的可选方法还有下列一些:\r\n\r\n  - eq()\r\n  - notEq()\r\n  - like()\r\n  - notLike()\r\n  - in()\r\n  - notIn()\r\n  - gt()\r\n  - gte()\r\n  - lt()\r\n  - lte()\r\n  - isNull()\r\n  - isNotNull()\r\n\r\n  使用MySQL内置方法的方式:\r\n\r\n  ```php\r\n  // Results in SELECT COUNT(*) count FROM ...\r\n  $builder->select([\'count\' => $builder->func()->count(\'*\')]);\r\n  ```\r\n\r\n- 获取查询结果\r\n\r\n  ```php\r\n  // Iterate the query\r\n  foreach ($builder as $row) {\r\n      echo $row[\'title\'];\r\n  }\r\n  \r\n  // Get the statement and fetch all results\r\n  $results = $builder->execute()->fetchAll(\'assoc\');\r\n  ```\r\n\r\n- 创建数据\r\n\r\n  ```php\r\n  $builder = $this->getQueryBuilder();\r\n  $builder\r\n      ->insert([\'first_name\', \'last_name\'])\r\n      ->into(\'users\')\r\n      ->values([\'first_name\' => \'Steve\', \'last_name\' => \'Jobs\'])\r\n      ->values([\'first_name\' => \'Jon\', \'last_name\' => \'Snow\'])\r\n      ->execute()\r\n  ```\r\n\r\n- 更新数据\r\n\r\n  ```php\r\n  $builder = $this->getQueryBuilder();\r\n  $builder\r\n      ->update(\'users\')\r\n      ->set(\'fname\', \'Snow\')\r\n      ->where([\'fname\' => \'Jon\'])\r\n      ->execute()\r\n  ```\r\n\r\n- 删除数据\r\n\r\n  ```php\r\n  $builder = $this->getQueryBuilder();\r\n  $builder\r\n      ->delete(\'users\')\r\n      ->where([\'accepted_gdpr\' => false])\r\n      ->execute()\r\n  ```\r\n\r\n### 常用命令\r\n\r\n- 创建迁移文件\r\n\r\n  ```shell\r\n  ./vendor/bin/phinx create MyMigrate\r\n  ```\r\n\r\n- 初始化，生成Phinx的配置文件\r\n\r\n  ```php\r\n  ./vendor/bin/phinx init  //默认当前目录生成phinx.php\r\n  ```\r\n\r\n  ```php\r\n  ./vendor/bin/phinx init migration.php //指定生成的文件名\r\n  ```\r\n\r\n  ```php\r\n  ./vendor/bin/phinx init --format=yml //指定生成的文件格式，可以指定php、json、yml\r\n  ```\r\n\r\n- 执行迁移\r\n\r\n  ```shell\r\n  ./vendor/bin/phinx migrate -e development  \r\n  ```\r\n\r\n  -e指定数据库环境，不指定-e,默认使用配置文件中配置的默认环境\r\n\r\n- 执行回滚\r\n\r\n  ```php\r\n  phinx rollback -e development\r\n  ```\r\n\r\n### 配置\r\n\r\n- 指定迁移文件生成的位置\r\n\r\n  ```php\r\n  paths:\r\n      migrations: /your/full/path\r\n  ```\r\n\r\n- 指定迁移数据表名\r\n\r\n  ```php\r\n  environments:\r\n      default_migration_table: migrations\r\n  ```\r\n\r\n- 配置默认环境\r\n\r\n  ```php\r\n  environments:\r\n      default_environment: development\r\n  ```\r\n\r\n- 表前缀、后缀\r\n\r\n  ```php\r\n  environments:\r\n      development:\r\n          table_prefix: dev_\r\n          table_suffix: _v1\r\n  ```\r\n\r\n  \r\n\r\n### 更多\r\n\r\nPhinx是一个强大的工具，还有很多功能没能及时进行说明，可以参考[Phinx官网](https://phinx.org/)进行学习\r\n\r\n',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,956,1),(57,'设计模式之代理模式','57',1595829840,1595829968,'<!--markdown-->### 定义\r\n代理模式提供了对目标对象的另一种访问方式，通过代理对象访问目标对象,也就是我们平常说得中介;.带理模式得好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能。代理模式的关键点是:代理对象是对目标对象的扩展,**并会调用目标对象**。代理模式需要实现目标对象得所有方法。\r\n### 分类\r\n因为代理模式需要实现目标对象的所有方法，根据这个特点可以分为动态代理模式、静态代理模式\r\n- 静态代理模式\r\n通过手动编码，实现目标对象的每一个方法，也就是说目标对象实现了哪些方法，代理类就需要实现那些方法。\r\n\r\n- 动态代理模式\r\n动态代理模式不需要手动实现目标对象的方法，通过反射动态创建\r\n\r\n### 实现\r\n\r\n- 静态代理模式\r\n\r\n```php\r\n<?php\r\n\r\ninterface DB {\r\n\r\n    public function find();\r\n    \r\n    public function findAll();\r\n    \r\n    public function findColumn();\r\n\r\n}\r\n\r\nclass Mysql implements DB\r\n{\r\n    \r\n    public function find() \r\n    {\r\n        echo \"this is find\";\r\n    }\r\n    \r\n    public function findAll()\r\n    {\r\n        echo \"this is findAll\";\r\n    }\r\n    \r\n    public function findColumn()\r\n    {\r\n        echo \"this is findColumn\";\r\n    }\r\n}\r\n\r\nclass MysqlProxy implements DB\r\n{\r\n\r\n    private $db;\r\n    \r\n    public function __construct()\r\n    {\r\n        $this->db = new Mysql;\r\n    }\r\n    \r\n    public function find()\r\n    {\r\n        $this->db->find();\r\n    }\r\n    \r\n    public function findAll()\r\n    {\r\n        echo \"我扩展下fnidAll，输出这行代码\";\r\n        $this->db->findAll();\r\n    }\r\n    \r\n    public function findColumn()\r\n    {\r\n        $this->db->findColumn();\r\n    }\r\n}\r\n```\r\n\r\n使用方式\r\n```php\r\n$proxy = new MysqlProxy;\r\n\r\n$proxy->find();\r\n$proxy->findAll();\r\n$proxy->findColumn();\r\n```\r\n我们可以看到代理类MysqlProxy实现了目标类Mysql的接口DB，并且最终调用的是被代理类的方法，当然也可以扩展添加自己的代码。\r\n\r\n- 动态代理模式\r\n\r\n```php\r\n<?php\r\n\r\ninterface DB {\r\n\r\n    public function find();\r\n    \r\n    public function findAll();\r\n    \r\n    public function findColumn();\r\n\r\n}\r\n\r\nclass Mysql implements DB\r\n{\r\n    \r\n    public function find() \r\n    {\r\n        echo \"this is find\";\r\n    }\r\n    \r\n    public function findAll()\r\n    {\r\n        echo \"this is findAll\";\r\n    }\r\n    \r\n    public function findColumn()\r\n    {\r\n        echo \"this is findColumn\";\r\n    }\r\n}\r\n\r\nclass MysqlProxy\r\n{\r\n    public function __call($methodName, $args)\r\n    {\r\n        $className = \'Mysql\';\r\n        $reflectionClass = new ReflectionClass($className);\r\n        if($reflectionClass->hasMethod($methodName)) {\r\n            $reflectionMethod = new ReflectionMethod($className, $methodName);\r\n            if($reflectionMethod->isPublic()) {\r\n                $reflectionMethod->invoke(new $className,$args);\r\n            } else {\r\n                throw new Exception(\"method \".$method. \' is not public in class DB\');\r\n            }\r\n        } else {\r\n            throw new Exception(\" not found method \".$method. \' in class DB\');\r\n        }\r\n    }\r\n}   \r\n```\r\n使用方式同静态代理模式一样:\r\n```php\r\n$proxy = new MysqlProxy;\r\n$proxy->find();\r\n$proxy->findAll();\r\n$proxy->findColumn();\r\n```\r\n对比静态代理模式，动态代理模式不再需要显示的实现DB接口，动态代理模式如果想为某些方法扩展添加自己的方法变得比较困难。',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,704,0),(58,'设计模式之多例模式','58',1595910780,1595910865,'<!--markdown-->多例模式其实是单例模式的扩展，就是在程序运行过程中一个类有多个实例对象，这个模式在实际场景中用的不多，但是为解决问题提供了更多的思路，比如读取分布式缓存服务器的数据,可以根据key取模进行缓存和数据读取。\r\n\r\n### 代码实现\r\n```php\r\n<?php\r\n\r\nclass Multiton {\r\n\r\n	private static $_instance = array();\r\n\r\n	private function __construct() \r\n	{\r\n\r\n	}\r\n\r\n	private function __clone() \r\n	{\r\n\r\n	}\r\n\r\n	public static function getInstance()\r\n	{\r\n		$rand_num = rand(1,10);\r\n		\r\n		$index = $rand_num % 3;\r\n\r\n		if(!isset(self::$_instance[$index])) {\r\n			self::$_instance[$index] = new self;\r\n			echo \'新实例--\';\r\n		}\r\n		echo \"实例\".$index;\r\n\r\n		return self::$_instance[$index];\r\n	}\r\n}\r\n```\r\n\r\n### 调用方式\r\n```php\r\nfor($i=0;$i<100;$i++) {\r\n	Multiton::getInstance();\r\n	echo \"<br/>\";\r\n}\r\n```',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,732,0),(59,'设计模式之原型模式','59',1596083700,1596083815,'<!--markdown-->### 定义\r\n\r\n原型模式定义: 用一个已经创建的实例作为原型，通过复制该原型对象来创建一个新对象。用这种方式创建对象非常高效，根本无须知道对象创建的细节。\r\n\r\n### 使用场景\r\n- 在需要一个类的大量对象的时候，使用原型模式是最佳选择，因为原型模式是在内存中对这个对象进行拷贝，要比直接new这个对象性能要好很多。\r\n\r\n- 如果一个对象的初始化需要很多其他对象的数据准备或其他资源的繁琐计算，那么可以使用原型模式\r\n\r\n### 代码实现\r\n\r\n```php\r\n<?php\r\n\r\ninterface Prototype {\r\n    public function copy();\r\n}\r\n\r\nclass Person implements Prototype \r\n{\r\n    public $name;\r\n\r\n    public $db;\r\n\r\n    public function __construct($name,$db) \r\n    {\r\n        $this->name =   $name;\r\n        $this->db   =   $db;\r\n    }\r\n\r\n    public function copy()\r\n    {\r\n        return clone $this;\r\n    }\r\n}\r\n\r\nclass Db\r\n{\r\n    public $name;\r\n\r\n    public function __construct($name) \r\n    {\r\n        $this->name = $name;\r\n    }\r\n}\r\n\r\n```\r\n这就实现了一个原型模式，测试代码如下\r\n```php\r\n\r\n$db = new Db(\"db1\");\r\n\r\n$person = new Person(\"person1\",$db);\r\n\r\n$person1 = $person->copy();\r\n\r\nvar_dump($person->name, $person1->name,\"====\");\r\nvar_dump($person->db->name, $person1->db->name,\"====\");\r\n\r\n$person->name = \"person2\";\r\n$person->db->name = \'db2\';\r\nvar_dump($person->name, $person1->name,\"====\");\r\nvar_dump($person->db->name, $person1->db->name,\"====\");\r\n```\r\n输出结果\r\n```shell\r\n\r\nstring(7) \"person1\"\r\nstring(7) \"person1\"\r\nstring(4) \"====\"\r\nstring(3) \"db1\"\r\nstring(3) \"db1\"\r\nstring(4) \"====\"\r\nstring(7) \"person2\"\r\nstring(7) \"person1\"\r\nstring(4) \"====\"\r\nstring(3) \"db2\"\r\nstring(3) \"db2\"\r\nstring(4) \"====\"\r\n```\r\n我们可以看到，调用person对象进行copy得到了person1实例，修改person实例的name属性和db属性的name之后，person1实例的name属性没有进行同步变化，但是person1实例的db属性name却同步被修改了，这是为什么呢?这就引入了浅拷贝、深拷贝的概念。\r\n\r\n### 浅拷贝&深拷贝\r\n- 浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。通俗一点就是浅拷贝会复制对象的标量属性的值，但是如果属性是引用别的对象，则只是对属性对应的地址进行复制，引用的对象不会进行复制。php自带的clone函数属于浅拷贝，上面的例子已经证实这一点。\r\n\r\n- 深拷贝:被复制对象的所有变量都含有与原来的对象相同的值，所有的引用的其它对象也被复制一份，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。 \r\n\r\n我们看一个深拷贝的原型模式:\r\n\r\n```php\r\n<?php\r\n\r\ninterface Prototype {\r\n    public function copy();\r\n}\r\n\r\nclass Person implements Prototype \r\n{\r\n    public $name;\r\n\r\n    public $db;\r\n\r\n    public function __construct($name,$db) \r\n    {\r\n        $this->name =   $name;\r\n        $this->db   =   $db;\r\n    }\r\n\r\n    public function copy()\r\n    {\r\n        $obj = serialize($this);\r\n        return unserialize($obj);\r\n    }\r\n}\r\n\r\nclass Db\r\n{\r\n    public $name;\r\n\r\n    public function __construct($name) \r\n    {\r\n        $this->name = $name;\r\n    }\r\n}\r\n\r\n```\r\n使用serialize、unserialize序列化、反序列化进行对象的深度拷贝，输出的结果如下,我们可以看到实例的name属性和db属性引用的db实例的name也实现了复制。\r\n\r\n```shell\r\nstring(7) \"person1\"\r\nstring(7) \"person1\"\r\nstring(4) \"====\"\r\nstring(3) \"db1\"\r\nstring(3) \"db1\"\r\nstring(4) \"====\"\r\nstring(7) \"person2\"\r\nstring(7) \"person1\"\r\nstring(4) \"====\"\r\nstring(3) \"db2\"\r\nstring(3) \"db1\"\r\nstring(4) \"====\"\r\n```\r\n\r\n**注意原型模式是实现对原型的复制拷贝，不会重新new实例**\r\n',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,627,0),(60,'1.jpg','1-jpg-1',1596248080,1596248080,'a:5:{s:4:\"name\";s:5:\"1.jpg\";s:4:\"path\";s:35:\"/usr/uploads/2020/08/2840530327.jpg\";s:4:\"size\";i:12723;s:4:\"type\";s:3:\"jpg\";s:4:\"mime\";s:10:\"image/jpeg\";}',1,2,NULL,'attachment','publish',NULL,0,'1','0','1',61,0,0),(61,'Symfony之优雅的var_dump','61',1596248134,1596248134,'<!--markdown-->大家对var_dump应该不陌生了，用于输出，一般都是调试的时候会用到，今天为大家介绍的是symfony组件VarDumper 。VarDumper是一个简单的，类似于 var_dump 的调试工具，输出界面优美，支持结构的折叠，可以用来替代 var_dump。\r\n\r\n### 预览图\r\n![1.jpg](http://www.fxjson.com/usr/uploads/2020/08/2840530327.jpg)\r\n\r\n### 安装\r\n```php\r\ncomposer require symfony/var-dumper\r\n```\r\n\r\n### 使用\r\n```php\r\n<?php\r\n\r\nrequire \'vendor/autoload.php\';\r\n\r\n$arr = [\r\n    [\'name\'=>\'范晓杰\',\'age\'=>31],\r\n    [\'name\'=>\'Json\',\'age\'=>30]\r\n];\r\n\r\ndump($arr,\"12345\");\r\n\r\nclass Test {\r\n    \r\n    private $name;\r\n    private $age;\r\n    private $address;\r\n    \r\n    public function __construct($name) {\r\n        $this->name = $name;\r\n    }\r\n    \r\n    public function say() {\r\n        echo $this->name;\r\n    }\r\n    \r\n}\r\n\r\n$obj = new Test(\"test\");\r\ndd($obj);\r\ndump(\"hello world\");\r\n```\r\n\r\n### 介绍\r\n上面的例子其实已经告诉大家怎么使用了，只需要两步\r\n- 引入autoload.php文件\r\n- dump或者dd函数直接使用就好，用法跟var_dump一样\r\n\r\n值得注意的是,**dump函数不会终止程序，dd会终止下面的代码运行**\r\n```php\r\n<?php\r\nrequire \'vendor/autoload.php\';\r\n\r\n$arr = [11,22,33,null,55];\r\ndd($arr);//等价于dump($arr);exit(1);\r\necho \"ok\";\r\n\r\n```\r\n\r\n### 其它\r\nVarDumper支持实例对象的输出\r\n```php\r\n<?php\r\n\r\nrequire \'vendor/autoload.php\';\r\n\r\nclass Test {\r\n    \r\n    public $name;\r\n    public $age;\r\n    public $db;\r\n    public function say() {\r\n        return \"hello world\";\r\n    }\r\n}\r\n\r\n$test = new Test;\r\ndump($test);\r\n\r\n```',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,610,0),(62,'像Laravel一样从.env文件中读取配置','62',1596367500,1596367589,'<!--markdown-->熟悉laravel的朋友应该对env函数不陌生了吧，config文件夹里面的每个文件应该都会用到，今天为大家推荐的就是laravel项目从.env文件里面读取配置的库,[vlucas/phpdotenv](https://github.com/vlucas/phpdotenv)。大家可以看到laravel/framework项目的composer.json文件有依赖这个库。大家可以在github上搜到这个库。\r\n\r\n### 用途\r\n\r\n从.env文件里面读取配置到getenv(), $_ENV and $_SERVER。\r\n\r\n### 安装\r\n```shell\r\ncomposer require vlucas/phpdotenv\r\n```\r\n\r\n### 使用\r\n- 创建.env文件\r\n\r\n```shell\r\nDB_HOST=127.0.0.1\r\nDB_NAME=demo\r\nDB_USER=root\r\nDB_PASS=root\r\nDB_PORT=3306\r\n```\r\n\r\n- 代码\r\n\r\n所有的配置变量都可以通过$_ENV,$_SERVER超全局变量读取。\r\n```php\r\n<?php\r\n\r\nrequire \'vendor/autoload.php\';\r\n\r\n$dotenv = Dotenv\\Dotenv::createImmutable(__DIR__);\r\n$dotenv->load();\r\n\r\nvar_dump($_ENV[\'DB_HOST\'],$_SERVER[\'DB_HOST\']);\r\n```\r\n\r\n### 其它\r\n- 自定义配置文件\r\n\r\n使用第二个参数设置从其它文件读取配置\r\n```php\r\n$dotenv = Dotenv\\Dotenv::createImmutable(__DIR__, \'.env.local\');\r\n$dotenv->load();\r\n```\r\n- 使用getenv函数读取配置\r\n\r\n要使用getenv函数读取配置，需要使用Dotenv::createUnsafeImmutable方法，如下代码\r\n\r\n```php\r\n<?php\r\n\r\nrequire \'vendor/autoload.php\';\r\n\r\n$dotenv = Dotenv\\Dotenv::createUnsafeImmutable(__DIR__);\r\n$dotenv->load();\r\n\r\nvar_dump($_ENV[\'DB_HOST\'],$_SERVER[\'DB_HOST\'],getenv(\'DB_HOST\'));\r\n```\r\n\r\n- 配置里面使用另一个配置变量\r\n\r\n配置变量使用另一个配置变量的值，需要使用${}将变量包起来，如下,DB_URL使用DB_HOST、DB_USER、DB_PASS变量\r\n\r\n```shell\r\nDB_HOST=127.0.0.1\r\nDB_NAME=demo\r\nDB_USER=root\r\nDB_PASS=root\r\nDB_PORT=3306\r\n\r\nDB_URL = \"${DB_HOST}/${DB_USER}:${DB_PASS}\"\r\n```\r\n\r\n- 验证变量\r\n该库提供了对配置文件中变量的必要验证方法\r\n \r\n	-  验证配置变量必填\r\n ```php\r\n $dotenv->required(\'DATABASE_DSN\');\r\n ```\r\n \r\n - 验证多个变量必填\r\n ```php\r\n $dotenv->required([\'DB_HOST\',\'DB_URL1\']);\r\n ```\r\n - 验证存在且不为空\r\n ```php\r\n $dotenv->required(\'DATABASE_DSN\')->notEmpty()\r\n ```\r\n - 验证是整数\r\n ```php\r\n $dotenv->ifPresent(\'DB_PORT\')->isInteger();\r\n ```\r\n\r\nphpdotenv还有更多用法，大家可以点击[这里](https://github.com/vlucas/phpdotenv)\r\n',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,973,1),(63,'设计模式之门面模式','63',1596430020,1596430066,'<!--markdown-->### 定义\r\n\r\n什么是门面模式呢？我们先举个例子，我们装修房子的时候一般都是找一个装修公司，然后告诉他们自己的装修要求，然后装修公司打包一切工作帮我们装修。而有的人也会选择自己找人装修，那就费劲了，需要自己去买地板，买水泥，买涂料，买木料等一切需要的材料，很繁琐。在这个例子中，装修公司实际就是个门面角色，我们提装修的要求，跟装修公司联系就好了，我们不需要对接其它细节工作，至于装修公司怎么装修，怎么买水泥等材料我们不关心。\r\n\r\n再举个例子，晚上要睡觉了，要关掉空调，电灯，电视各种电器，我们要找到各个电器的按钮去一个一个关闭掉，如果有一个总按钮，我们摁一下所有电器都关闭了，这是不是很方便呢。这个总按钮其实就是一个门面，内部处理去关闭各个电器。\r\n\r\n门面模式提供一个统一的接口去访问多个子系统的多个不同的接口，它为子系统中的一组接口提供一个统一的高层接口，使子系统更容易使用，最终实现化零为整。\r\n\r\n### 代码\r\n```php\r\n<?php\r\nclass Light \r\n{\r\n    public function open()\r\n    {\r\n        echo \'电灯开了\';\r\n    }\r\n\r\n    public function close()\r\n    {\r\n        echo \'电灯关了\';\r\n    }\r\n}\r\n\r\nclass TV \r\n{\r\n    public function on()\r\n    {\r\n        echo \'电视打开了\';\r\n    }\r\n\r\n    public function off()\r\n    {\r\n        echo \'电视关闭了\';\r\n    }\r\n}\r\n\r\nclass Computer \r\n{\r\n    public function turnOn()\r\n    {\r\n        echo \'电脑打开了\';\r\n    }\r\n\r\n    public function turnOff()\r\n    {\r\n        echo \'电脑关闭了\';\r\n    }\r\n}\r\n\r\nclass Facade \r\n{\r\n    private $tv;\r\n    private $light;\r\n    private $computer;\r\n\r\n    public function __construct()\r\n    {\r\n        $this->tv = new TV;\r\n        $this->light = new Light;\r\n        $this->computer = new Computer;\r\n    }\r\n\r\n    public function open()\r\n    {\r\n        $this->tv->on();\r\n        $this->light->open();\r\n        $this->computer->turnOn();\r\n    }\r\n\r\n    public function close()\r\n    {\r\n        $this->tv->off();\r\n        $this->light->close();\r\n        $this->computer->turnOff();\r\n    }\r\n}\r\n\r\n$facade = new Facade;\r\n\r\n$facade->open();\r\n\r\n$facade->close();\r\n```',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,721,0),(64,'设计模式之观察者模式','64',1596535902,1596535902,'<!--markdown-->### 定义\r\n\r\n观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。在观察者模式中，可以有任意数目的观察者订阅并接收通知。观察者模式中有两个重要得角色:观察者和被观察者，被观察者在观察者模式中一般叫主题。举例来说，我们大家都会关注微信公众号，比如你关注了\"Json的博客\"的公众号，那你就成了这个公众号的观察者，小王也关注了这个公众号，则小王也成了观察者，而这个公众号就是所谓的被观察者，也就是观察者模式中的主题。\r\n\r\n### 角色\r\n- 抽象主题（Subject)\r\n抽象主题定义具体主题的抽象方法，提供约定，可以增加和删除观察者对象。\r\n- 具体主题（Concrete Subject）\r\n实现抽象主题提供的方法，包括实现添加、删除观察者对象。\r\n- 抽象观察者（Observer）：\r\n为所有的具体观察者定义接口，在得到主题通知时更新自己。\r\n- 具体观察者（Concrete Observer）：\r\n实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题状态协调\r\n\r\n### 代码\r\n```php\r\n<?php\r\n\r\ninterface Subject \r\n{\r\n    //添加观察者\r\n    public function add(Observer $observer);\r\n\r\n    //删除观察者\r\n    public function remove(Observer $observer);\r\n\r\n    //发送通知\r\n    public function notify($message);\r\n}\r\n\r\ninterface Observer \r\n{\r\n    public function execute($message);\r\n}\r\n\r\nclass MessageSubject implements Subject\r\n{\r\n    private $element = [];\r\n\r\n    public function add(Observer $observer) \r\n    {\r\n        $this->element[get_class($observer)] = $observer;\r\n    }\r\n\r\n    public function remove(Observer $observer)\r\n    {\r\n        unset($this->element[get_class($observer)]);\r\n    }\r\n\r\n    public function notify($message) \r\n    {\r\n        foreach($this->element as $observer)\r\n        {\r\n            $observer->execute($message);\r\n        }\r\n    }\r\n}\r\n\r\nclass JsonObserver implements Observer\r\n{\r\n    public function execute($message)\r\n    {\r\n        echo \"我叫Json,我收到了消息:\".$message;\r\n    }\r\n}\r\n\r\nclass WangObserver implements Observer\r\n{\r\n    public function execute($message)\r\n    {\r\n        echo \"我叫小王,我收到了消息,但是内容我不想告诉你\";\r\n    }\r\n}\r\n```\r\n客户端使用方式：\r\n```php\r\n$subject = new MessageSubject;\r\n\r\n//添加观察者\r\n$jsonObserver = new JsonObserver; \r\n$subject->add($jsonObserver);\r\n$wangObserver = new WangObserver;\r\n$subject->add($wangObserver);\r\n//通知\r\n$subject->notify(\"我发布新文章了，快来看看吧!文章内容:我不是大牛，只是多写了几年代码而已!\");\r\n\r\n$subject->remove($wangObserver);\r\n$subject->notify(\"我又发布新文章了，快来看看吧!\");\r\n\r\n```\r\n上面就是实现了观察者模式的全部代码，可以看到我们可以无限添加观察者，之后主题更新会给所有观察者发消息，也可以根据情况删除观察者，删除之后，被删除的观察者不再收到消息。\r\n\r\n### 分类\r\n\r\n- 推模式： 主题对象向观察者主动推送消息，不管观察者是否需要。\r\n\r\n- 拉模式：主题对象在通知观察者的时候，只传递少量信息或者不传信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取。\r\n\r\n### 推模式观察者\r\n其实上面的例子就是一个推模式的观察者，我不管JsonObserver、WangObserver是否需要消息的具体内容，反正主题向观察者推送了，至于观察者需不需要就是观察者自己的事情了，例如下面的WangObserver并不输出收到的消息内容，而是自己定义了输出。\r\n### 拉模式观察者\r\n\r\n```php\r\n<?php\r\n\r\n\r\ninterface Subject \r\n{\r\n    //添加观察者\r\n    public function add(Observer $observer);\r\n\r\n    //删除观察者\r\n    public function remove(Observer $observer);\r\n\r\n    //发送通知\r\n    public function notify();\r\n}\r\n\r\ninterface Observer \r\n{\r\n    public function execute($message);\r\n}\r\n\r\nclass MessageSubject implements Subject\r\n{\r\n    private $element = [];\r\n\r\n    public function add(Observer $observer) \r\n    {\r\n        $this->element[get_class($observer)] = $observer;\r\n    }\r\n\r\n    public function remove(Observer $observer)\r\n    {\r\n        unset($this->element[get_class($observer)]);\r\n    }\r\n\r\n    public function notify() \r\n    {\r\n        foreach($this->element as $observer)\r\n        {\r\n            $observer->execute($this);\r\n        }\r\n    }\r\n\r\n    public function getMessage()\r\n    {\r\n        return \"我发布新文章了，快来看看吧\";\r\n    }\r\n}\r\n\r\nclass JsonObserver implements Observer\r\n{\r\n    public function execute($obj)\r\n    {\r\n        echo \"我叫Json,我收到了消息:\".$obj->getMessage();\r\n    }\r\n}\r\n\r\nclass WangObserver implements Observer\r\n{\r\n    public function execute($obj)\r\n    {\r\n        echo \"我叫小王,我收到了消息,但是内容我不关心\";\r\n    }\r\n}\r\n```\r\n调用方式代码:\r\n```php\r\n\r\n$subject = new MessageSubject;\r\n\r\n//添加观察者\r\n$jsonObserver = new JsonObserver; \r\n$subject->add($jsonObserver);\r\n$wangObserver = new WangObserver;\r\n$subject->add($wangObserver);\r\n//通知\r\n$subject->notify();\r\n\r\n$subject->remove($wangObserver);\r\n$subject->notify();\r\n\r\n```\r\n可以看到拉模式的观察者模式，不会主动推送消息，而是如果观察者需要，则自己去拉取消息。\r\n\r\n',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,704,0),(65,'php之PhpOption库','65',1596549600,1596549797,'<!--markdown-->### 前言\r\n\r\n查看laravel框架的config目录的配置文件时，看到了env这个函数，于是根据代码提示追踪了下，无意间发现了phpoption/phpoption这个代码仓库，这个库具体有什么作用，我也说不清楚，感觉有点儿类似于空对象模式，但又有些不一样。\r\n\r\n### 介绍\r\n\r\n这个库在github可以搜索到，大家可以自行搜索，github介绍说这个库是一个可选项类型，什么意思呢我不是特别理解。我总结的这个库主要是用来提供默认值或者默认结构，减少冗余代码。\r\n\r\n- 提供默认值\r\n\r\nlaravel也是采用的这种方式，主要是给config配置项提供默认值，大家应该都知道了env()函数，从.env文件里面读取配置，如果.env文件里面不存在这个变量，则取env函数的第二个值作为默认值。逻辑代码如下:\r\n\r\n```php\r\n/**\r\n * Gets the value of an config file.\r\n *\r\n * @param  string  $key\r\n * @param  mixed  $default\r\n * @return mixed\r\n */\r\nfunction env($key,$default) {\r\n    \r\n   //模拟配置文件\r\n   $configFromFile = [\r\n        \'DB_HOST\'   =>  \'localhost\',\r\n        \'DB_USER\'   =>  \'json\'\r\n   ];\r\n   \r\n   return Option::fromValue($configFromFile[$key])->getOrCall(function() use ($default) {\r\n        return $default; \r\n   });\r\n}\r\n$arr = [\r\n    \'DB_HOST\'   =>  env(\"DB_HOST\",\'127.0.0.1\'),\r\n    \'DB_USER\'   =>  env(\'DB_USER\',\'root\'),\r\n    \'DB_PORT\'   =>  env(\'DB_PORT\',3306)\r\n];\r\n\r\nvar_dump($arr);\r\n```\r\n最后结果输出\r\n\r\n```php\r\narray(3) {\r\n  [\"DB_HOST\"]=>\r\n  string(9) \"localhost\"\r\n  [\"DB_USER\"]=>\r\n  string(4) \"json\"\r\n  [\"DB_PORT\"]=>\r\n  int(3306)\r\n}\r\n```\r\n这里我用$configFromFile模拟从.env文件里面读取的配置，laravel其实是通过vlucas/phpdotenv库读取.env文件的，之前我有文章已经介绍过这个库。我们可以看到$configFromFile里面没有DB_PORT，则读取的是默认值3306.\r\n\r\n- 返回默认结构\r\n\r\n相信用过laravel或者其它框架的同学都知道，一般model或者repository返回的都是实体entity，我们在业务层经常见过类似下面的代码。\r\n```php\r\n	$user = $userRepository->find(5);\r\n	$data = [\r\n		\'name\'   => $user?$user->name:\'\',\r\n		\'age\'	=> $user?$user->age:\'\',\r\n	];\r\n```\r\n我们需要判断兼容$user为空的情况。而PhpOption在这里也有适用的场景，我们看修改后的完整代码。\r\n\r\n```php\r\nrequire \'vendor/autoload.php\';\r\n\r\nuse PhpOption\\Option;\r\n\r\nclass UserRepository \r\n{\r\n    public function find($id)\r\n    {\r\n        $user = null;\r\n        //模拟查到的数据存在和不存在的情况，这里真实情况下一般是db里面查询记录结构，映射成entity\r\n        if($id>10) {\r\n            $user = new UserEntity($id,\"Json\",32);\r\n        }\r\n        return Option::fromValue($user);\r\n        \r\n    }\r\n}\r\n\r\nclass UserEntity \r\n{\r\n    public $id;\r\n    public $name;\r\n    public $age;\r\n    \r\n    public function __construct($id=\'\', $name=\'\', $age=\'\') \r\n    {\r\n        $this->id = $id;\r\n        $this->name = $name;\r\n        $this->age = $age;\r\n    }\r\n}\r\n```\r\n使用方法\r\n```php\r\n$userRepository = new UserRepository;\r\n\r\n$user = $userRepository->find(8)->getOrCall(function() {\r\n    return new UserEntity;\r\n});\r\n\r\n$data = [\r\n    \'name\'   => $user->name,\r\n    \'age\'	 => $user->age,\r\n];\r\nvar_dump($data);\r\n```\r\n可以看到从不再需要$user?$user->name:\"\"类似的兼容代码了，看上去是不是很舒服。\r\n\r\n### 安装\r\n```shell\r\ncomposer require phpoption/phpoption\r\n```\r\n\r\n### 其它\r\n\r\n上面的例子代码使用了PhpOption库中的fromValue方法和getOrCall方法，这个库还有其它一些方法，大家可以通过**[github](https://github.com/schmittjoh/php-option)**进行查看，这里就不一一介绍了。\r\n',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,955,0),(66,'设计模式之迭代器模式','66',1596688224,1596688224,'<!--markdown-->### 定义\r\n迭代器模式，又叫游标模式，迭代器模式提供一种方法顺序访问一个容器集合中的所有元素，而又不暴露容器元素的内部细节。\r\n\r\n我们有存储标量基本值的集合，也有存储Object类型的集合，因为使用了不同的容器，我们访问不同容器的元素要使用不同的迭代方式，这时候如果多个容器都可以提供统一的迭代方式，这对于我们开发者来说，将大大提高工作效率，这时候迭代器模式就可以排上用场了，我们只需要通过类似的迭代方式去访问元素，我们并不关心内部是如何存储的。\r\n\r\n这里有两个注意点:\r\n- 迭代器模式针对的是集合而生的，而不是单个元素\r\n- 容器集合中存储的是相同类型的元素对象\r\n\r\n### 代码\r\n\r\n```php\r\n<?php\r\n\r\n//定义迭代器接口\r\ninterface MYIterator\r\n{\r\n    public function hasNext();\r\n\r\n    public function next();\r\n}\r\n\r\n//定义元素结构\r\nclass Item\r\n{\r\n    private $value;\r\n\r\n    public function __construct($value)\r\n    {\r\n        $this->value = $value;\r\n    }\r\n}\r\n\r\n//定义容器集合的接口\r\ninterface MYList\r\n{\r\n    public function add(Item $item);\r\n\r\n    public function remove(Item $item);\r\n\r\n    public function getIterator();\r\n}\r\n\r\n\r\n\r\nclass ArrayList implements MYList\r\n{\r\n    private $elements = [];\r\n\r\n    public function add(Item $item)\r\n    {\r\n        $this->elements[] = $item;\r\n    }\r\n\r\n    public function remove(Item $item)\r\n    {\r\n        while(($index = array_search($item,$this->elements)) !== false) {\r\n            unset($this->elements[$index]);\r\n        }\r\n        $this->elements = array_values($this->elements);\r\n    }\r\n\r\n    public function getIterator()\r\n    {\r\n        return new ArrayListIterator($this->elements);\r\n    }\r\n}\r\n\r\nclass ArrayListIterator implements MyIterator\r\n{\r\n\r\n    private $position;\r\n\r\n    private $list;\r\n\r\n    public function __construct($data)\r\n    {\r\n        $this->position = 0;\r\n        $this->list = $data;\r\n    }\r\n\r\n    public function hasNext()\r\n    {\r\n        return isset($this->list[$this->position]);\r\n    }\r\n\r\n    public function next()\r\n    {\r\n        $item = $this->list[$this->position];\r\n        $this->position += 1;\r\n        return $item;\r\n    }\r\n}\r\n```\r\n上面我们定义了基本元素Item类、MYList集合接口、ArrayList集合实现、MYIterator迭代器接口以及针对ArrayList的迭代器实现ArrayListIterator类，那我们获取集合内元素的方式就可以像下面一样，而不需要关注集合内部是如何存储的。\r\n\r\n```php\r\n$arrayList = new ArrayList;\r\n\r\n$arrayList->add(new Item(\"111\"));\r\n$arrayList->add(new Item(\"hello\"));\r\n$arrayList->add(new Item(\"json\"));\r\n$arrayList->add(new Item(\"111\"));\r\n$arrayList->add(new Item(\"444\"));\r\n\r\n$iterator = $arrayList->getIterator();\r\nwhile($iterator->hasNext()) {\r\n    var_dump($iterator->next());\r\n}\r\n\r\n$arrayList->remove(new Item(\"111\"));\r\n$iterator = $arrayList->getIterator();//获取arraylist集合的迭代器\r\n\r\n//迭代器遍历集合内元素\r\nwhile($iterator->hasNext()) {\r\n    var_dump($iterator->next());\r\n}\r\n\r\n```\r\n\r\n集合容器可能不同，但是只要集合容器实现了集合MYList接口，并且能够获取正确的迭代器，我们就可以使用hastNext判断还有没有元素，用next方法获取当前元素。上面例子的集合容器是数组方式的，我们再用一个**链表方式**的体会下迭代器的用处:\r\n\r\n```php\r\n<?php\r\n\r\n//定义迭代器接口\r\ninterface MYIterator\r\n{\r\n    public function hasNext();\r\n\r\n    public function next();\r\n}\r\n\r\n//定义元素结构\r\nclass Item\r\n{\r\n    private $value;\r\n\r\n    public function __construct($value)\r\n    {\r\n        $this->value = $value;\r\n    }\r\n}\r\n\r\n//定义容器集合的接口\r\ninterface MYList\r\n{\r\n    public function add(Item $item);\r\n\r\n    public function remove(Item $item);\r\n\r\n    public function getIterator();\r\n}\r\n\r\n\r\n//定义个节点node\r\nclass Node\r\n{\r\n    public $data;\r\n    public $next = null;\r\n\r\n    public function __construct($data = null)\r\n    {\r\n        $this->data = $data;\r\n    }\r\n}\r\n\r\n\r\nclass LinkedList implements MYList\r\n{\r\n    private $head;\r\n    private $size;\r\n\r\n    public function __construct() \r\n    {\r\n        $this->head = new Node();\r\n        $this->size = 0;\r\n    }\r\n\r\n    public function add(Item $item)\r\n    {\r\n        $prev = $this->head;\r\n        while($prev->next) {\r\n            $prev = $prev->next;\r\n        }\r\n        $prev->next = new Node($item);\r\n    }\r\n\r\n    public function remove(Item $item)\r\n    {\r\n        $prev = $this->head;\r\n        while($prev->next) {\r\n            if($prev->next && $prev->next->data == $item) {\r\n                if($prev->next->next) {\r\n                    $prev->next = $prev->next->next;\r\n                } else {\r\n                    $prev->next = null;\r\n                }\r\n            }\r\n            $prev = $prev->next;\r\n        }\r\n    }\r\n\r\n    public function getIterator()\r\n    {\r\n        return new LinkedListIterator($this->head);\r\n    }\r\n}\r\n\r\nclass LinkedListIterator implements MyIterator\r\n{\r\n\r\n    private $prev;\r\n\r\n    public function __construct($head)\r\n    {\r\n        $this->prev = $head;\r\n    }\r\n\r\n    public function hasNext()\r\n    {\r\n        return (bool)$this->prev->next;\r\n    }\r\n\r\n    public function next()\r\n    {\r\n        $item = $this->prev->next->data;\r\n        $this->prev = $this->prev->next;\r\n        return $item;\r\n    }\r\n}\r\n```\r\n\r\n使用方式如下:\r\n```php\r\n$arrayList = new LinkedList;\r\n\r\n$arrayList->add(new Item(\"111\"));\r\n$arrayList->add(new Item(\"hello\"));\r\n$arrayList->add(new Item(\"json\"));\r\n$arrayList->add(new Item(\"111\"));\r\n$arrayList->add(new Item(\"444\"));\r\n\r\n$iterator = $arrayList->getIterator();\r\nwhile($iterator->hasNext()) {\r\n    var_dump($iterator->next());\r\n}\r\n\r\n$arrayList->remove(new Item(\"444\"));\r\n$iterator = $arrayList->getIterator();\r\nwhile($iterator->hasNext()) {\r\n    var_dump($iterator->next());\r\n}\r\n\r\n```\r\n你应该发现了，使用方式上，除了使用的容器集合不一样，其它代码一模一样，特别是遍历元素的方式，这就是迭代器模式带来的好处。\r\n\r\n### php内置迭代器\r\n\r\nphp本身内置了迭代器接口，只要我们实现了这个接口，就可以迭代遍历实现迭代器的集合对象了。\r\n```php\r\nIterator extends Traversable {\r\n    /* Methods */\r\n    abstract public current ( void ) : mixed\r\n    abstract public key ( void ) : scalar\r\n    abstract public next ( void ) : void\r\n    abstract public rewind ( void ) : void\r\n    abstract public valid ( void ) : bool\r\n}\r\n```\r\n\r\n我们尝试把我们上面例子中的迭代器接口以及实现，换成php内置的Iterator。\r\n```php\r\n<?php\r\n\r\n//定义元素结构\r\nclass Item\r\n{\r\n    private $value;\r\n\r\n    public function __construct($value)\r\n    {\r\n        $this->value = $value;\r\n    }\r\n}\r\n\r\n//定义容器集合的接口\r\ninterface MYList\r\n{\r\n    public function add(Item $item);\r\n\r\n    public function remove(Item $item);\r\n\r\n    public function getIterator();\r\n}\r\n\r\n\r\n\r\nclass ArrayList implements MYList\r\n{\r\n    private $elements = [];\r\n\r\n    public function add(Item $item)\r\n    {\r\n        $this->elements[] = $item;\r\n    }\r\n\r\n    public function remove(Item $item)\r\n    {\r\n        while(($index = array_search($item,$this->elements)) !== false) {\r\n            unset($this->elements[$index]);\r\n        }\r\n        $this->elements = array_values($this->elements);\r\n    }\r\n\r\n    public function getIterator()\r\n    {\r\n        return new ArrayListIterator($this->elements);\r\n    }\r\n}\r\n\r\nclass ArrayListIterator implements Iterator\r\n{\r\n\r\n    private $position;\r\n\r\n    private $list;\r\n\r\n    public function __construct($data)\r\n    {\r\n        $this->position = 0;\r\n        $this->list = $data;\r\n    }\r\n\r\n    public function rewind() {\r\n        $this->position = 0;\r\n    }\r\n\r\n    public function current() {\r\n        return $this->list[$this->position];\r\n    }\r\n\r\n    public function key() {\r\n        return $this->position;\r\n    }\r\n\r\n    public function next() {\r\n        ++$this->position;\r\n    }\r\n\r\n    public function valid() {\r\n        return isset($this->list[$this->position]);\r\n    }\r\n}\r\n```\r\n我们可以发现，除了迭代器接口以及迭代器实现方式换了，其它代码不需要变动，就可以像数组一样使用foreach遍历元素了，也可以使用while方式进行遍历。\r\n\r\n\r\n',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,730,0),(67,'Symfony组件之FileSystem','67',1596856165,1596856165,'<!--markdown-->今天要介绍的是一个操作文件系统的工具包---symfony/filesystem，由Symfony框架提供。\r\n\r\n### 安装\r\n\r\n```shell\r\n composer require symfony/filesystem\r\n```\r\n\r\n### 常用方法\r\n\r\n- mkdir()\r\n\r\n  递归的创建目录，第二个参数设置目录权限，默认777,如果目录已经存在，则会自动忽略`exists`\r\n\r\n  ```php\r\n  <?php\r\n  \r\n  require \'vendor/autoload.php\';\r\n  \r\n  use Symfony\\Component\\Filesystem\\Exception\\IOExceptionInterface;\r\n  use Symfony\\Component\\Filesystem\\Filesystem;\r\n  \r\n  $filesystem = new Filesystem();\r\n  \r\n  try {\r\n      $filesystem->mkdir(\'./test/a/\'.random_int(0, 1000),755);\r\n  } catch (IOExceptionInterface $exception) {\r\n      echo \"An error occurred while creating your directory at \".$exception->getPath();\r\n  }\r\n  ```\r\n\r\n- exists()\r\n\r\n  判断目录或者文件是否存在，可以传多个值，如果有任意一个不存在，则返回false，否则返回true\r\n\r\n  ```php\r\n  $filesystem->exists([\'./test/aa\']);\r\n  ```\r\n\r\n  \r\n\r\n- copy()\r\n\r\n  复制单个文件\r\n\r\n  ```php\r\n  $filesystem->copy(\'./test/a.txt\',\'./a.txt\',true);//强制将test目录下的a.txt复制到当前目录的a.txt文件，如果当前目录已经存在a.txt，则会覆盖\r\n  \r\n  $filesystem->copy(\'./test/a.txt\',\'./a.txt\');//复制test目录的a.txt文件到当前目录，如果当面目录a.txt不存在，或者test/a.txt文件修改时间比当前目录a.txt新，则复制成功\r\n  ```\r\n\r\n  \r\n\r\n  \r\n\r\n- touch()创建文件\r\n\r\n  ```php\r\n  $filesystem->touch(\'file.txt\');\r\n  ```\r\n\r\n- chown()修改所有者\r\n\r\n  ```php\r\n  $filesystem->chown(\'file.txt\',\'www\');\r\n  ```\r\n\r\n- chmod()修改权限\r\n\r\n  ```php\r\n  $filesystem->chmod(\'file.txt\',700);\r\n  ```\r\n\r\n- remove()\r\n\r\n  删除文件、目录、快捷方式\r\n\r\n  ```php\r\n  $filesystem->remove([\"file.txt\",\"test\"]);//删除file.txt文件以及test目录\r\n  ```\r\n\r\n- rename()\r\n\r\n  重命名文件或者目录\r\n\r\n  ```php\r\n  $filesystem->touch(\'file.txt\');\r\n  $filesystem->rename(\"file.txt\",\"hello.txt\");//file.txt重命名为hello.txt\r\n  ```\r\n\r\n- symlink()\r\n\r\n  创建快捷方式\r\n\r\n  ```php\r\n  $filesystem->touch(\'file.txt\');\r\n  $filesystem->symlink(\"file.txt\",\"dd\");//创建file.txt文件的快捷方式dd\r\n  ```\r\n\r\n- makePathRelative()\r\n\r\n  返回相对目录，指的是第一个参数相对于第二个参数的目录\r\n\r\n  ```php\r\n  $filesystem->makePathRelative(\r\n      \'/var/lib/symfony/src/Symfony/\',\r\n      \'/var/lib/symfony/src/Symfony/Component\'\r\n  );//\r\n  \r\n  // returns \'videos/\'\r\n  $filesystem->makePathRelative(\'/tmp/videos\', \'/tmp\')\r\n  ```\r\n\r\n- mirror()\r\n\r\n  复制目录内所有子目录以及文件\r\n\r\n  ```php\r\n  $filesystem->mirror(\'./vendor\',\'./test\');//将vendor目录内容备份到test目录\r\n  ```\r\n\r\n- isAbsolutePath()\r\n\r\n  判断是否绝对路径\r\n\r\n  ```php\r\n  $filesystem->isAbsolutePath(\"/opt/lampp\");\r\n  ```\r\n\r\n- tempnam()\r\n\r\n  创建文件名唯一的临时文件,并返回文件名\r\n\r\n  ```php\r\n  // returns a path like : /tmp/prefix_wyjgtF\r\n  $filesystem->tempnam(\'/tmp\', \'prefix_\');\r\n  // returns a path like : /tmp/prefix_wyjgtF.png\r\n  $filesystem->tempnam(\'/tmp\', \'prefix_\', \'.png\');\r\n  ```\r\n\r\n- dumpFile()\r\n\r\n  保存文件内容\r\n\r\n  ```php\r\n  $filesystem->dumpFile(\'file.txt\', \'Hello World\');//file.txt内容变成了Hello World\r\n  ```\r\n\r\n- appendToFile()\r\n\r\n  在原有文件末尾追加文件内容\r\n\r\n  ```php\r\n  $filesystem->appendToFile(\'file.txt\', \'append hello world\');\r\n  ```\r\n\r\n  ',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,740,0),(68,'又一个获取.env文件配置的库','68',1597328460,1597328670,'<!--markdown-->### 前言\r\n\r\n有一个星期没有给大家做分享了，今天要分享的是一个加载.env文件配置的库，这是出自symfony框架的一款库，[symfony/dotenv](https://github.com/symfony/dotenv)。不知道大家有没有看过之前我的博文，关于[vlucas/phpdotenv](https://github.com/vlucas/phpdotenv)的，他们的作用是一样的，都是加载.env中的配置项。\r\n\r\n### 安装\r\n\r\n```php\r\ncomposer require symfony/dotenv\r\n```\r\n\r\n### 实例代码\r\n\r\n```php\r\n<?php\r\n\r\nrequire \'vendor/autoload.php\';\r\n\r\nuse Symfony\\Component\\Dotenv\\Dotenv;\r\n\r\n$dotenv = new Dotenv();\r\n\r\n$dotenv->load(__DIR__.\'/.env\');\r\n\r\nvar_dump($_SERVER[\'DB_NAME\'],$_ENV[\'DB_NAME\'],getenv(\'DB_NAME\'));\r\n```\r\n\r\n### 说明\r\n\r\n这个库的作用是解析.env文件的配置变量到$_SERVER、$_ENV。\r\n\r\n- load()\r\n\r\n  解析配置到$_SERVER、$_ENV，如果配置在$_SERVER、$_ENV已经存在，则不会覆盖。\r\n\r\n  ```shell\r\n  //.env内容\r\n  DB_NAME=localhost\r\n  ```\r\n\r\n  ```php\r\n  $_SERVER[\'DB_NAME\'] = \'test\';//模拟$_SERVER已经存在的变量\r\n  $dotenv->load(__DIR__.\'/.env\');\r\n  \r\n  var_dump($_SERVER[\'DB_NAME\']);//输出string(4) \"test\"\r\n  ```\r\n\r\n- overload()\r\n\r\n  解析配置到$_SERVER、$_ENV，如果配置在$_SERVER、$_ENV已经存在，则会进行覆盖。\r\n\r\n  ```php\r\n  $_SERVER[\'DB_NAME\'] = \'test\';\r\n  $dotenv->overload(__DIR__.\'/.env\');\r\n  \r\n  var_dump($_SERVER[\'DB_NAME\']);//输出string(9) \"localhost\"\r\n  ```\r\n\r\n- 支持多文件载入\r\n\r\n  ```php\r\n  $dotenv->load(__DIR__.\'/.env.local\',__DIR__.\'/.env\');//如果配置已经存在则不会使用配置文件里的配置，如果不存在则后面的会覆盖前面的配置\r\n  ```\r\n\r\n  配置文件内容,下面的讲解说明都是假设配置文件内容是这个\r\n\r\n  ```shell\r\n  //.env内容\r\n  DB_NAME=localhost\r\n  DB_USER=.env\r\n  \r\n  //.env.local内容\r\n  DB_NAME=127.0.0.1\r\n  ```\r\n\r\n  php文件内容:\r\n\r\n  ```php\r\n  $dotenv->load(__DIR__.\'/.env.local\',__DIR__.\'/.env\');\r\n  var_dump($_SERVER[\'DB_NAME\']);//string(9) \"localhost\"\r\n  var_dump($_SERVER[\'DB_USER\']);//string(4) \".env\"\r\n  ```\r\n\r\n  ```php\r\n  $_SERVER[\'DB_NAME\'] = \'test\';\r\n  $dotenv->load(__DIR__.\'/.env.local\',__DIR__.\'/.env\');\r\n  \r\n  var_dump($_SERVER[\'DB_NAME\']);//string(4) \"test\"\r\n  var_dump($_SERVER[\'DB_USER\']);//string(4) \".env\"\r\n  ```\r\n\r\n  可以得出结论，当多文件load时，如果配置已经存在则不会覆盖，如果配置不存在，则多文件里面后面的配置会覆盖前面的配置。\r\n\r\n  ```php\r\n  $dotenv->overLoad(__DIR__.\'/.env.local\',__DIR__.\'/.env\');\r\n  \r\n  var_dump($_SERVER[\'DB_NAME\']);//string(9) \"localhost\"\r\n  var_dump($_SERVER[\'DB_USER\']);//string(4) \".env\"\r\n  ```\r\n\r\n  调用overLoad方法时，多文件中后面文件的配置变量值总是覆盖前面的配置值。\r\n\r\n- loadEnv()\r\n\r\n  按照.env、 .env.local、.env.$APP_ENV.local和.env.$APP_ENV的顺序从配置文件加载配置。\r\n\r\n  ```php\r\n  $dotenv->loadEnv(__DIR__.\'/.env\');\r\n  \r\n  var_dump($_SERVER[\'DB_NAME\']);//string(9) \"127.0.0.1\"\r\n  var_dump($_SERVER[\'DB_USER\']);//string(4) \".env\"\r\n  ```\r\n\r\n- usePutenv()\r\n\r\n  使用usePutenv后，可以使用getenv函数获取$_SERVER、或者$\\_ENV里面的配置项\r\n\r\n  ```php\r\n  $dotenv->usePutenv();\r\n  $dotenv->loadEnv(__DIR__.\'/.env\');\r\n  \r\n  //string(9) \"127.0.0.1\"  string(9) \"127.0.0.1\"\r\n  var_dump($_SERVER[\'DB_NAME\'],getenv(\'DB_NAME\'));\r\n  //string(4) \".env\"  string(4) \".env\"\r\n  var_dump($_SERVER[\'DB_USER\'],getenv(\'DB_USER\'));\r\n  ```\r\n\r\n  ```php\r\n  //$dotenv->usePutenv();\r\n  $dotenv->loadEnv(__DIR__.\'/.env\');\r\n  //string(9) \"127.0.0.1\"   bool(false)\r\n  var_dump($_SERVER[\'DB_NAME\'],getenv(\'DB_NAME\'));\r\n  //string(4) \".env\"   bool(false)\r\n  var_dump($_SERVER[\'DB_USER\'],getenv(\'DB_USER\'));\r\n  ```\r\n\r\n  我们可以看到，没有使用usePutenv()方法时，getenv获取不到$_SERVER以及加载到$_SERVER里面的配置变量',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,758,0),(69,'设计模式之模板方法模式','69',1597381641,1597381641,'<!--markdown-->### 定义\r\n\r\n模板方法定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。\r\n\r\n通俗的说，模板方法定义算法的大逻辑，具体细节由子类完成。举例来说，比如盖房子，模板方法定义可以定义盖房子的关键步骤，先打地基、然后盖墙壁，然后嵌入门窗，最后搭房顶等，而具体的实现可以交给子类，子类怎么打地基，怎么盖墙壁，父类并不关心。\r\n\r\n### 结构\r\n- 抽象类：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下：\r\n\r\n    - 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。为防止恶意操作，一般模板方法都加上 final 关键词\r\n    - 基本方法：是整个算法中的一个步骤，包含以下几种类型:\r\n        - 抽象方法：在抽象类中申明，由具体子类实现。\r\n        - 具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。\r\n        - 钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种\r\n\r\n- 具体子类：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。\r\n\r\n### 代码实现\r\n\r\n```php\r\n<?php\r\n\r\nabstract class Excel\r\n{\r\n    abstract function getTitle();//抽象方法\r\n\r\n    abstract public function getFooter();//抽象方法\r\n\r\n    abstract public function getBody();//抽象方法\r\n\r\n    public function haveFooter()//钩子方法\r\n    {\r\n        return false;\r\n    }\r\n\r\n    public function getSheetName()//具体方法\r\n    {\r\n        echo \"输出sheet名称\";\r\n    }\r\n\r\n    public function handle() {//模板方法\r\n        $this->getSheetName();\r\n        $this->getTitle();\r\n        $this->getBody();\r\n        if($this->haveFooter())\r\n        {\r\n            $this->getFooter();\r\n        }\r\n    }\r\n}\r\n\r\n\r\nclass OrderExcel extends Excel\r\n{\r\n    public function getTitle()\r\n    {\r\n        echo \"OrderExcel的title\";\r\n    }\r\n\r\n    public function getBody()\r\n    {\r\n        echo \"OrderExcel的body\";\r\n    }\r\n\r\n    public function getFooter()\r\n    {\r\n    }\r\n}\r\n\r\nclass UserExcel extends Excel\r\n{\r\n    public function getTitle()\r\n    {\r\n        echo \"UserExcel的title\";\r\n    }\r\n\r\n    public function getBody()\r\n    {\r\n        echo \"UserExcel的body\";\r\n    }\r\n\r\n    public function getFooter()\r\n    {\r\n        echo \"UserExcel的footer\";\r\n    }\r\n\r\n    public function haveFooter()\r\n    {\r\n        return true;\r\n    }\r\n}\r\n```\r\n使用方法\r\n```php\r\n$orderExcel = new OrderExcel;\r\n$orderExcel->handle();\r\n\r\n$orderExcel = new UserExcel;\r\n$orderExcel->handle();\r\n```\r\n我们可以看到\r\n- 模板方法handle()规定了大的行为，具体的实现由子类完成；\r\n- 抽象类的getTitle()、getFooter()、getBody()抽象方法由子类实现，实现具体的细节；\r\n- 钩子方法haveFooter()用于判断是否需要getFooter()方法，每一个子类可以根据自己的业务是否需要\r\ngetFooter()去重写钩子方法；\r\n- getSheetName()作为逻辑中的一个小环节，由抽象类实现，具体子类可以进行重写，也可以不重写。\r\n\r\n模板方法提供了一个骨架的基本算法，子类不需要关注骨架的前后逻辑，只需要实现每一个细节抽象类即可。有时候模板方法会要求子类按照一定的规范，去在每一步返回固定格式的数据，便于模板方法拿到数据，进行业务处理。大体如下:\r\n```php\r\n<?php\r\n\r\nabstract class Excel\r\n{\r\n    protected $body;\r\n    \r\n    abstract function getTitle();//抽象方法\r\n\r\n    abstract public function getFooter();//抽象方法\r\n\r\n    abstract public function getBody();//抽象方法\r\n\r\n    public function haveFooter()//钩子方法\r\n    {\r\n        return false;\r\n    }\r\n\r\n    public function getSheetName()//具体方法\r\n    {\r\n        echo \"输出sheet名称\";\r\n    }\r\n\r\n    public function handle() {//模板方法\r\n        $this->getSheetName();\r\n        echo \"我获取的title内容:\".$this->getTitle();\r\n        $this->getBody();\r\n        echo \"我拿到了body数据:\".$this->body;\r\n        if($this->haveFooter())\r\n        {\r\n            //我不关心getFooter的返回结果\r\n            $this->getFooter();\r\n        }\r\n    }\r\n}\r\n\r\n\r\nclass UserExcel extends Excel\r\n{\r\n    public function getTitle()\r\n    {\r\n        return \"UserExcel的title\";\r\n    }\r\n\r\n    public function getBody()\r\n    {\r\n        $this->body = \'this is body\';\r\n    }\r\n\r\n    public function getFooter()\r\n    {\r\n        return \"UserExcel的footer\";\r\n    }\r\n\r\n    public function haveFooter()\r\n    {\r\n        return true;\r\n    }\r\n}\r\n```\r\n### 优缺点\r\n优点:\r\n- 它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。\r\n- 它在父类中提取了公共的部分代码，便于代码复用。\r\n- 部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。\r\n\r\n缺点:\r\n- 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。\r\n- 按照设计习惯，抽象类负责声明最抽象、最一般的事务属性和方法，实现类负责完成具体的事务属性和方法，但是模板方法正好相反，子类执行的结果影响了父类的结果，会增加代码阅读的难度',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,809,0),(70,'php库推荐之fractal','70',1597478160,1597541937,'<!--markdown-->### 前言\r\n\r\n今天推荐的这个库叫`league/fractal`，用途是在源数据和响应结果之间提供一种转换方式。\r\n\r\n### 优点\r\n\r\n- Fractal 为复杂的数据输出提供了一个表示和转换层，为表示层提供固定的数据结构，提高代码的复杂度。\r\n\r\n- 当表示层或者api接口开发需要部分字段时，会大量使用循环，去组装响应的结果数据，使用Fractal可以避免代码中循环。\r\n\r\n- Fractal将源数据转换成固定的数据结构，这样源数据有字段增删时，不会影响表示层的数据结构。\r\n- 有时候返回表示层的数据可能来源于多个数据源，或者嵌套关系，使用Fractal可以拆分逻辑，降低代码复杂度\r\n\r\n### 安装方式\r\n\r\n```shell\r\ncomposer require league/fractal\r\n```\r\n\r\n### 代码示例\r\n\r\n```php\r\n<?php\r\n\r\nrequire \'vendor/autoload.php\';\r\n\r\nuse League\\Fractal\\Manager;\r\nuse League\\Fractal\\Resource\\Collection;\r\n\r\n// Create a top level instance somewhere\r\n$fractal = new Manager();\r\n\r\n//原始数据\r\n$userlist = [\r\n	[\r\n		\'user_id\'   => \'1\',\r\n		\'name\'      => \'Json\',\r\n		\'email\'     => \'fanqingxuan@163.com\',\r\n		\'age\'       => 32,\r\n	],\r\n	[\r\n		\'user_id\'   => \'2\',\r\n		\'name\'      => \'范先生\',\r\n		\'email\'     => \'json@163.com\',\r\n		\'age\'       => 29,\r\n	]\r\n];\r\n\r\n$resource = new Collection($userlist, function(array $user) {\r\n    return [\r\n        \'id\'            => (int) $user[\'user_id\'],\r\n        \'username\'      => $user[\'name\'],\r\n        \'email\'         => $user[\'email\'],\r\n        \'other\'         => [\r\n        	\'age\'   => $user[\'age\'],\r\n        ],\r\n        \'url\'           => \"user/\".$user[\'user_id\']\r\n    ];\r\n});\r\n\r\n$array = $fractal->createData($resource)->toArray();\r\n//print_r($array);\r\n// Turn all of that into a JSON string\r\necho $fractal->createData($resource)->toJson();\r\n//输出的是:{\"data\":[{\"id\":1,\"username\":\"Json\",\"email\":\"fanqingxuan@163.com\",\"other\":{\"age\":\r\n32},\"url\":\"user\\/1\"},{\"id\":2,\"username\":\"\\u8303\\u5148\\u751f\",\"email\":\"json@163.c\r\nom\",\"other\":{\"age\":29},\"url\":\"user\\/2\"}]}\r\n```\r\n\r\n我们可以看到输出的结构我们进行了重新规范，可能我们看着代码有些多，不过可以通过使用Transformers类进行简化，简化用法我们稍后再讲。\r\n\r\n### 概念讲解\r\n\r\n- 资源Resources\r\n\r\n  上面的例子中使用了new Collection，这在Fractal里面叫Resources，Resources主要作用是对不同的结构数据进行对象化处理，然后通过使用Transformer或者会掉函数输出固定的结构。Fractal包含两种常用的Resources，就是Item和Collection。\r\n\r\n  - Collection对集合或者List的结构进行对象化处理。\r\n\r\n    上面的源数据userlist是个list所以用Collection\r\n\r\n  - Item用在对一维数组或者单挑记录进行对象化。\r\n\r\n    ```php\r\n    //原始数据\r\n    $userInfo = [\r\n        \'user_id\'   => \'2\',\r\n        \'name\'      => \'范先生\',\r\n        \'email\'     => \'json@163.com\',\r\n        \'age\'       => 29,\r\n    ];\r\n    \r\n    $resource = new Item($userInfo, function(array $user) {\r\n        return [\r\n            \'id\'            => (int) $user[\'user_id\'],\r\n            \'username\'      => $user[\'name\'],\r\n            \'email\'         => $user[\'email\'],\r\n            \'other\'         => [\r\n            	\'age\'   => $user[\'age\'],\r\n            ],\r\n            \'url\'           => \"user/\".$user[\'user_id\']\r\n        ];\r\n    });\r\n    \r\n    $array = $fractal->createData($resource)->toArray();\r\n    print_r($array);\r\n    \r\n    echo $fractal->createData($resource)->toJson();\r\n    ```\r\n\r\n- Serializers\r\n\r\n  Serializer 是以某种方式构建你的转换后的数据。Fractal默认提供了几种不同的Serializer, 这些 Serializers 之间的大多数差异是，如何定义数据的命名空间。Serializer 让我们在 Transformers 上可进行最小的修改，然后在不同的输出格式之间切换。设计Serializer方式如下:\r\n\r\n  ```php\r\n  $fractal->setSerializer(new League\\Fractal\\Serializer\\ArraySerializer);\r\n  ```\r\n\r\n  - DataArraySerializer\r\n\r\n    这是 Fractal 中的默认Serializer，该序列化并不符合每个人的口味，因为它给输出添加了一个 \'data\' 的命名空间。比如上面的结果输出,我们可以看到将结构放到了data域下。\r\n\r\n    ```php\r\n    {\"data\":{\"id\":2,\"username\":\"\\u8303\\u5148\\u751f\",\"email\":\"json@163.com\",\"other\":{\r\n    \"age\":29},\"url\":\"user\\/2\"}}\r\n    ```\r\n\r\n    使用 \'data\' 命名空间，非常适合标准化开发，比如api开发规范通常是把数据放到data下给客户端使用，此外使用data命名空间也可以防止命名冲突，还可以引入其他非data域下的资源。\r\n\r\n  - ArraySerializer\r\n\r\n    如果确实想移除 \'data\' 命名空间，这可以通过使用 ArraySerializer 来实现。除了 移除了\'data\'命名空间之外，跟DataArraySerializer大体相同。这里值得注意的是，Collections 不会移除 \'data\' 命名空间，只有Item会移除。我想Collection不移除可能是考虑到方式跟元数据(meta data)冲突，另外如果移除data命名空间，返回结构可能类似如下,客户端难以获取数据\r\n\r\n    ```jso\r\n    {\"0\":{\"id\":1,\"username\":\"Json\",\"email\":\"fanqingxuan@163.com\",\"other\":{\"age\":32},\r\n    \"url\":\"user\\/1\"},\"1\":{\"id\":2,\"username\":\"\\u8303\\u5148\\u751f\",\"email\":\"json@163.c\r\n    om\",\"other\":{\"age\":29},\"url\":\"user\\/2\"},\"meta\":[]}\r\n    ```\r\n\r\n  - 自定义 Serializers\r\n\r\n    我们可以继承SerializerAbstract抽象类来定义自己的Serializers。\r\n\r\n    ```php\r\n    $manager->setSerializer(new CustomSerializer());//使用自定义Serializers，进行数据序列化\r\n    ```\r\n\r\n- Transformer\r\n\r\n  Transformer定义数据的结构，有回调和使用Transformer类两种方式\r\n\r\n  - 回调\r\n\r\n    在某些情况下，使用这种方式是比较便捷的。上面我们使用了回调，类似下面的代码\r\n\r\n  ```php\r\n  new Collection($userlist, function(array $user) {\r\n      return [\r\n          \'id\'            => (int) $user[\'user_id\'],\r\n          \'username\'      => $user[\'name\'],\r\n          \'email\'         => $user[\'email\'],\r\n          \'other\'         => [\r\n          	\'age\'   => $user[\'age\'],\r\n          ],\r\n          \'url\'           => \"user/\".$user[\'user_id\']\r\n      ];\r\n  });\r\n  ```\r\n\r\n  - 定义Transformer类\r\n\r\n    大多数数据需要在多个位置进行多次转换, 因此创建 Transformer类的方式，可以减少代码重复，便于代码复用，同时也可以简化业务层代码量。\r\n\r\n    Transformer类必须继承 League\\Fractal\\TransformerAbstract，并且至少实现方法 transform() ;\r\n\r\n    我们将上面的代码改成Transformer类方式,Transformer类大概如下:\r\n\r\n    ```php\r\n    class UserTransformer extends League\\Fractal\\TransformerAbstract\r\n    {\r\n        public function transform(array $userInfo)\r\n        {\r\n            return [\r\n                \'id\'            => (int) $userInfo[\'user_id\'],\r\n                \'username\'      => $userInfo[\'name\'],\r\n                \'email\'         => $userInfo[\'email\'],\r\n                \'other\'         => [\r\n                    \'age\'   => $userInfo[\'age\'],\r\n                ],\r\n                \'url\'           => \"user/\".$userInfo[\'user_id\']\r\n            ];\r\n        }\r\n        \r\n    }\r\n    ```\r\n\r\n    我们可以看到将回调函数的数据结构定义封装到了transform方法里面，一旦 Transformer 类被定义，就可以将其作为实例，传递给 resource 构造函数，如下代码:\r\n\r\n    ```php\r\n    $resource = new Collection($userlist, new UserTransformer);\r\n    $array = $fractal->createData($resource)->toArray();\r\n    ```\r\n\r\n### 高级玩法\r\n\r\n通过上面的概念讲解，其实已经把Fractal的基本使用方式说了一遍，那我们下面讲下引入数据的用法，比如我们返回的结构可能是用户list，然后用户下面又有文章列表的情况，我们也想规范化输出。\r\n\r\n常规的方法，在回调或者transform方法里面进行循环结构化，如下使用方式:\r\n\r\n```php\r\n<?php\r\n\r\nrequire \'vendor/autoload.php\';\r\n\r\nuse League\\Fractal\\Manager;\r\nuse League\\Fractal\\Resource\\Collection;\r\n\r\n// Create a top level instance somewhere\r\n$fractal = new Manager();\r\n\r\n//原始数据\r\n$userlist = [\r\n	[\r\n		\'user_id\'   => \'1\',\r\n		\'name\'      => \'Json\',\r\n		\'email\'     => \'fanqingxuan@163.com\',\r\n		\'age\'       => 32,\r\n        \'list\'      =>  [\r\n            [\r\n                \'id\'    =>  1,\r\n                \'title\' =>  \'文章1\',\r\n                \'text\'  =>  \'文章1内容\',\r\n                \'status\'=>  1\r\n            ],\r\n            [\r\n                \'id\'    =>  2,\r\n                \'title\' =>  \'文章2\',\r\n                \'text\'  =>  \'文章2内容\',\r\n                \'status\'=>  0\r\n            ]\r\n        ]\r\n	],\r\n	[\r\n		\'user_id\'   => \'2\',\r\n		\'name\'      => \'范先生\',\r\n		\'email\'     => \'json@163.com\',\r\n		\'age\'       => 29,\r\n        \'list\'      =>  [\r\n            [\r\n                \'id\'    =>  3,\r\n                \'title\' =>  \'文章3\',\r\n                \'text\'  =>  \'文章3内容\',\r\n                \'status\'=>  1\r\n            ],\r\n            [\r\n                \'id\'    =>  4,\r\n                \'title\' =>  \'文章4\',\r\n                \'text\'  =>  \'文章4内容\',\r\n                \'status\'=>  1\r\n            ]\r\n        ]\r\n	]\r\n];\r\n\r\nclass UserTransformer extends League\\Fractal\\TransformerAbstract\r\n{\r\n    public function transform(array $userInfo)\r\n    {\r\n        $info = [\r\n            \'id\'            => (int) $userInfo[\'user_id\'],\r\n            \'username\'      => $userInfo[\'name\'],\r\n            \'email\'         => $userInfo[\'email\'],\r\n        ];\r\n        foreach($userInfo[\'list\'] as $post) {\r\n            $info[\'posts\'][] = [\r\n                \'post_id\'   =>  $post[\'id\'],\r\n                \'title\'     =>  $post[\'title\']\r\n            ];\r\n        }\r\n        return $info;\r\n    }\r\n    \r\n}\r\n\r\n$resource = new Collection($userlist, new UserTransformer);\r\n\r\n$array = $fractal->createData($resource)->toArray();\r\n\r\nprint_r($array);\r\n```\r\n\r\n上面的代码不是不可以，但是难免感觉有些臃肿，达不到复用效果。Fractal为我们提供了更好的方式，避免显示for循环，使用include方式，如下代码:\r\n\r\n```php\r\n<?php\r\n\r\nrequire \'vendor/autoload.php\';\r\n\r\nuse League\\Fractal\\Manager;\r\nuse League\\Fractal\\Resource\\Collection;\r\n\r\n// Create a top level instance somewhere\r\n$fractal = new Manager();\r\n\r\n//原始数据\r\n$userlist = [\r\n	[\r\n		\'user_id\'   => \'1\',\r\n		\'name\'      => \'Json\',\r\n		\'email\'     => \'fanqingxuan@163.com\',\r\n		\'age\'       => 32,\r\n        \'list\'      =>  [\r\n            [\r\n                \'id\'    =>  1,\r\n                \'title\' =>  \'文章1\',\r\n                \'text\'  =>  \'文章1内容\',\r\n                \'status\'=>  1\r\n            ],\r\n            [\r\n                \'id\'    =>  2,\r\n                \'title\' =>  \'文章2\',\r\n                \'text\'  =>  \'文章2内容\',\r\n                \'status\'=>  0\r\n            ]\r\n        ]\r\n	],\r\n	[\r\n		\'user_id\'   => \'2\',\r\n		\'name\'      => \'范先生\',\r\n		\'email\'     => \'json@163.com\',\r\n		\'age\'       => 29,\r\n        \'list\'      =>  [\r\n            [\r\n                \'id\'    =>  3,\r\n                \'title\' =>  \'文章3\',\r\n                \'text\'  =>  \'文章3内容\',\r\n                \'status\'=>  1\r\n            ],\r\n            [\r\n                \'id\'    =>  4,\r\n                \'title\' =>  \'文章4\',\r\n                \'text\'  =>  \'文章4内容\',\r\n                \'status\'=>  1\r\n            ]\r\n        ]\r\n	]\r\n];\r\n\r\nclass PostTransformer extends League\\Fractal\\TransformerAbstract\r\n{\r\n                    \r\n    public function transform(array $post)\r\n    {\r\n        return [\r\n            \'post_id\'   =>  $post[\'id\'],\r\n             \'title\'    =>  $post[\'title\']\r\n        ];\r\n    }\r\n    \r\n}\r\n\r\nclass UserTransformer extends League\\Fractal\\TransformerAbstract\r\n{\r\n    protected $defaultIncludes = [\"posts\"];\r\n                    \r\n    public function transform(array $userInfo)\r\n    {\r\n        return [\r\n            \'id\'            => (int) $userInfo[\'user_id\'],\r\n            \'username\'      => $userInfo[\'name\'],\r\n            \'email\'         => $userInfo[\'email\'],\r\n        ];\r\n    }\r\n    \r\n    public function includePosts($userInfo)\r\n    {\r\n        $posts = $userInfo[\'list\'];\r\n        return $this->collection($posts,new PostTransformer);\r\n    }\r\n    \r\n}\r\n\r\n$resource = new Collection($userlist, new UserTransformer);\r\n\r\n$array = $fractal->createData($resource)->toJSON();\r\n\r\nprint_r($array);\r\n```\r\n\r\n我们可以看到将post相关的结构，抽离成了一个PostTransformer类，这样不仅简化代码，同时可以复用。另外在\r\n\r\nUserTransformer定义了一个includePosts方法，这里注意注意的是:\r\n\r\n- includePosts是一种magic写法，方法规则是includeXXX，引入数据的资源命名空间就是xxx，例如includePost则引入数据的顶级命名空间就是posts，如下:\r\n\r\n  ```php\r\n  {\"data\":[{\"id\":1,\"username\":\"Json\",\"email\":\"fanqingxuan@163.com\",\"posts\":{\"data\":[{\"post_id\":1,\"title\":\"\\u6587\\u7ae01\"},{\"post_id\":2,\"title\":\"\\u6587\\u7ae02\"}]}},{\"id\":2,\"username\":\"\\u8303\\u514\r\n  8\\u751f\",\"email\":\"json@163.com\",\"posts\":{\"data\":[{\"post_id\":3,\"title\":\"\\u6587\\u7ae03\"},{\"post_id\":4,\"title\":\"\\u6587\\u7ae04\"}]}}]}\r\n  ```\r\n\r\n  \r\n\r\n- 引入数据的Transformer需要定义$defaultIncludes属性，这个属性是一个数组。定义了includeXxx方法，若该属性中添加了xxx，则生成的最终结构就会包含顶级命名空间是xxx的资源。如上代码中的\r\n\r\n  ```php\r\n  protected $defaultIncludes = [\'posts\'];\r\n  ```\r\n\r\n  \r\n\r\n- $defaultIncludes是一个默认include的方式，若定义了includeXxx方法，返回结构就会包含默认资源的结构。Fractal提供了可选的方式，即可以动态设置是否返回引入数据资源，这个需要在Transformer的继承类里面使用$availableIncludes定义可用的资源，然后使用parseIncludes方法解析需要展示的资源，举例如下:\r\n\r\n  ```php\r\n  class UserTransformer extends League\\Fractal\\TransformerAbstract\r\n  {\r\n      protected $availableIncludes = [\'posts\'];//可引入的资源\r\n                      \r\n      public function transform(array $userInfo)\r\n      {\r\n          return [\r\n              \'id\'            => (int) $userInfo[\'user_id\'],\r\n              \'username\'      => $userInfo[\'name\'],\r\n              \'email\'         => $userInfo[\'email\'],\r\n          ];\r\n      }\r\n      \r\n      public function includePosts($userInfo)//可用资源的方法includeXxx\r\n      {\r\n          $posts = $userInfo[\'list\'];\r\n          return $this->collection($posts,new PostTransformer);\r\n      }\r\n      \r\n  }\r\n  \r\n  $resource = new Collection($userlist, new UserTransformer);\r\n  \r\n  $array = $fractal->createData($resource)->toJSON();\r\n  print_r($array);\r\n  $fractal->parseIncludes(\'posts\');//解析要引入的资源\r\n  $array = $fractal->createData($resource)->toJSON();\r\n  print_r($array);\r\n  ```\r\n\r\n  输出结果如下,没有使用parseIncludes()方法时,即使定义了$availableIncludes属性，也不会不包含引用的资源。\r\n\r\n  ```php\r\n  {\"data\":[{\"id\":1,\"username\":\"Json\",\"email\":\"fanqingxuan@163.com\"},{\"id\":2,\"username\":\"\\u8303\\u5148\\u751f\",\"email\":\"json@163.com\"}]}\r\n  ```\r\n\r\n  ```php\r\n  {\"data\":[{\"id\":1,\"username\":\"Json\",\"email\":\"fanqingxuan@163.com\",\"posts\":{\"data\":[{\"post_id\":1,\"title\":\"\\u6587\\u7ae01\"},{\"post_id\":2,\"title\":\"\\u6587\\u7ae02\"}]}},{\"id\":2,\"username\":\"\\u8303\\u514\r\n  8\\u751f\",\"email\":\"json@163.com\",\"posts\":{\"data\":[{\"post_id\":3,\"title\":\"\\u6587\\u7ae03\"},{\"post_id\":4,\"title\":\"\\u6587\\u7ae04\"}]}}]}\r\n  ```\r\n\r\n  **注意:parseIncludes方法支持引入多个资源,用逗号分开,也支持数组**\r\n\r\n  ```php\r\n  $fractal->parseIncludes(\'posts,order\');\r\n  $fractal->parseIncludes([\'posts\',\'order\']);\r\n  ```\r\n\r\n### 代码封装\r\n\r\n上面我们就把Fractal的用法讲完了，为了更好的熟悉，以及灵活应用，笔者特意做了一个封装的demo，大家可以尝试用用\r\n\r\n- 安装\r\n\r\n  ```php\r\n  composer require fanqingxuan/presenter\r\n  ```\r\n\r\n- 使用\r\n\r\n  ```php\r\n  require \'vendor/autoload.php\';\r\n  \r\n  use Json\\TransformerAbstract;\r\n  use Json\\Presenter;\r\n  \r\n  class BookTransformer extends TransformerAbstract\r\n  {\r\n      public function transform($book)\r\n      {\r\n          return [\r\n              \'id\'      => (int) $book[\'id\'],\r\n              \'title\'   => $book[\'title\'],\r\n              \'year\'    => (int) $book[\'yr\'],\r\n          ];\r\n      }\r\n  }\r\n  \r\n  $presenter = new Presenter();\r\n  \r\n  //模拟源数据\r\n  $books =[\r\n          \'id\' => \'1\',\r\n          \'title\' => \'Hogfather\',\r\n          \'yr\' => \'1998\',\r\n          \'author_name\' => \'Philip K Dick\',\r\n          \'author_email\' => \'philip@example.org\',\r\n      ];\r\n  $data = $presenter->transform($books,new BookTransformer(),false);//不包含引用资源,输出单记录结构\r\n  ```\r\n\r\n  输出结果\r\n\r\n  ```shell\r\n  Array\r\n  (\r\n      [id] => 1\r\n      [title] => Hogfather\r\n      [year] => 1998\r\n  )\r\n  ```\r\n\r\n- 说明\r\n\r\n  - 输出单记录结构\r\n\r\n    ```php\r\n    //模拟源数据\r\n    $books =[\r\n            \'id\' => \'1\',\r\n            \'title\' => \'Hogfather\',\r\n            \'yr\' => \'1998\',\r\n            \'author_name\' => \'Philip K Dick\',\r\n            \'author_email\' => \'philip@example.org\',\r\n        ];\r\n    $data = $presenter->transform($books,new BookTransformer(),false);//不包含引用资源,输出单 ```\r\n    **注意transform第三个参数是false，表示数据源是单记录结构**\r\n  - 输出单记录结构，且结构引入其他资源\r\n    - 方式一\r\n	```php\r\n      //定义transformer\r\n      class LinkTransformer extends TransformerAbstract\r\n      {\r\n          public function transform($book)\r\n          {\r\n              return [\r\n                  \'rel\' => \'self\',\r\n                   \'uri\' => \'/books/\'.$book[\'id\'],\r\n              ];\r\n          }\r\n      }   \r\n      class BookTransformer extends TransformerAbstract\r\n      {\r\n          /**\r\n           * List of resources possible to include\r\n           *\r\n           * @var array\r\n           */\r\n          protected $availableIncludes = [\r\n              \'links\'\r\n          ];\r\n		  \r\n          public function transform($book)\r\n          {\r\n              return [\r\n                  \'id\'      => (int) $book[\'id\'],\r\n                  \'title\'   => $book[\'title\'],\r\n                  \'year\'    => (int) $book[\'yr\'],\r\n              ];\r\n          }\r\n      \r\n          public function includeLinks($book)\r\n          {\r\n              return $this->item($book,new LinkTransformer);\r\n          }\r\n      }\r\n      \r\n      $presenter = new Presenter();\r\n      \r\n      //模拟源数据\r\n      $books =[\r\n              \'id\' => \'1\',\r\n              \'title\' => \'Hogfather\',\r\n              \'yr\' => \'1998\',\r\n              \'author_name\' => \'Philip K Dick\',\r\n              \'author_email\' => \'philip@example.org\',\r\n          ];\r\n      $data = $presenter->transform($books,new BookTransformer([\'links\']),false);//包含引用记录,输出单记录结构\r\n      print_r($data);\r\n```\r\n\r\n      **Transformer类的构造函数传引用的资源，可以是数组或者字符串** \r\n	- 方式二\r\n      通过Transformer的setAvailableIncludes()方法设置引用的资源，参考可以是数组或者字符串，字符串用逗号区分多个资源。\r\n	```php\r\n      //定义transformer\r\n      class LinkTransformer extends TransformerAbstract\r\n      {\r\n          public function transform($book)\r\n          {\r\n              return [\r\n                  \'rel\' => \'self\',\r\n                   \'uri\' => \'/books/\'.$book[\'id\'],\r\n              ];\r\n          }\r\n      }\r\n\r\n      class BookTransformer extends TransformerAbstract\r\n      {\r\n          /**\r\n           * List of resources possible to include\r\n           *\r\n           * @var array\r\n           */\r\n          protected $availableIncludes = [\r\n              \'links\'\r\n          ];\r\n\r\n          public function transform($book)\r\n          {\r\n              return [\r\n                  \'id\'      => (int) $book[\'id\'],\r\n                  \'title\'   => $book[\'title\'],\r\n                  \'year\'    => (int) $book[\'yr\'],\r\n              ];\r\n          }\r\n      \r\n          public function includeLinks($book)\r\n          {\r\n              return $this->item($book,new LinkTransformer);\r\n          }\r\n      }\r\n      \r\n      $presenter = new Presenter();\r\n      \r\n      //模拟源数据\r\n      $books =[\r\n              \'id\' => \'1\',\r\n              \'title\' => \'Hogfather\',\r\n              \'yr\' => \'1998\',\r\n              \'author_name\' => \'Philip K Dick\',\r\n              \'author_email\' => \'philip@example.org\',\r\n          ];\r\n      \r\n      //包含引用记录,输出单记录结构的另一种方式\r\n      $bookTransformer = new BookTransformer;\r\n      $bookTransformer->setAvailableIncludes(\'links\');\r\n      $data = $presenter->transform($books,$bookTransformer,false);//包含引用记录,输出单记录结构\r\n      print_r($data);\r\n	```\r\n  - 输出集合资源\r\n\r\n    ```php\r\n    require \'vendor/autoload.php\';\r\n    \r\n    use Json\\TransformerAbstract;\r\n    use Json\\Presenter;\r\n    \r\n    class BookTransformer extends TransformerAbstract\r\n    {\r\n        public function transform($book)\r\n        {\r\n            return [\r\n                \'id\'      => (int) $book[\'id\'],\r\n                \'title\'   => $book[\'title\'],\r\n                \'year\'    => (int) $book[\'yr\'],\r\n            ];\r\n        }\r\n    }\r\n    \r\n    $presenter = new Presenter();\r\n    \r\n    //原始数据\r\n    $userlist = [\r\n    	[\r\n    		\'user_id\'   => \'1\',\r\n    		\'name\'      => \'Json\',\r\n    		\'email\'     => \'fanqingxuan@163.com\',\r\n    		\'age\'       => 32,\r\n            \'list\'      =>  [\r\n                [\r\n                    \'id\'    =>  1,\r\n                    \'title\' =>  \'文章1\',\r\n                    \'text\'  =>  \'文章1内容\',\r\n                    \'status\'=>  1\r\n                ],\r\n                [\r\n                    \'id\'    =>  2,\r\n                    \'title\' =>  \'文章2\',\r\n                    \'text\'  =>  \'文章2内容\',\r\n                    \'status\'=>  0\r\n                ]\r\n            ]\r\n    	],\r\n    	[\r\n    		\'user_id\'   => \'2\',\r\n    		\'name\'      => \'范先生\',\r\n    		\'email\'     => \'json@163.com\',\r\n    		\'age\'       => 29,\r\n            \'list\'      =>  [\r\n                [\r\n                    \'id\'    =>  3,\r\n                    \'title\' =>  \'文章3\',\r\n                    \'text\'  =>  \'文章3内容\',\r\n                    \'status\'=>  1\r\n                ],\r\n                [\r\n                    \'id\'    =>  4,\r\n                    \'title\' =>  \'文章4\',\r\n                    \'text\'  =>  \'文章4内容\',\r\n                    \'status\'=>  1\r\n                ]\r\n            ]\r\n    	]\r\n    ];\r\n    \r\n    class PostTransformer extends TransformerAbstract\r\n    {\r\n                        \r\n        public function transform(array $post)\r\n        {\r\n            return [\r\n                \'post_id\'   =>  $post[\'id\'],\r\n                 \'title\'    =>  $post[\'title\']\r\n            ];\r\n        }\r\n        \r\n    }\r\n    \r\n    class UserTransformer extends TransformerAbstract\r\n    {\r\n        protected $availableIncludes = [\'posts\'];\r\n                        \r\n        public function transform(array $userInfo)\r\n        {\r\n            return [\r\n                \'id\'            => (int) $userInfo[\'user_id\'],\r\n                \'username\'      => $userInfo[\'name\'],\r\n                \'email\'         => $userInfo[\'email\'],\r\n            ];\r\n        }\r\n        \r\n        public function includePosts($userInfo)\r\n        {\r\n            $posts = $userInfo[\'list\'];\r\n            return $this->collection($posts,new PostTransformer);\r\n        }\r\n        \r\n    }\r\n    \r\n    $data = $presenter->transform($userlist,new UserTransformer());//不包含引用资源,输出集合结构\r\n    print_r($data);\r\n    ```\r\n\r\n    **注意transform()方法没有专递第三个参数，第三个参数默认为true，表示处理集合**\r\n\r\n  - 输出集合资源，且引用其它资源结构\r\n\r\n    和单资源一样，也有两种方式，两种方式代码如下\r\n\r\n    ```php\r\n    //方式1\r\n    $data = $presenter->transform($userlist,new UserTransformer([\'posts\']));//包含引用记录,输出集合结构\r\n    print_r($data);\r\n    \r\n    //方式2\r\n    //包含引用记录,输出集合结构的另一种方式\r\n    $userTransformer = new UserTransformer;\r\n    $userTransformer->setAvailableIncludes(\'posts\');\r\n    $data = $presenter->transform($userlist,$userTransformer);//包含引用记录,输出集合结构\r\n    print_r($data);\r\n    ```\r\n\r\n如果你对封装的源码感兴趣，可以[点击这里](https://github.com/fanqingxuan/presenter)查看,或者在github搜索[fanqingxuan/presenter](https://github.com/fanqingxuan/presenter)。',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,1106,1),(71,'门面类之Laravel实现','71',1597640640,1597640809,'<!--markdown-->### 前言\r\n\r\n用过Laravel的同学应该都见过类似如下的方法:\r\n```php\r\nCache::get(\"user\");\r\nRoute::get(\"/list\");\r\nDB::table(\"lgt_good\")->where(\'lgid\',2)->get();\r\n```\r\n看到没有不需要new实例，直接使用方法，是不是用起来特别方便。\r\n\r\n###  正文\r\n\r\n也许你认为是调用了类的静态方法，如果你是这么想的，那就大错特错了，可以通过IDE的代码追踪工具看到，每一个门面类都只有一个类似下面的代码，只有一个getFacadeAccessor()受保护的静态方法。\r\n\r\n```php\r\nclass Route extends Facade\r\n{\r\n    /**\r\n     * Get the registered name of the component.\r\n     *\r\n     * @return string\r\n     */\r\n    protected static function getFacadeAccessor()\r\n    {\r\n        return \'router\';\r\n    }\r\n}\r\n```\r\n\r\n其实这种使用方式最关键的一点是实现了`__callStatic`静态方法，这是php内置的一个魔术方法，**当调用类不存在或者没有权限访问的静态方法时会调用**。聪明的同学应该看到了，门面类继承了一个抽象类Facade，可以看到里面确实实现了`__callStatic`静态方法。\r\n\r\n```php\r\npublic static function __callStatic($method, $args)\r\n    {\r\n        $instance = static::getFacadeRoot();\r\n\r\n        if (! $instance) {\r\n            throw new RuntimeException(\'A facade root has not been set.\');\r\n        }\r\n\r\n        return $instance->$method(...$args);\r\n    }\r\n```\r\n到这里其实实现原理已经一目了然了，拿DB门面类举例，DB::table()调用时，门面类DB并不存在静态方法table()于是调用父类的`__callStatic`静态方法,`__callStatic`方法通过调用子类的getFacadeAccessor()方法获取实际类名，最终获取类的实例对象，然后调用相关方法。\r\n\r\n```php\r\n$instance->$method(...$args);\r\n```\r\n\r\n### 完整代码\r\n\r\n下面是我提取的Laravel门面基类的所有关键代码\r\n\r\n```php\r\n//抽象类\r\nabstract class Facade\r\n{\r\n    /**\r\n     * The resolved object instances.\r\n     *\r\n     * @var array\r\n     */\r\n    protected static $resolvedInstance;\r\n\r\n    /**\r\n     * Get the root object behind the facade.\r\n     *\r\n     * @return mixed\r\n     */\r\n    public static function getFacadeRoot()\r\n    {\r\n        return static::resolveFacadeInstance(static::getFacadeAccessor());\r\n    }\r\n\r\n    /**\r\n     * Handle dynamic, static calls to the object.\r\n     *\r\n     * @param  string  $method\r\n     * @param  array  $args\r\n     * @return mixed\r\n     *\r\n     * @throws \\RuntimeException\r\n     */\r\n    public static function __callStatic($method, $args)\r\n    {\r\n        $instance = static::getFacadeRoot();\r\n\r\n        if (! $instance) {\r\n            throw new RuntimeException(\'A facade root has not been set.\');\r\n        }\r\n\r\n        return $instance->$method(...$args);\r\n    }\r\n\r\n    /**\r\n     * Resolve the facade root instance from the container.\r\n     *\r\n     * @param  object|string  $name\r\n     * @return mixed\r\n     */\r\n    protected static function resolveFacadeInstance($name)\r\n    {\r\n        if (is_object($name)) {\r\n            return $name;\r\n        }\r\n\r\n        if (isset(static::$resolvedInstance[$name])) {\r\n            return static::$resolvedInstance[$name];\r\n        }\r\n\r\n        return new $name;\r\n        \r\n    }\r\n\r\n\r\n    /**\r\n     * Get the registered name of the component.\r\n     *\r\n     * @return string\r\n     *\r\n     * @throws \\RuntimeException\r\n     */\r\n    protected static function getFacadeAccessor()\r\n    {\r\n        throw new RuntimeException(\'Facade does not implement getFacadeAccessor method.\');\r\n    }\r\n}\r\n```\r\n\r\nDB门面类\r\n\r\n```php\r\nclass DB extends Facade\r\n{\r\n    protected static function getFacadeAccessor()\r\n    {\r\n        return \"Mysql\";\r\n    }\r\n}\r\n```\r\n\r\n一个简单的Mysql实际类\r\n```php\r\nclass Mysql \r\n{\r\n    public function find($id)\r\n    {\r\n        print_r($id);\r\n    }\r\n\r\n    public function findAll($ids)\r\n    {\r\n       print_r($ids);\r\n    }\r\n\r\n    public function insert($data)\r\n    {\r\n        print_r($data);\r\n    }\r\n}\r\n\r\n```\r\n于是我们就可以像Laravel一样使用门面了\r\n\r\n```php\r\nDB::find(1);\r\nDB::findAll([1,2,3]);\r\nDB::insert([\'name\'=>\'Json\',\'pwd\'=>3333]);\r\n```',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,861,0),(72,'symfony库之文件查找','72',1597672166,1597672166,'<!--markdown-->### 前言\r\n\r\n这次要介绍的是一个Symfony组件，使用该组件可以通过不同的方式查找文件或者目录，比如根据名称、文件大小、修改时间等条件查找。\r\n\r\n### 安装\r\n\r\n```shell\r\ncomposer require symfony/finder\r\n```\r\n\r\n### 使用\r\n\r\n```php\r\nrequire_once __DIR__.\'/vendor/autoload.php\';\r\n\r\nuse Symfony\\Component\\Finder\\Finder;\r\n\r\n$finder = new Finder();\r\n// find all files in the current directory\r\n$finder->files()->in(__DIR__);\r\n\r\n// check if there are any search results\r\nif ($finder->hasResults()) {\r\n    // ...\r\n}\r\n\r\nforeach ($finder as $file) {\r\n    $absoluteFilePath = $file->getRealPath();\r\n    $fileNameWithExtension = $file->getRelativePathname();\r\n\r\n    var_dump($fileNameWithExtension);\r\n}\r\n```\r\n\r\n**注意:Finder实例对象不会重置内部状态，这也就意味着如果你想获取多个结果的话需要重新创建Finder类的实例对象**\r\n\r\n### 方法说明\r\n\r\n- in()\r\n\r\n  in()方法确定查找目录，用法如下:\r\n\r\n  ```php\r\n  $finder->in(__DIR__);\r\n  ```\r\n\r\n  多个目录查找\r\n\r\n  ```php\r\n  $finder->in([\'./a\', \'./b\']);\r\n  \r\n  // 跟上面等价\r\n  $finder->in(\'./a\')->in(\'./b\');\r\n  ```\r\n\r\n  使用*通配符进行模糊匹配查找\r\n\r\n  ```php\r\n  $finder->files()->in(\'./a*\');//查找当前目录下a开头的目录\r\n  ```\r\n\r\n  排除查找某些目录\r\n\r\n  ```php\r\n  $finder->in(__DIR__)->exclude(\'ruby\');\r\n  ```\r\n\r\n  忽略没有权限的目录\r\n\r\n  ```php\r\n  $finder->ignoreUnreadableDirs()->in(__DIR__);\r\n  ```\r\n\r\n- files()&directories()\r\n\r\n  默认情况下，查找会返回所有的目录和文件，如果想只返回目录可以使用directories(), 只返回符合条件的文件可以使用files()方法，如下\r\n\r\n  ```php\r\n  // find all files in the current directory\r\n  $finder->files()->in(\'./a*\')->files();\r\n  \r\n  foreach($finder as $file) {\r\n      print_r($file->getRelativePathname());\r\n  }\r\n  ```\r\n\r\n- followLinks()\r\n\r\n  通过followLinks()方法，可以返回快捷方式，或者连接\r\n\r\n  ```php\r\n  $finder->files()->followLinks();\r\n  ```\r\n\r\n- name()\r\n\r\n  根据名字进行查找\r\n\r\n  ```php\r\n  $finder->in(\'./\')->files()->name(\'*.php\');//查找当前目录下的php文件\r\n  ```\r\n\r\n  name()方法可以根据正则,glob，字符串形式的文件名匹配查找\r\n\r\n  ```php\r\n  $finder->files()->name(\'/\\.php$/\');\r\n  ```\r\n\r\n  name()也支持多种文件名方式的查找\r\n\r\n  ```php\r\n  $finder->files()->name([\'*.php\', \'*.py\']);//查找后缀是php或者py的文件\r\n  \r\n  //等价于上面的方式\r\n  $finder->files()->name(\'*.php\')->name(\'*.py\');\r\n  ```\r\n\r\n  查找不包含某种模式的文件,如查找不是php后缀的所有文件\r\n\r\n  ```php\r\n  $finder->files()->notName(\'*.php\');\r\n  \r\n  $finder->files()->notName([\'*.rb\', \'*.py\']);//不是php、py后缀的所有文件\r\n  ```\r\n\r\n- contains()\r\n\r\n  根据文件内容查找,如查找文件内容包含hello的所有文件\r\n\r\n  ```php\r\n  $finder->files()->in(\'./a*\')->files()->contains(\'hello\');\r\n  ```\r\n\r\n  也可以根据正则匹配查找文件\r\n\r\n  ```php\r\n  $finder->files()->contains(\'/\\s+hello/i\');\r\n  ```\r\n\r\n  查找文件内容不包含hello的所有文件\r\n\r\n  ```php\r\n  $finder->files()->notContains(\'hello\');\r\n  ```\r\n\r\n- path()\r\n\r\n  查找匹配的文件或者目录\r\n\r\n  ```php\r\n  $finder->path(\'data\')->name(\'*.xml\');//查找data.xml或者data/*.xml\r\n  ```\r\n\r\n  同其它方法一样，也支持数组方式或者正则查找\r\n\r\n  ```php\r\n  $finder->path([\'data\', \'public\']);\r\n  $finder->path(\'/^public\\/images/\');\r\n  ```\r\n\r\n  不查找某文件和目录\r\n\r\n  ```php\r\n  $finder->notPath(\'public/image\');\r\n  ```\r\n\r\n- size()\r\n\r\n  根据文件大小查找文件\r\n\r\n  ```php\r\n  $finder->files()->size(\'< 1.5K\');\r\n  $finder->files()->size(\'>= 1M\')->size(\'<= 2M\');//根据区间查找\r\n  ```\r\n\r\n- date()\r\n\r\n  根据修改时间查找\r\n\r\n  ```php\r\n  $finder->date(\'since yesterday\');\r\n  ```\r\n\r\n- 对查找结果排序\r\n\r\n  ```php\r\n  $finder->sortByName();\r\n  $finder->sortByType();\r\n  $finder->sortByChangedTime();\r\n  $finder->sortByModifiedTime();\r\n  ```\r\n\r\n  ',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,787,0),(73,'记录我对抽象类的误解','73',1597900988,1597900988,'<!--markdown-->### 定义\r\n用`abstract`关键字声明的类叫抽象类,如下代码:\r\n```php\r\nabstract class Person\r\n{\r\n\r\n}\r\n```\r\n\r\n### 特点\r\n- 抽象的类不能被直接实例化,仅允许通过继承来实例化。值得注意的是:尽管抽象类不能实例化,但仍然可以声明构造函数。\r\n\r\n- 类中只要有方法被声明为abstract抽象方法,那么这个类就必须声明为抽象类。\r\n\r\n- 抽象方法只允许有方法声明与参数列表,不允许有方法体，即不能定义其具体的实现\r\n\r\n```php\r\nabstract class Person//有抽象方法的类被声明为抽象类\r\n{\r\n    abstract function say();//抽象方法没有方法体\r\n\r\n    public function execute() {\r\n        $this->say();\r\n    }\r\n}\r\n```\r\n\r\n**注意:类中若存在抽象方法，那么类就必须被定义成抽象类，但是抽象类中可以没有抽象方法，虽然没有抽象方法，但是类仍然不能被直接实例化**。曾经我一直以为抽象类中至少需要一个抽象方法，但是通过读开源代码，无意间发现抽象类里面竟然没有抽象方法，于是查阅了下资料，结合自己写验证代码，证时了抽象类里面可以没有抽象方法，为此记录之。**抽象类里面可以没有抽象方法**\r\n\r\n```php\r\nabstract class Person\r\n{\r\n  \r\n   public function say()\r\n   {\r\n        //do something\r\n   }\r\n\r\n   public function execute()\r\n   {\r\n        //....\r\n   }\r\n}\r\n```',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,779,0),(74,'记录学习golang的小收获','74',1601461149,1601461149,'<!--markdown-->- 全局变量使用`:=`去初始化，跳出作用域变量资源会及时清理，所以在作用域外要使用该值，不能使用`:=`初始化\r\n\r\n	```golang\r\n	package main\r\n\r\n	import \"fmt\"\r\n\r\n	type Person struct {\r\n		name string\r\n	}\r\n\r\n	var p Person\r\n\r\n	func main() {\r\n		Test()\r\n		fmt.Println(p)\r\n	}\r\n\r\n	func Test() {\r\n		p := Person{name: \"hello world\"}\r\n		fmt.Println(p.name)\r\n	}\r\n\r\n	```\r\n	输出结果:\r\n	```shell\r\n	hello world\r\n	{}\r\n	```\r\n	如果要在main中使用全局变量p在Test中的初始化结果，可以将Test中的`p:=`改成`p=`,如下:\r\n	```golang\r\n	func Test() {\r\n		p = Person{name: \"hello world\"}\r\n		fmt.Println(p.name)\r\n	}\r\n	```\r\n- 全局变量不能在函数外先定义，然后再初始化，但是可以定义的时候指定初始化值。如下代码:定义string类型变量name,然后初始化值为hello，结果报错\r\n\r\n	```golang\r\n	package main\r\n\r\n	import \"fmt\"\r\n\r\n	var name string\r\n	name = \"hello\"\r\n\r\n	func main() {\r\n\r\n	}\r\n	```\r\n\r\n	```shell\r\n	syntax error: non-declaration statement outside function body\r\n	```\r\n\r\n	但是可以声明的时候指定初始值:\r\n	```golang\r\n	package main\r\n\r\n	var name = \"hello\"\r\n	//或者\r\n	//var name string = \"hello\"\r\n	func main() {\r\n\r\n	}\r\n	```\r\n- 只能在本包为本包的类型扩展方法，不能在其它包扩展方法，举个例子\r\n\r\n	```golang\r\n\r\n	package test\r\n\r\n	import \"fmt\"\r\n\r\n	type Person struct {\r\n		Name string\r\n	}\r\n\r\n	func (p *Person) say() {\r\n		fmt.Println(p.Name);\r\n	}\r\n	```\r\n	```golang\r\n	package hello\r\n\r\n	import \"fmt\"\r\n\r\n	func (p *Person) write() {\r\n		fmt.Println(p.Name);\r\n	}\r\n	```\r\n	上面的代码是错误的，Person类型属于test包，不能在hello包里面为Person类型添加方法。\r\n\r\n- 下划线`_`的使用场景\r\n\r\n    - 使用在import中，因为go中import一个包之后，如果不使用会编译失败，所以使用下划线来表示只是导入其他package，执行其它包中的init函数\r\n    \r\n    ```golang\r\n        import (\r\n            _ \"net/http\"\r\n        )\r\n    ```\r\n\r\n    - 忽略或者抛弃不使用的变量，仅仅作为一个占位\r\n\r\n    ```golang\r\n    package main\r\n\r\n    import \"fmt\"\r\n\r\n    func main() {\r\n        sum, err := Add(1, 2)\r\n        fmt.Println(sum)\r\n    }\r\n\r\n    func Add(a, b int) (int, error) {\r\n        return a + b, nil\r\n    }\r\n    ```\r\n    上面的代码或报错，因为err变量没用使用，go语言是一个干净的语言，不允许有闲置不适用的变量存在，如果变量值没有使用，那就不要存在这个变量。为了解决这种问题，go中使用占位符`_`类抛弃不使用的变量，上面改成下面的代码就不报错了\r\n\r\n     ```golang\r\n    //sum, err := Add(1, 2)\r\n    sum, _ := Add(1, 2)\r\n    ```\r\n\r\n    - 用在变量(特别是接口断言)\r\n\r\n    看开源代码的使用看到过如下类似的代码:\r\n    ```golang\r\n    package main\r\n\r\n    type Test interface {\r\n        Result() string\r\n    }\r\n\r\n    type T struct {\r\n        Name string\r\n    }\r\n\r\n    func (t *T) Result() string {\r\n        return t.Name\r\n    }\r\n\r\n    func main() {\r\n        var _ Test = &T{Name: \"Json\"}\r\n    }\r\n\r\n    ```\r\n\r\n    这段代码`var _ Test = &T{Name: \"Json\"}`的意思是判断&T是否实现了Test接口,如果&T没有实现Test,则会报编译错误,`_`的作用也是个占位，类型断言，但是后续不使用\r\n\r\n\r\n- golang中的三个点(...)\r\n\r\n    - 根据元素实际数量识别数组的长度\r\n\r\n    ```golang\r\n    package main\r\n\r\n    import \"fmt\"\r\n\r\n    func main() {\r\n        arr := [...]string{\"java\", \"python\", \"php\", \"js\"}\r\n        fmt.Println(arr, len(arr))\r\n    }\r\n\r\n    ```\r\n\r\n    - slice可以被打散进行传递\r\n\r\n    ```golang\r\n    package main\r\n\r\n    import \"fmt\"\r\n\r\n    func main() {\r\n        arr := []int{1, 2, 3, 4, 5}\r\n        var lst []int\r\n        lst = make([]int, 0)\r\n        lst = append(lst, arr...)\r\n        fmt.Println(lst)\r\n    }\r\n\r\n    ```\r\n\r\n    - 函数接收不定长参数的情况\r\n\r\n    ```golang\r\n    package main\r\n\r\n    import \"fmt\"\r\n\r\n    func main() {\r\n        arr := []int{1, 2, 3, 4, 5}\r\n        fmt.Println(Sum(arr...))\r\n        fmt.Println(Sum(1, 2, 3, 4, 5, 6))\r\n    }\r\n\r\n    func Sum(args ...int) int {\r\n        sum := 0\r\n        for _, value := range args {\r\n            sum += value\r\n        }\r\n        return sum\r\n    }\r\n\r\n    ```',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,813,0),(75,'作为初试面试官我问的问题有哪些？','75',1606018260,1606018304,'<!--markdown-->- 自我介绍\r\n了解面试者的基本信息，沟通表达能力以及项目经验\r\n- 针对最近的一个项目进行追问\r\n了解面试者在项目中扮演的角色，处理的项目深度以及项目复杂度，了解逻辑能力和表述能力\r\n- 常用php字符串数组函数，类，抽象类，魔术方法\r\n了解面试者的技术基本功\r\n- mysql引擎，事务，锁，索引优化，慢查询分析\r\n了解面试者mysql使用熟练程度\r\n- 随机设计几道题目\r\n考察面试者的基本技术的综合作用能力，包括php,mysql,redis等\r\n- redis,memcache使用情况以及用过哪些命令\r\n- 处理过哪些线上问题\r\n考察面试者踩过的坑多吗，解决问题的能力\r\n- 用过哪些设计模式，都是为了解决什么问题，能简单写一个设计模式的代码吗\r\n- 有没有看过开源代码，最熟悉使用哪个框架，有没有看过框架源码',0,2,NULL,'post','publish',NULL,1,'1','1','1',0,893,0),(76,'基于openresty的web api框架','76',1609488000,1609488114,'<!--markdown-->### openresty介绍\r\n\r\nopenresty是将nginx和luajit融合在一个的一个项目，常用来做网关、灰度发布等，也可以用来开发web，但是不是特别好，毕竟没有提供那么多便捷的字符串以及其它结构处理的函数，也不容易处理业务层的复杂逻辑，因此不是太擅长业务复杂的系统。\r\nopenresty内置了大量精良的lua库，用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。其它介绍大家可以参考[openresty官网](http://openresty.org/cn)\r\n\r\n### 框架由来\r\nlua是一个轻量小巧的编程语言，据说是性能最高的编程语言之一，可以结合openresty开发web，也可以结合redis实现一些原子性的操作，当然还可以开发web。自己是做web方面工作的，所以就希望看看在web方面有什么使用框架没有，通过调研发现，市场上有lor、orange、lapis等框架，但是lor需要在linux环境使用，orange是基于lor封装了一下，lapis是用moonscript开发的，不是特别满意，因此自己开发了一个轻量级框架，windows上也可以用。既然openresty官方提供了windows预编译版本，那自己就想找一个可以windows下开发和允许的框架，特此有了这个项目，方便之后用的时候快速生成项目结构。\r\n\r\n### 框架地址\r\n[点我看源码](https://github.com/fanqingxuan/jframe)\r\n### 目录结构\r\n\r\n结构供包含config、controller、libs、model四个目录\r\n\r\n- config\r\n\r\n  配置文件目录，用于app、redis、database相关的配置\r\n\r\n  - app应用相关\r\n\r\n  ```lua\r\n  return {\r\n  	default_controller = \'home\', -- 默认控制器\r\n  	default_action	   = \'index\', -- 默认方法\r\n  }\r\n  ```\r\n\r\n  - 数据库相关\r\n\r\n  ```lua\r\n  local mysql_config = {\r\n      timeout = 5000,\r\n      connect_config = {\r\n          host = \"127.0.0.1\",\r\n          port = 3306,\r\n          database = \"demo\",\r\n          user = \"root\",\r\n          password = \"a12345\",\r\n          max_packet_size = 1024 * 1024\r\n      },\r\n      pool_config = {\r\n          max_idle_timeout = 20000, -- 20s\r\n          pool_size = 50 -- connection pool size\r\n      }\r\n  }\r\n  ```\r\n\r\n  - redis配置\r\n\r\n  ```lua\r\n  return {\r\n      host = \"127.0.0.1\", -- redis host\r\n      port = 6379, -- the port\r\n      max_idle_timeout = 60000, -- max idle time\r\n      pool_size = 1000, -- pool size\r\n      timeout = 1000, -- timeout time\r\n      db_index= 2, -- database index\r\n      \r\n  }\r\n  ```\r\n\r\n- libs目录\r\n\r\n  libs目录下面的公共的模块库，包括redis、db、request、response等\r\n\r\n- controller目录\r\n\r\n  这是控制器目录，里面有一个封装了一个基类Base.lua,业务控制器继承这个即可，基本的业务控制器代码如下\r\n\r\n  ```lua\r\n  -- home.lua\r\n  local Base = require(\"controller.base\")\r\n  \r\n  local Home = Base:extend()\r\n  \r\n  function Home:index() \r\n      self:json({data={}})\r\n  end\r\n  ```\r\n\r\n  上面的代码就实现了一个控制器，访问路径hostname://home/index即可请求index方法,请求的url规则是hostname+controller文件夹下的文件名+/+文件中的方法名**(注意一定要继承Base模块)**\r\n\r\n  controller里面提供了几个基本属性\r\n\r\n  - self.request获取请求相关参数，如self.request.query.xx获取get参数，self.request.body.xx获取post参数，self.request.headers.xx获取header参数等\r\n\r\n  - self.response输出响应结果，主要有self.response:json()返回data结果，以及self.response:redirect()跳转,self.response.get_body()获取响应结果等\r\n\r\n    为了方便开发，在Base里面封装了response，提供了self:json(),self:error(code,message)两个快捷方法\r\n\r\n    ```lua\r\n    self:json({data=self.redis:get(\"test\")}) --返回结果设置data\r\n    self:error(2,\"获取数据失败\") --返回结果设置错误码，错误消息\r\n    ```\r\n\r\n    返回的结构包含data,code,message字段\r\n\r\n    ```lua\r\n    {\"data\":{\"data\":[\"BBBBB\",\"B\",\"AAAAA\",\"A\",\"BBBBB\",\"B\",\"AAAAA\",\"A\"]},\"message\":\"\",\"code\":\"获取成功\"}\r\n    ```\r\n\r\n  - self.redis可以使用redis，包含self.redis:set,self.redis:get,self.redis:hset,self.redis:hget等等，具体可以使用的函数可以参考**libs/redis.lua**文件的15到72行\r\n\r\n  - self.controller获取当前控制器名称\r\n\r\n  - self.action获取当前action操作名称\r\n\r\n- model目录\r\n\r\n  模型相关，为了便于操作，也封装了一个Base基类，业务model只需要继承即可\r\n\r\n  ```lua\r\n  -- good.lua\r\n  local Base = require \"model.base\"\r\n  \r\n  local Good = Base:extend() --继承Base\r\n  \r\n  return Good(\"test\",\'lgid\') --第一个参数表名称,第二个参数是表对应的主键(默认为id)\r\n  ```\r\n\r\n  Base.lua封装的基类提供了单表增删改查的方法\r\n\r\n  - create(data)添加记录\r\n  - delete(id)删除记录\r\n  - update(data,id)修改记录\r\n  - get()、all()过滤记录\r\n  - where()过滤条件方法\r\n  - columns()设置查找哪些列的方法\r\n  - orderby()设置排序的方法\r\n  - count()查找数据总条数的方法\r\n\r\n  同时Base.lua也提供了一个方法用于自定义执行sql的方法，方便复杂查询\r\n\r\n  - query()\r\n\r\n### 快速开始\r\n\r\n- nginx.conf添加类似如下代码\r\n\r\n  ```she\r\n  worker_processes  1;\r\n  error_log logs/error.log;\r\n  events {\r\n      worker_connections 1024;\r\n  }\r\n  http {\r\n  \r\n      lua_package_path \'E:/openresty/demo/src/?.lua;;\';\r\n      server {\r\n          charset utf-8;        \r\n          listen 8080;\r\n          \r\n          location = /favicon.ico {\r\n            log_not_found off;#关闭日志\r\n            access_log off;#不记录在access.log\r\n          }\r\n  \r\n          location / {\r\n              default_type text/html;\r\n              content_by_lua_file \"E:/openresty/demo/src/main.lua\";\r\n          }\r\n      }\r\n  }\r\n  ```\r\n\r\n- 添加控制器\r\n\r\n  在controller目录添加user.lua\r\n\r\n  ```lua\r\n  local Base = require(\"controller.base\")\r\n  \r\n  local User = Base:extend()\r\n  \r\n  function User:index() \r\n      self:json({\r\n          data={\r\n              name = \"hello world\"\r\n          }\r\n      })\r\n  end\r\n  return User\r\n  ```\r\n\r\n- 添加model\r\n\r\n  ```lua\r\n  local Base = require \"model.base\"\r\n  \r\n  local User = Base:extend()\r\n  \r\n  return User(\"sls_p_user\",\'suid\')\r\n  ```\r\n\r\n- 控制器使用model\r\n\r\n  ```lua\r\n  local userModel = require(\'model.user\')\r\n  \r\n  function User:index() \r\n      self:json({\r\n          data={\r\n              name = userModel:columns(\'rname\'):get(1)\r\n          }\r\n      })\r\n  end\r\n  ```\r\n\r\n### model封装的快捷方法说明\r\n\r\n- 添加\r\n\r\n  ```lua\r\n  local data = {\r\n      name = \"test\",\r\n      pwd = 123\r\n  }\r\n  local insertId = userModel:create(data)\r\n  ```\r\n\r\n- 删除\r\n\r\n  - 根据主键删除\r\n\r\n    ```lua\r\n    local affect_rows = userModel:delete(2)\r\n    ```\r\n\r\n  - 根据where条件删除\r\n\r\n    ```lua\r\n    local affect_rows = userModel:where(\"name\",\"=\",3):delete()\r\n    ```\r\n\r\n- 修改\r\n\r\n  - 根据主键修改\r\n\r\n    ```lua\r\n    local affect_rows = userModel:update(data,2)\r\n    \r\n    local data = {\r\n        suid = \"1\", -- data里面存在主键，根据主键更新\r\n        name = \"hello 我的测试\",\r\n    }\r\n    local affect_rows = userModel:update(data)\r\n    ```\r\n\r\n  - 根据where条件修改\r\n\r\n    ```lua\r\n    local affect_rows = userModel:where(\"name\",\"=\",3):update(data)\r\n    ```\r\n\r\n- 查找\r\n\r\n  - 查找一条记录\r\n\r\n    ```lua\r\n    local info = userModel:where(\"name\",\"=\",3):get() --根据where条件查找\r\n    local info = userModel:get(1) --根据主键查找\r\n    local info = userModel:columns(\'suid,name\'):get(1) --查找指定字段,查找字段是字符串\r\n    local info = userModel:columns({\'suid\',\'name\'}):get(1) --查找指定字段,查找字段是table\r\n    ```\r\n\r\n  - 查找多条记录\r\n\r\n    ```lua\r\n    local list = userModel:where(\"name\",\"=\",3):all() --根据where条件查找\r\n    local list = userModel:columns(\'suid,name\'):all() --查找指定字段,查找字段是字符串\r\n    local list = userModel:columns({\'suid\',\'name\'}):all() --查找指定字段,查找字段是table\r\n    ```\r\n\r\n- 其它方法说明\r\n\r\n  - 查找数据条数\r\n\r\n    ```lua\r\n    local count = userModel:where(\"name\",\"=\",\"json\"):count()\r\n    ```\r\n\r\n  - 排序\r\n\r\n    ```lua\r\n    local list = userModel:where(\"name\",\"=\",3):orderby(\"id\"):all()\r\n    \r\n    local list = userModel:where(\"name\",\"=\",3):orderby(\"name\",\"asc\"):orderby(\"id\",\"desc\"):all() --多个排序\r\n    ```\r\n\r\n  - 查找指定字段(不使用指定字段，则是查找所有字段)\r\n\r\n    ```lua\r\n    local list = userModel:columns(\'suid,name\'):all() --columns里面可以是字符串，也可以是table结构\r\n    ```\r\n\r\n  - 根据where条件查找\r\n\r\n    ```lua\r\n    local list = userModel:columns(\'suid,rname\'):where(\"suid\",\"<\",\"30\"):orderby(\"suid\"):all()\r\n    \r\n    local list = userModel:columns(\'suid,rname\'):where(\"suid\",\"<\",\"30\"):where(\"rname\",\"like\",\"test%\"):orderby(\"suid\"):all() -- 可以多个where\r\n    ```\r\n\r\n  - 自定义执行的sql\r\n\r\n    ```lua\r\n    -- 关联查询\r\n    local sql = \"select su.*,c.logincount from sls_p_user su join c_user c on su.suid=c.suid where su.suid=2\"\r\n    local result = userModel:query(sql)\r\n    \r\n    -- 动态参数查询\r\n    local sql = \"select * from sls_p_user where suid=? and username=?\"\r\n    local result = userModel:query(sql,{1,\"json\"})\r\n    ```\r\n\r\n\r\n### 命令行\r\n\r\n为了方便快速生成控制器controller,以及模型model, 特开发了命令行,命令行使用**luajit**编写，需要将luajit放入环境变量\r\n\r\n```lua\r\n ./jframe -h\r\njframe v0.1.1, a Lua web framework based on OpenResty.\r\nUsage: jframe COMMAND [OPTIONS]\r\nCommands:\r\n controller [name]          Create a new controller\r\n model      [name]  [table] Create a new model\r\n version                    Show version of the framework\r\n help                       Show help tips\r\n```\r\n\r\n**注意windows下命令是**\r\n\r\n```lua\r\nluajit ./jframe -h\r\n```\r\n\r\n- 生成控制器，自动生成到controller目录下\r\n\r\n  ```lua\r\n  jframe controller controllerName\r\n  ```\r\n\r\n- 生成model，自动生成到model目录下\r\n\r\n  ```lua\r\n  jframe model modelName --不指定表名称，生成的model表名称默认是给定的modelname的小写格式\r\n  jframe model modelName table--指定model名称以及表名称\r\n  \r\n  ```\r\n\r\n  \r\n',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,843,1),(77,'lua工具包汇集','77',1609994940,1609995062,'<!--markdown-->### This is a pure Lua library that provides a set of utility functions for dealing with strings,tables,files and some others.\r\n\r\n### Code source\r\n[Click here](https://github.com/fanqingxuan/lua_utils)\r\n### debug\r\n\r\nfirst you must require the module if you need use it in your code.\r\n\r\n```lua\r\nlocal debug = require \'utils.debug\'\r\n```\r\n\r\n- `print()` print a scalar value or table\r\n\r\n  **Notice**:\r\n\r\n  a) can not print nil value .\r\n\r\n  b) will print json format if the params is table.\r\n\r\n  ```lua\r\n  local a = 56\r\n  debug.print(\'hello\',a) --output: hello  56\r\n  debug.print(false,true,3.4)  --output:false true 3.4\r\n  debug.print({1,2,3,4}) --output json:[1,2,3,4]\r\n  ```\r\n\r\n- `die()` Output a message and terminate the current script\r\n\r\n  ```lua\r\n  debug.print(\"hello\") --output:hello\r\n  debug.die(\"this is die\") --output: this is die\r\n  debug.print(\"can not print this line\")\r\n  ```\r\n\r\n  \r\n\r\n### string\r\n\r\nfirst you must require the module if you need use it in your code.\r\n\r\n```lua\r\nlocal util_string = require \'utils.string\'\r\n```\r\n\r\n- `trim()` Strip whitespace from the beginning and end of a string\r\n\r\n  ```lua\r\n  print(util_string.trim(\" hello \")) -- output:\"hello\"\r\n  print(util_string.trim(\"helloaa\",\'a\')) -- output:\"hello\"\r\n  ```\r\n\r\n- `ltrim()` Strip whitespace from the beginning of a string\r\n\r\n  ```lua\r\n  print(util_string.ltrim(\" hello \")) --output:\"hello \"\r\n  print(util_string.ltrim(\"ahelloa\",\'a\')) -- output:\"helloa\"\r\n  ```\r\n\r\n- `rtrim()`  Strip whitespace from the end of a string\r\n\r\n  ```lua\r\n  print(util_string.rtrim(\" hello \")) --output:\" hello\"\r\n  print(util_string.rtrim(\"ahelloa\",\'a\')) -- output:\"ahello\"\r\n  ```\r\n\r\n- `startswith()` check whether a string is start with some charactors\r\n\r\n  ```lua\r\n  print(util_string.startswith(\"hello\",\'he\')) --output:true\r\n  print(util_string.startswith(\"hello\",\'H\')) --output:false\r\n  ```\r\n\r\n- `endswith()` check whether a string is end with some charactors\r\n\r\n  ```lua\r\n  print(util_string.endswith(\"hello\",\'o\')) -- output:true\r\n  print(util_string.endswith(\"hello\",\'O\')) -- output:false\r\n  ```\r\n\r\n- `split()` split a string into table\r\n\r\n  ```lua\r\n  util_string.split(\"a#b#c#d\",\'#\') --output:{\'a\',\'b\',\'c\',\'d\'}\r\n  ```\r\n\r\n- `contains()` Checks if a value exists in a string\r\n\r\n  ```lua\r\n  print(util_string.contains(\"hello world\",\'H\')) --output:false\r\n  print(util_string.contains(\"hello world\",\'e\')) --output:true\r\n  ```\r\n\r\n- `replace()` Replace all occurrences of the search string with the replacement string\r\n\r\n  ```lua\r\n  print(util_string.replace(\"hello world world\",\'world\',\'lua\')) -- output:hello lua lua\r\n  ```\r\n\r\n- `len()` get string length\r\n\r\n  ```lua\r\n  print(util_string.len(\"hello\")) -- output:5\r\n  ```\r\n\r\n- `upper()` Make a string uppercase\r\n\r\n  ```lua\r\n  print(util_string.upper(\"hello world\")) -- output:HELLO WORLD\r\n  ```\r\n\r\n- `lower()` Make a string lowercase\r\n\r\n  ```lua\r\n  print(util_string.lower(\"Hello world\")) -- output:hello world\r\n  ```\r\n\r\n- `ucwords()` Uppercase the first character of each word in a string\r\n\r\n  ```lua\r\n  print(util_string.ucwords(\"hello world\")) --output:Hello World\r\n  print(util_string.ucwords(\"hello#world\",\'#\')) -- output:Hello#World\r\n  ```\r\n\r\n- `ucfirst()` Make a string\'s first character uppercase\r\n\r\n  ```lua\r\n  print(util_string.ucfirst(\"hello world\")) --output:Hello world\r\n  ```\r\n\r\n- `reverse()` Reverse a string\r\n\r\n  ```lua\r\n  print(util_string.reverse(\"hello\")) -- output:olleh\r\n  ```\r\n\r\n- `substr()` Return part of a string\r\n\r\n  ```lua\r\n  print(util_string.substr(\"hello\",2,3)) -- output:el\r\n  \r\n  print(util_string.substr(\"hello\",-3)) --output:llo\r\n  ```\r\n\r\n### table\r\n\r\nfirst you must require the module if you need use it in your code.\r\n\r\n```lua\r\nlocal util_table = require \'utils.table\'\r\n```\r\n\r\n- `is_empty()` Determine whether a variable is empty,return true or false\r\n\r\n  ```lua\r\n  util_table.is_empty({})  -- output:true\r\n  util_table.is_empty({name=\"json\"})  -- output:false\r\n  ```\r\n\r\n- `reverse()` Return an array with elements in reverse order\r\n\r\n  ```lua\r\n  debug.print(util_table.reverse({\'a\',\'b\',\'c\'})) -- output:{\'c\',\'b\',\'a\'}\r\n  ```\r\n\r\n- `unique()` Removes duplicate values from an array\r\n\r\n  ```lua\r\n  debug.print(util_table.unique({\'a\',\'b\',\'a\',\'c\'})) -- output:{\'a\',\'b\',\'c\'}\r\n  ```\r\n\r\n- `implode()`  Join array elements with a string\r\n\r\n  ```lua\r\n  debug.print(util_table.implode({\'a\',\'b\',\'a\',\'c\'},\'#\')) -- output:a#b#a#c\r\n  ```\r\n\r\n- `copy()` Deep copies a table into a new table.\r\n\r\n  ```lua\r\n  local a = {\'a\',\'b\',\'c\'}\r\n  local b = util_table.copy(a)\r\n  debug.print(a==b) -- output:false\r\n  ```\r\n\r\n- `is_array`() Finds whether a variable is an array\r\n\r\n  ```lua\r\n  local a = {\'a\',\'b\',\'c\'}\r\n  debug.print(util_table.is_array(a)) -- output:true\r\n  debug.print(util_table.is_array(\'hello\')) -- output:false\r\n  debug.print(util_table.is_array({name=\'json\',age=32})) -- output:false\r\n  ```\r\n\r\n- `merge()` Merge arrays into a new array. if the key is same, and the after element will override the before. \r\n\r\n  ```lua\r\n  local a = {\'a\',\'b\',\'c\',\'d\'}\r\n  local b = {1,2}\r\n  debug.print(util_table.merge(a,b))  -- output:{1,2,\'c\',\'d\'}\r\n  \r\n  local a = {name=\'json\',age=32}\r\n  local b = {1,2}\r\n  debug.print(util_table.merge(a,b))  --output:{1,2,name=\'json\',age=32}\r\n  ```\r\n\r\n- `contains()` Checks if a value exists in a table,return true or false\r\n\r\n  ```lua\r\n  local a = {\'a\',\'b\',\'c\'}\r\n  debug.print(util_table.contains(a,\'a\')) -- output:true\r\n  \r\n  debug.print(util_table.contains(a,\'11\')) --output:false\r\n  ```\r\n\r\n- `keys()` return a table containing the keys of the provided table\r\n\r\n  ```lua\r\n  local a = {name=\'json\',age=32}\r\n  debug.print(util_table.keys(a))  -- output:{\'name\',\'json\'}\r\n  ```\r\n\r\n- `values()` return a table containing the values of the provided table\r\n\r\n  ```lua\r\n  local a = {name=\'json\',age=32}\r\n  debug.print(util_table.values(a)) -- output:{\'json\',32}\r\n  ```\r\n\r\n- `append()` append the contents of (array-like) table b into table a\r\n\r\n  ```lua\r\n  local a = {\'a\',\'b\',\'c\'}\r\n  local b = {1,2,3}\r\n  util_table.append(a,b)\r\n  debug.print(a)  -- output:{\'a\',\'b\',\'c\',1,2,3}\r\n  ```\r\n\r\n- `push()` Push one or more elements onto the end of table\r\n\r\n  ```lua\r\n  local a = {\'a\',\'b\',\'c\'}\r\n  util_table.push(a,1,2,3)\r\n  debug.print(a)  -- output:{\'a\',\'b\',\'c\',1,2,3}\r\n  ```\r\n\r\n- `pop()` Pop the element off the end of table\r\n\r\n  ```lua\r\n  local a = {\'a\',\'b\',\'c\'}\r\n  util_table.pop(a)\r\n  debug.print(a)  -- output:{\'a\',\'b\'}\r\n  ```\r\n\r\n- `unshift()` Prepend one or more elements to the beginning of an table\r\n\r\n  ```lua\r\n  local a = {\'a\',\'b\',\'c\'}\r\n  util_table.unshift(a,1,2,3)\r\n  debug.print(a)  -- output:{3,2,1,\'a\',\'b\',\'c\'}\r\n  ```\r\n\r\n- `shift()` Shift an element off the beginning of table\r\n\r\n  ```lua\r\n  local a = {\'a\',\'b\',\'c\'}\r\n  util_table.shift(a)\r\n  debug.print(a) -- output:{\'b\',\'c\'}\r\n  ```\r\n\r\n- `key_exists()` Checks if the given key or index exists in the table, return true or false\r\n\r\n  ```lua\r\n  local tab = {name=\'json\',age=32}\r\n  debug.print(util_table.key_exists(\'info\',tab)) -- output:false\r\n  debug.print(util_table.key_exists(\'name\',tab)) -- output:true\r\n  ```\r\n\r\n- `search()` Searches the table for a given value and returns the first corresponding key if successful\r\n\r\n  ```lua\r\n  local tab = {name=\'json\',age=32}\r\n  debug.print(util_table.search(\'json\',tab)) -- output:name\r\n  debug.print(util_table.search(\'info\',tab)) -- output:nil\r\n  ```\r\n\r\n- `slice(tab,index,length)` Extract a slice of the table. the first argument is the table, the second is the index, and the third is the slice length, default is the last if you not give.\r\n\r\n  if the index is negative, and the slice with count from back.\r\n\r\n  ```lua\r\n  local tab = {\'a\',\'b\',\'c\',\'d\'}\r\n  debug.print(util_table.slice(tab,2))  -- output:{\'b\',\'c\',\'d\'}\r\n  debug.print(util_table.slice(tab,2,2)) --output:{\'b\',\'c\'}  \r\n  debug.print(util_table.slice(tab,-3)) --output:{\'b\',\'c\',\'d\'}\r\n  ```\r\n\r\n- `to_array()`  convert table to list\r\n\r\n  ```lua\r\n  local tab = {name=\'json\',age=32,}\r\n  debug.print(util_table.to_array(tab))  -- output:{\'json\',32}\r\n  ```\r\n\r\n- `sort()` sort with a function\r\n\r\n  ```lua\r\n  local tab = {4,2,-6,3}\r\n  util_table.sort(tab)\r\n  debug.print(tab)  --output:{-6,2,3,4}\r\n  \r\n  util_table.sort(tab,function(a,b) \r\n      return math.abs( a ) < math.abs( b ) \r\n  end)\r\n  debug.print(tab)  --output:{2,3,4,-6}\r\n  ```\r\n\r\n- `filter(tab,callback)` Filters elements of an array using a callback function. filter the false value if you not give the function,  and If the callback function returns true, the current value from table is returned into the result array.\r\n\r\n  ```lua\r\n  local tab = {4,2,false,3}\r\n  \r\n  debug.print(util_table.filter(tab))  --output:{4,2,3}\r\n  \r\n  local a = util_table.filter(tab,function(a)\r\n      return a and a%2==1\r\n  end)\r\n  debug.print(a)  --output:{3}\r\n  ```\r\n\r\n- `pluck(tab,column,index_key)` Return the values from a single column in the input array\r\n\r\n  returns the values from a single column of the array, identified by the column_key. Optionally, an index_key may be provided to index the values in the returned array by the values from the index_key column of the input array.\r\n\r\n  ```lua\r\n  local list = {\r\n      {id=\'1\',name=\'json\',age=32},\r\n      {id=\'2\',name=\'fanqingxuan\',age=29},\r\n      {id=\'3\',name=\'lua\',age=45}\r\n  }\r\n  \r\n  debug.print(util_table.pluck(list,\'name\')) --output:{\'json\',\'fanqingxuan\',\'lua\'}\r\n  debug.print(util_table.pluck(list,\'name\',\'id\')) --putput:{[\'1\']=\'json\',[\'2\']=\'fanqingxuan\',[\'3\']=\'lua\'}\r\n  \r\n  debug.print(util_table.pluck(list,nil,\'id\'))\r\n  --oputput:{[\'1\']={id=\'1\',name=\'json\',age=32},[\'2\']={id=\'2\',name=\'fanqingxuan\',age=29},[\'3\']={id=\'3\',name=\'lua\',age=45}}\r\n  \r\n  ```\r\n\r\n### io\r\n\r\nfirst you must require the module if you need use it in your code.\r\n\r\n```lua\r\nlocal io = require \'utils.io\'\r\n```\r\n\r\n- `file_get_contents`  get contents from file, return the content str and err\r\n\r\n  ```lua\r\n  local data,err = io.file_get_contents(\'./utils/cjson.lua\')\r\n  debug.print(data) -- output the content in file cjson.lua\r\n  ```\r\n\r\n- `file_put_contents(file,data,mode)` Write file contents.\r\n\r\n  return true upon success, or false + error message on failure\r\n\r\n  ```lua\r\n  io.file_put_contents(\'a.txt\',\"hello world\") -- will clear a.txt content, then write \'hello world\' to a.txt\r\n  \r\n  io.file_put_contents(\'a.txt\',\"hello world\",\"a+\") -- will append \'hello world\' to a.txt\r\n  ```\r\n\r\n- `file_exists()` Checks whether a file exists\r\n\r\n  ```lua\r\n  debug.print(io.file_exists(\"index.lua\") )-- output:true\r\n  \r\n  local exists,err = io.file_exists(\"index1.lua\")\r\n  \r\n  if not exists then\r\n  	print(\"file not exists with err:\"..err)\r\n  end\r\n  ```\r\n\r\n- `execute_cmd()`Execute an external program\r\n\r\n  ```lua\r\n  local data,err = io.execute_cmd(\'ls -ll\')\r\n  ```\r\n\r\n### console\r\n\r\nfirst you must require the module if you need use it in your code.\r\n\r\n```lua\r\nlocal console = require \'utils.console\'\r\n```\r\n\r\nThis library is for command, and can print some text with colors.\r\n\r\n```lua\r\nconsole.red(\" this is red color\");\r\nconsole.yellow(\" this is yellow color\");\r\nconsole.white(\" this is white color\");\r\nconsole.blue(\" this is blue color\");\r\nconsole.green(\" this is green color\");\r\nconsole.magenta(\" this is magenta color\");\r\nconsole.cyan(\" this is cyan color\");\r\n```\r\n\r\nAnd you can also write log with diffent color:\r\n\r\n```lua\r\nconsole.log(\"this is log\")\r\nconsole.trace(\"this is trace log\")\r\nconsole.info(\"this is info log\")\r\nconsole.warn(\"this is warn log\")\r\nconsole.error(\"this is error log\")\r\nconsole.debug(\"this is debug log\")\r\nconsole.fatal(\"this is fatal log\")\r\n```\r\n\r\nThe module also provide two function for sucess or fail output:\r\n\r\n```lua\r\nconsole.success(\"the code run success\")\r\nconsole.error(\"there something error\")\r\n```\r\n\r\n### json\r\n\r\nfirst you must require the module if you need use it in your code.\r\n\r\n```lua\r\nlocal json = require \'utils.cjson\'\r\n```\r\n\r\n**Notice**: you must confirm you have installed cjson library in your system, if not please install it with luarocks.\r\n\r\n- `encode()` Returns the JSON representation of a value\r\n\r\n  ```lua\r\n  local arr = {\r\n      name = \'json\',\r\n      age = 32\r\n  }\r\n  debug.print(json.encode(arr)) -- output string:{\"age\":32,\"name\":\"json\"}\r\n  ```\r\n\r\n- `decode()` Decodes a JSON string\r\n\r\n  ```lua\r\n  local str = \'{\"age\":32,\"name\":\"json\"}\'\r\n  debug.print(json.decode(str).name) --output:json\r\n  ```\r\n\r\n\r\n### other library\r\n\r\nThe project also collect some useful third library, You can click the link and read the detail document.\r\n\r\n- [ansicolors](https://github.com/kikito/ansicolors.lua) a useful library for output color text\r\n- [argparse](https://github.com/mpeterv/argparse) a library for parse arguments from command line\r\n- [classic](https://github.com/rxi/classic/blob/master/classic.lua) a library that you can make your lua code more like oop\r\n- [date](https://github.com/Tieske/date) a library that for date and time calculations\r\n- [dkjson](https://github.com/LuaDist/dkjson) a module for encoding and decoding JSON data\r\n- [md5](https://github.com/kikito/md5.lua) a module for generating md5 string\r\n- [redis-lua](https://github.com/nrk/redis-lua/) you can use redis with this module\r\n- [memcached](https://github.com/silentbicycle/lua-memcached) you can play with memcached',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,580,0),(78,'yaf框架搭建的开箱即用项目','78',1610161581,1610161581,'<!--markdown-->### 环境要求\r\n- yaf版本3.2.5\r\n- php版本7.0+\r\n\r\n### 源码地址\r\n[点击这里](https://github.com/fanqingxuan/yaf_demo)\r\n### 框架说明\r\n该项目使用yaf搭建的一个开箱即用的web api项目\r\n- 集成了seaslog高性能日志组件，用来记录业务日志，error日志以及request日志\r\n- 集成了phpredis类库，封装成JRedis，方便使用redis，也可以提取出来用到自己的项目里面，这个类库包含了phpredis的所有函数，便于编辑器智能提示\r\n- 集成了Medoo作为数据库连接层，在BaseModel里面进行了简单封装，便于业务model做快速的增删改查\r\n- dev-tools目录提供了代码命名规范工具**phpmd**、psr代码美化工具**php-cs-fixer**、代码格式化工具**phpcbf**以及语法错误检查工具**phpcs**、**phpstan**\r\n- 目录结构\r\n  - controllers  控制器目录\r\n  - models 做数据库的查询\r\n  - services 做为业务处理层\r\n  - config 配置项目录，包括db、redis、日志等配置\r\n  - logs 日志目录，里面有default子目录作为业务日志，error子目录错误日志，request子目录做请求日志，日志按天生成文件\r\n  - libs 类库目录\r\n  - plugins 中间件钩子目录\r\n\r\n### model\r\n\r\nmodel默认使用model类去掉Model后由驼峰式转成长蛇格式后的字符串作为表名字，例如UserModel表名称是user，UserPostModel用user_post作为表名称，也支持自定义表名称，在model里面定义tableName静态方法，如下:\r\n\r\n```php\r\n<?php\r\n\r\nclass UserModel extends BaseModel\r\n{\r\n    protected $primary_key = \'uid\';\r\n\r\n    public static function tableName()\r\n    {\r\n        return \'t_user\';\r\n    }\r\n}\r\n```\r\n\r\n默认用id字段作为主键，可以用`$primary_key`属性自定义表主键，便于下面根据主键查询时使用。\r\n\r\n- 添加\r\n\r\n  ```php\r\n  $model = new PostModel;\r\n  $post = [\r\n      \'user_id\'   =>  11,\r\n      \'content\'   =>  \'这是内容\',\r\n      \'title\'     =>  \'这是标题\',\r\n  ];\r\n  $id = $model->create($post);\r\n  ```\r\n\r\n- 删除\r\n\r\n  ```php\r\n  $model = new PostModel;\r\n  $deleteCount = $model->deleteByPk(\'1,2,3\');//pk是字符串\r\n  $deleteCount = $model->deleteByPk([1,2,3]);//pk是数组\r\n  $deleteCount = $model->delete([\'id\'=>[1,2,3]]);//根据where条件删除\r\n  ```\r\n\r\n- 修改\r\n\r\n  ```php\r\n  $model = new PostModel;\r\n  $data = [\r\n      \'content\'   =>  \'this is 444\',\r\n  ];\r\n  $affectRows = $model->updateByPk($data,\'10,11,12\');//pk是字符串\r\n  $affectRows = $model->updateByPk($data,[10,11]);//pk是数组\r\n  \r\n  $where = [\'id\'=>10];\r\n  $affectRows = $model->update($data,$where);//根据where条件修改\r\n  ```\r\n\r\n- 查询单条数据\r\n\r\n  ```php\r\n  $data = $model->fields([\'title\',\'content\'])->where([\'id\'=>10])->get();//查询字段是数组\r\n  $data = $model->fields([\'title\',\'content\'])->where([\'id\'=>10])->get();//查询字段是字符串\r\n  \r\n  $where = [\'id\'=>10];\r\n  $data = $model->get($where);//查询所有字段\r\n  \r\n  $where = [\'id\'=>10];\r\n  $fields = [\'title\',\'content\'];\r\n  $data = $model->get($where,$fields);//查询部分字段\r\n  \r\n  $data = $model->findByPk(10);//查询所有字段\r\n  $data = $model->findByPk(10,\'title,content\');//查询部分字段\r\n  $data = $model->findByPk(10,[\'title\',\'content\']);//查询部分字段\r\n  ```\r\n\r\n- 查询多条数据\r\n\r\n  ```php\r\n  $data = $model->fields([\'title\',\'content\'])->where([\'id\'=>10])->all();//查询字段是数组\r\n  $data = $model->fields([\'title\',\'content\'])->where([\'id\'=>10])->all();//查询字段是字符串\r\n  \r\n  $where = [\'id\'=>10];\r\n  $data = $model->all($where);//查询所有字段\r\n  \r\n  $where = [\'id\'=>10];\r\n  $fields = [\'title\',\'content\'];\r\n  $data = $model->all($where,$fields);//查询部分字段\r\n  \r\n  $data = $model->findAll();//查询所有数据\r\n  \r\n  $pks = [1,2,3];\r\n  $fields = [\'title\',\'content\'];\r\n  $data = $model->findAll($pks,$fields);\r\n  \r\n  //根据where条件查找\r\n  $where = [\'id\'=>[4,5]];\r\n  $fields = [\'title\',\'content\'];\r\n  $data = $model->findByCondition($where,$fields);\r\n  ```\r\n\r\n- 其它\r\n\r\n  ```php\r\n  $data = [\r\n      \'id\'        =>  10,//主键\r\n      \'content\'   =>  \'add\'\r\n  ];\r\n  $result = $model->updateOrCreate($data);//更改id是10的记录\r\n  \r\n  $data = [\r\n      \'content\'   =>  \'add\'\r\n  ];\r\n  $result = $model->updateOrCreate($data);//没有主键，表示新增\r\n  \r\n  $model->getLastSql();//获取最后执行的sql语句\r\n  \r\n  //进行复杂的查询\r\n  $model->query(\"SELECT u.* from post p join user u on p.uid=u.uid \");\r\n  ```\r\n\r\n### 日志\r\n\r\n支持debug,info,warn,error,emergency五种级别的日志记录，日志文件会记录在logs目录的default目录下面，对应的日志方法如下:\r\n\r\n```php\r\nLogger::debug($keywords,$message);\r\nLogger::info($keywords,$message);\r\nLogger::warn($keywords,$message);\r\nLogger::error($keywords,$message);\r\nLogger::emergency($keywords,$message);\r\n```\r\n\r\n可以在config配置文件里面用配置项logging.level配置需要记录的日志级别\r\n\r\n### 配置项说明\r\n\r\n- 配置文件里面支持redis配置\r\n\r\n  ```shell\r\n  ;redis配置\r\n  redis.host = 127.0.0.1\r\n  redis.port = 6379\r\n  ;key前缀\r\n  redis.prefix = yaf: \r\n  redis.dbIndex = 0\r\n  ```\r\n\r\n- 是否开启调试模式(开启调试模式，错误信息会直接打印到页面上)\r\n\r\n  ```SHEL\r\n  application.debug = On\r\n  ```\r\n\r\n- 默认控制器\r\n\r\n  ```shel\r\n  application.dispatcher.defaultController = Home\r\n  ```\r\n\r\n- 默认action\r\n\r\n  ```php\r\n  application.dispatcher.defaultAction = index\r\n  ```\r\n\r\n  ',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,804,0),(79,'轻量级解析.env文件的类库，轻量到只需要一个类文件，可用于生产环境','79',1614004020,1614004051,'<!--markdown-->### 背景\r\nLaravel读取.env文件配置时，业务层里面访问一个配置项则Laravel底层会解析一次.env问题，那么Codeigniter4是这样的吗?最近有在读CodeIgniter4的源码,虽然现在还不是特别稳定，但是里面一些优秀的思想以及优秀的库还是值得学习的，比如其中的限流、异常界面实现、Kint调试利器等。今天再Codeigniter贴吧看到一个问答，是关于读取.env文件配置的问题，大致问题是:\r\n> Laravel读取.env文件配置时，业务层里面访问一个配置项则Laravel底层会解析一次.env问题，那么Codeigniter4是这样的吗?\r\n\r\n处于好奇，并且最近在看CodeIgniter，于是就研究了下CodeIngiter解析.env文件的方式，自己又稍作改动，自动解析bool、null变量。\r\n\r\n### 代码\r\n整个DotEnv.php文件内容如下\r\n```php\r\n<?php\r\n\r\n/**\r\n * Environment-specific configuration\r\n */\r\nclass DotEnv\r\n{\r\n	/**\r\n	 * The directory where the .env file can be located.\r\n	 *\r\n	 * @var string\r\n	 */\r\n	protected $path;\r\n\r\n	//--------------------------------------------------------------------\r\n\r\n	/**\r\n	 * Builds the path to our file.\r\n	 *\r\n	 * @param string $path\r\n	 * @param string $file\r\n	 */\r\n	public function __construct(string $path, string $file = \'.env\')\r\n	{\r\n		$this->path = rtrim($path, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR . $file;\r\n	}\r\n\r\n	//--------------------------------------------------------------------\r\n\r\n	/**\r\n	 * The main entry point, will load the .env file and process it\r\n	 * so that we end up with all settings in the PHP environment vars\r\n	 * (i.e. getenv(), $_ENV, and $_SERVER)\r\n	 *\r\n	 * @return boolean\r\n	 */\r\n	public function load(): bool\r\n	{\r\n		$vars = $this->parse();\r\n\r\n		return ($vars === null ? false : true);\r\n	}\r\n    \r\n    //--------------------------------------------------------------------\r\n\r\n	/**\r\n	 * get .env value by key name\r\n	 *\r\n	 * @return boolean|string|null\r\n	 */\r\n     \r\n    public function getenv($name) {\r\n        $value = $this->getVariable($name);\r\n        switch (strtolower($value)) {\r\n            case \'true\':\r\n            case \'(true)\':\r\n                return true;\r\n            case \'false\':\r\n            case \'(false)\':\r\n                return false;\r\n            case \'empty\':\r\n            case \'(empty)\':\r\n                return \'\';\r\n            case \'null\':\r\n            case \'(null)\':\r\n                return;\r\n        }\r\n        return $value;\r\n    }\r\n\r\n	//--------------------------------------------------------------------\r\n\r\n	/**\r\n	 * Parse the .env file into an array of key => value\r\n	 *\r\n	 * @return array|null\r\n	 */\r\n	protected function parse(): ?array\r\n	{\r\n		// We don\'t want to enforce the presence of a .env file, they should be optional.\r\n		if (! is_file($this->path))\r\n		{\r\n			return null;\r\n		}\r\n\r\n		// Ensure the file is readable\r\n		if (! is_readable($this->path))\r\n		{\r\n			throw new InvalidArgumentException(\"The .env file is not readable: {$this->path}\");\r\n		}\r\n\r\n		$vars = [];\r\n\r\n		$lines = file($this->path, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);\r\n\r\n		foreach ($lines as $line)\r\n		{\r\n			// Is it a comment?\r\n			if (strpos(trim($line), \'#\') === 0)\r\n			{\r\n				continue;\r\n			}\r\n\r\n			// If there is an equal sign, then we know we are assigning a variable.\r\n			if (strpos($line, \'=\') !== false)\r\n			{\r\n				list($name, $value) = $this->normaliseVariable($line);\r\n				$vars[$name]        = $value;\r\n				$this->setVariable($name, $value);\r\n			}\r\n		}\r\n\r\n		return $vars;\r\n	}\r\n\r\n	//--------------------------------------------------------------------\r\n\r\n	/**\r\n	 * Sets the variable into the environment. Will parse the string\r\n	 * first to look for {name}={value} pattern, ensure that nested\r\n	 * variables are handled, and strip it of single and double quotes.\r\n	 *\r\n	 * @param string $name\r\n	 * @param string $value\r\n	 */\r\n	protected function setVariable(string $name, string $value = \'\')\r\n	{\r\n		if (! getenv($name, true))\r\n		{\r\n			putenv(\"$name=$value\");\r\n		}\r\n\r\n		if (empty($_ENV[$name]))\r\n		{\r\n			$_ENV[$name] = $value;\r\n		}\r\n\r\n		if (empty($_SERVER[$name]))\r\n		{\r\n			$_SERVER[$name] = $value;\r\n		}\r\n	}\r\n\r\n	//--------------------------------------------------------------------\r\n\r\n	/**\r\n	 * Parses for assignment, cleans the $name and $value, and ensures\r\n	 * that nested variables are handled.\r\n	 *\r\n	 * @param string $name\r\n	 * @param string $value\r\n	 *\r\n	 * @return array\r\n	 */\r\n	protected function normaliseVariable(string $name, string $value = \'\'): array\r\n	{\r\n		// Split our compound string into its parts.\r\n		if (strpos($name, \'=\') !== false)\r\n		{\r\n			list($name, $value) = explode(\'=\', $name, 2);\r\n		}\r\n\r\n		$name  = trim($name);\r\n		$value = trim($value);\r\n\r\n		// Sanitize the name\r\n		$name = str_replace([\'export\', \'\\\'\', \'\"\'], \'\', $name);\r\n\r\n		// Sanitize the value\r\n		$value = $this->sanitizeValue($value);\r\n\r\n		$value = $this->resolveNestedVariables($value);\r\n\r\n		return [\r\n			$name,\r\n			$value,\r\n		];\r\n	}\r\n\r\n	//--------------------------------------------------------------------\r\n\r\n	/**\r\n	 * Strips quotes from the environment variable value.\r\n	 *\r\n	 * This was borrowed from the excellent phpdotenv with very few changes.\r\n	 * https://github.com/vlucas/phpdotenv\r\n	 *\r\n	 * @param string $value\r\n	 *\r\n	 * @return string\r\n	 * @throws InvalidArgumentException\r\n	 */\r\n	protected function sanitizeValue(string $value): string\r\n	{\r\n		if (! $value)\r\n		{\r\n			return $value;\r\n		}\r\n\r\n		// Does it begin with a quote?\r\n		if (strpbrk($value[0], \'\"\\\'\') !== false)\r\n		{\r\n			// value starts with a quote\r\n			$quote        = $value[0];\r\n			$regexPattern = sprintf(\r\n					\'/^\r\n					%1$s          # match a quote at the start of the value\r\n					(             # capturing sub-pattern used\r\n								  (?:          # we do not need to capture this\r\n								   [^%1$s\\\\\\\\] # any character other than a quote or backslash\r\n								   |\\\\\\\\\\\\\\\\   # or two backslashes together\r\n								   |\\\\\\\\%1$s   # or an escaped quote e.g \\\"\r\n								  )*           # as many characters that match the previous rules\r\n					)             # end of the capturing sub-pattern\r\n					%1$s          # and the closing quote\r\n					.*$           # and discard any string after the closing quote\r\n					/mx\', $quote\r\n			);\r\n\r\n			$value = preg_replace($regexPattern, \'$1\', $value);\r\n			$value = str_replace(\"\\\\$quote\", $quote, $value);\r\n			$value = str_replace(\'\\\\\\\\\', \'\\\\\', $value);\r\n		}\r\n		else\r\n		{\r\n			$parts = explode(\' #\', $value, 2);\r\n\r\n			$value = trim($parts[0]);\r\n\r\n			// Unquoted values cannot contain whitespace\r\n			if (preg_match(\'/\\s+/\', $value) > 0)\r\n			{\r\n				throw new InvalidArgumentException(\'.env values containing spaces must be surrounded by quotes.\');\r\n			}\r\n		}\r\n\r\n		return $value;\r\n	}\r\n\r\n	//--------------------------------------------------------------------\r\n\r\n	/**\r\n	 *  Resolve the nested variables.\r\n	 *\r\n	 * Look for ${varname} patterns in the variable value and replace with an existing\r\n	 * environment variable.\r\n	 *\r\n	 * This was borrowed from the excellent phpdotenv with very few changes.\r\n	 * https://github.com/vlucas/phpdotenv\r\n	 *\r\n	 * @param string $value\r\n	 *\r\n	 * @return string\r\n	 */\r\n	protected function resolveNestedVariables(string $value): string\r\n	{\r\n		if (strpos($value, \'$\') !== false)\r\n		{\r\n			$value = preg_replace_callback(\r\n				\'/\\${([a-zA-Z0-9_]+)}/\',\r\n				function ($matchedPatterns) {\r\n					$nestedVariable = $this->getVariable($matchedPatterns[1]);\r\n\r\n					if (is_null($nestedVariable))\r\n					{\r\n						return $matchedPatterns[0];\r\n					}\r\n\r\n					return $nestedVariable;\r\n				},\r\n				$value\r\n			);\r\n		}\r\n\r\n		return $value;\r\n	}\r\n\r\n	//--------------------------------------------------------------------\r\n\r\n	/**\r\n	 * Search the different places for environment variables and return first value found.\r\n	 *\r\n	 * This was borrowed from the excellent phpdotenv with very few changes.\r\n	 * https://github.com/vlucas/phpdotenv\r\n	 *\r\n	 * @param string $name\r\n	 *\r\n	 * @return string|null\r\n	 */\r\n	protected function getVariable(string $name)\r\n	{\r\n		switch (true)\r\n		{\r\n			case array_key_exists($name, $_ENV):\r\n				return $_ENV[$name];\r\n			case array_key_exists($name, $_SERVER):\r\n				return $_SERVER[$name];\r\n			default:\r\n				$value = getenv($name);\r\n\r\n				// switch getenv default to null\r\n				return $value === false ? null : $value;\r\n		}\r\n	}\r\n\r\n	//--------------------------------------------------------------------\r\n}\r\n\r\n```\r\n.env文件内容如下\r\n\r\n```shell\r\n\r\n# app配置\r\nAPP_DEBUG = False\r\nAPP_URL=http://localhost\r\nAPP_NAME = \"json 博客\" #值有空格等特殊字符，用引号括起来\r\n\r\n#数据库配置\r\nDB_HOST=localhost  #数据库名,这是注释\r\nDB_PORT=3306\r\nDB_DATABASE=demo\r\nDB_USERNAME=root\r\nDB_PASSWORD=root\r\nDB_DSN = \"mysql://${DB_USERNAME}:${DB_PASSWORD}@${DB_HOST}/${DB_DATABASE}\"\r\n\r\n#redis配置\r\nREDIS_HOST=127.0.0.1\r\nREDIS_PASSWORD=null\r\nREDIS_PORT=6379\r\nREDIS_PREFIX=\r\n\r\n\r\n#这是注释\r\n\r\n```\r\n\r\n### 使用方式\r\n\r\n```php\r\nrequire_once \'./DotEnv.php\';\r\n\r\n$env = new DotEnv(\'./\');//参数是.env文件所在目录\r\n$env->load();\r\n\r\nvar_dump($env->getenv(\"APP_NAME\"));\r\nvar_dump($env->getenv(\"APP_DEBUG\"));//自动解析bool结果true\r\nvar_dump($env->getenv(\"DB_DSN\"));//支持嵌套变量\r\nvar_dump($env->getenv(\"REDIS_PASSWORD\"));//自动解析null字符串为null值\r\n```\r\n\r\n### 输出结果\r\n```shell\r\nstring(11) \"json 博客\"\r\nbool(false)\r\nstring(32) \"mysql://root:root@localhost/demo\"\r\nNULL\r\n```\r\n\r\n### 注意\r\n- 如果值里面有空格需要用单引号、双引号引用起来\r\n- 支持值嵌套，用${xx}表示变量\r\n- 以#开头的行是注释，不会解析\r\n- 行内支持注释，#后面的不会解析为value\r\n- False、false、FALSE解析成false布尔值\r\n- True、true、TRUE解析成true布尔值\r\n- null字符串解析成null类型值\r\n',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,645,1),(80,'沉淀积累','80',1615098840,1645270246,'<!--markdown-->### ide\r\n- notepad++\r\n- vscode\r\n  - Better Align\r\n  - Better Comments\r\n  - Bracket Pair Colorizer\r\n  - Code Spell Checker\r\n  - GitLens\r\n  - indent-rainbow\r\n  - Material Icon Theme/vscode-icons\r\n  - PHP DocBlocker\r\n  - Todo Tree\r\n  \r\n### 软件工具\r\n- **Xshell、SecureCRT**\r\n- 向日葵/teamviewer\r\n- **git、小乌龟**\r\n- Typora\r\n- Postman\r\n- Winscp\r\n- navicat\r\n- cmder\r\n- open-dingtalk 内网穿透\r\n- [RedisDesktop](https://github.com/qishibo/AnotherRedisDesktopManager)  redis客户端连接工具	\r\n- [Robomongo](https://robomongo.org/download)	mongo客户端连接工具	\r\n- [ScreenToGif](https://www.screentogif.com/)	gif录制工具	\r\n- FSCapture\r\n- **[Snipaste](https://www.snipaste.com/)	屏幕截图工具**	\r\n- ShowDoc   在线api文档\r\n\r\n### php集成包\r\n- wamp\r\n- phpstudy\r\n- xampp\r\n- MAMP Pro\r\n\r\n### Php\r\n\r\n- Yii\r\n- CodeIgniter\r\n- Thinkphp\r\n- 模板引擎\r\n	- Smarty\r\n	- Twig\r\n	- Blade\r\n- yac\r\n- **apcu**\r\n- **Workerman**\r\n- yar/yaf\r\n- league/flysystem\r\n- league/flysystem-cached-adapter\r\n- league/fractal\r\n- **robmorgan/phinx**\r\n- phpdocumentor/reflection-docblock\r\n- doctrine/instantiator\r\n- doctrine/inflector\r\n- **humbug/box**\r\n- phpoption/phpoption\r\n- **ukko/phpredis-phpdoc**\r\n- dragonmantank/cron-expression\r\n- egulias/email-validator\r\n- monolog/monolog\r\n- **predis/predis**\r\n- **kint-php/kint**\r\n- **vlucas/phpdotenv**\r\n- filp/whoops\r\n- swiftmailer/swiftmailer\r\n- symfony/error-handler\r\n- symfony/var-dumper\r\n- **symfony/console**\r\n- symfony/process\r\n- symfony/dotenv\r\n- symfony/filesystem\r\n- symfony/finder\r\n- symfony/yaml\r\n- symfony/polyfill\r\n- symfony/translation\r\n- symfony/translation-contracts\r\n- symfony/string\r\n- symfony/event-dispatcher\r\n- symfony/event-dispatcher-contracts\r\n- pda/pheanstalk\r\n- ralouphie/getallheaders\r\n- mobiledetect/mobiledetectlib\r\n- phpmailer/phpmailer\r\n- ramsey/uuid\r\n- phpoffice/phpspreadsheet\r\n\r\n### php代码美化\r\n- php-cs-fixer/php_codesniffer\r\n- phpmd\r\n- phpstan\r\n- phpro/grumphp\r\n\r\n### Javascript&es6\r\n- layui\r\n- layer\r\n- jedate\r\n- fetch\r\n- art-template\r\n- moment.js\r\n- js-cookie\r\n- clipboard.js\r\n- Nunjucks\r\n- lodash\r\n- axios.js\r\n- prettier/lint\r\n- husky\r\n- winston\r\n- chalk\r\n- yargs\r\n- ora\r\n- shelljs\r\n- commander\r\n- inquirer.js\r\n- pkg\r\n- koa/koa-router/koa-bodyparser\r\n- sequelize-auto/sequelize-cli/sequelize\r\n- ioredis\r\n- pm2\r\n\r\n### Python\r\n- requests\r\n- click\r\n- fire\r\n- pipenv\r\n- python-dotenv\r\n- peewee\r\n- watchdog\r\n- python-rq\r\n\r\n### Go\r\n- uber/ratelimit\r\n- juju/ratelimit\r\n- uber/zap\r\n- NSQ\r\n- go-micro\r\n- echo\r\n- **gin**\r\n- **gorm**\r\n- **fresh热更新**\r\n- **go-redis**\r\n- **go-ini**\r\n- **stretchr/testify**\r\n- **endless**\r\n- **robfig/cron**\r\n\r\n### 运维\r\n- Metrics\r\n- open-falcon \r\n- Sonar\r\n\r\n### 中间件\r\n\r\n-  Zookeeper\r\n- Nacos\r\n- MyCat\r\n- **Elasticsearch**\r\n- Dubbo/Spring Cloud\r\n- **RabbitMQ/RocketMQ**\r\n- **MongoDB**\r\n- Memcache\r\n- etcd+confd\r\n- Kafka/NSQ/Pulsar\r\n- protobuf\r\n- Gearman\r\n- beanstalkd\r\n   - ptrofimov/beanstalk_console\r\n   - xuri/aurora\r\n   - pheanstalk/pheanstalk \r\n- XXL-JOB\r\n  \r\n### Linux\r\n- oh-my-zsh\r\n- vim-plug\r\n\r\n### 语言\r\n\r\n- Python\r\n- JavaScript\r\n- Shell\r\n\r\n### 概念\r\n\r\n- 缓存\r\n - 缓存穿透\r\n - 缓存击穿\r\n - 缓存雪崩\r\n- 分布式事务\r\n - XA\r\n -  SAGA \r\n - TCC\r\n - **本地消息**  --最终一致性\r\n - **事务消息**  --最终一致性\r\n - 最大努力通知\r\n- RPC',2,2,NULL,'page','hidden',NULL,0,'1','1','1',0,81,0),(81,'linux笔记','81',1615099523,1615099523,'<!--markdown-->\r\n- 目录内文件内容替换\r\n```shell\r\n//当前目录内字符串Phalcon替换为Tools\r\ngrep -Rl C . | xargs sed -i \'s#Phalcon#Tools#g\'\r\n```\r\n\r\n- 递归删除目录下匹配的文件\r\n```shell\r\nfind . -name \'.php_cs.cache\' -delete\r\n```',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,570,0),(82,'一个优秀的的vim配置文件.vimrc','82',1615101120,1615101240,'<!--markdown-->积累了一个基于Plug的vim配置，分享个大家，包括但不限于如下插件\r\n\r\n- 支持自定义主题，包括onedark、molokai、solarized等\r\n- 自动完成匹配引号、括号\r\n- 函数搜索\r\n- 目录结构\r\n- 代码美化、代码格式化\r\n- 语法检查\r\n- 彩虹括号\r\n\r\n```shell\r\n\"去除vi一致性\r\nset nocompatible\r\n\"设置 backspace可以删除任意字符\r\nset backspace=2\r\nsyntax enable\r\n\"缩进\r\nset autoindent\r\nset shiftwidth=4\r\nset tabstop=4\r\nset expandtab\r\nset smarttab\r\n\"设置编码\r\nset fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936\r\nset termencoding=utf-8\r\nset encoding=utf-8\r\nset fileencodings=ucs-bom,utf-8,cp936\r\nset fileencoding=utf-8\r\n\"显示行号\r\nset number\r\n\"显示光标当前位置\r\nset ruler\r\n\"突出当前行\r\nset cursorline\r\n\"共享剪切板\r\nset clipboard+=unnamed\r\n\"从不备份\r\nset nobackup\r\n\"高亮搜索项\r\nset hlsearch\r\n\"启用文件类型检测\r\nfiletype plugin indent on\r\n\"自动跳到上次打开的光标位置\r\nif has(\"autocmd\")\r\n  au BufReadPost * if line(\"\'\\\"\") > 1 && line(\"\'\\\"\") <= line(\"$\") | exe \"normal! g\'\\\"\" | endif\r\nendif\r\n\r\ncall plug#begin(\'~/.vim/plugged\')\r\n	\"成对删除或插入括号,引号\r\n	Plug \'jiangmiao/auto-pairs\'\r\n	\"ctrl+p 文件搜索\r\n	Plug \'ctrlpvim/ctrlp.vim\'\r\n	\"函数搜索\r\n	Plug \'tacahiroy/ctrlp-funky\'\r\n	\"树形目录\r\n	Plug \'preservim/nerdtree\'\r\n	Plug \'jistr/vim-nerdtree-tabs\'\r\n	\"代码注释\r\n	Plug \'tpope/vim-commentary\'\r\n	\"成对符号编辑\r\n	Plug \'tpope/vim-repeat\'\r\n	Plug \'tpope/vim-surround\'\r\n	\"彩虹括号\r\n	Plug \'luochen1990/rainbow\'\r\n	\"语法检查\r\n	Plug \'tpope/vim-pathogen\'\r\n	Plug \'scrooloose/syntastic\'\r\n	\"各种主题\r\n    Plug \'joshdick/onedark.vim\'\r\n    Plug \'altercation/vim-colors-solarized\'\r\n    Plug \'sickill/vim-monokai\'\r\n    Plug \'tomasr/molokai\'\r\n    Plug \'liuchengxu/space-vim-dark\'\r\n    Plug \'morhetz/gruvbox\'\r\n    Plug \'jpo/vim-railscasts-theme\'\r\n    Plug \'cormacrelf/vim-colors-github\'\r\n    Plug \'nanotech/jellybeans.vim\'\r\n    Plug \'rakr/vim-one\'\r\n    Plug \'jdkanani/vim-material-theme\'\r\n    Plug \'dracula/vim\'\r\n    Plug \'NLKNguyen/papercolor-theme\'\r\n	\"对齐\r\n	Plug \'godlygeek/tabular\'\r\n    \"状态栏\r\n    Plug \'vim-airline/vim-airline\'\r\n    \"缩进\r\n    Plug \'Yggdroot/indentLine\'\r\n    \"多光标操作\r\n    Plug \'terryma/vim-multiple-cursors\'\r\n\r\n    \"行尾空格标红，命令模式:FixWhitespace去文件内所有行尾空格\r\n    Plug \'bronson/vim-trailing-whitespace\'\r\n    \"css color\r\n    Plug \'ap/vim-css-color\'\r\n    \"tagbar 依赖Exuberant Ctags >= 5.5\r\n    Plug \'majutsushi/tagbar\'\r\n\r\n    \"php代码格式化\r\n    \"依赖php-cs-fixer， php-cs-fixer要求php>=5.6\r\n    \"a.下载: wget https://cs.symfony.com/download/php-cs-fixer-v2.phar -O php-cs-fixer\r\n    \"b.修改mod: sudo chmod a+x php-cs-fixer\r\n    \"c.移动到PATH: sudo mv php-cs-fixer /usr/local/bin/php-cs-fixer\r\n    Plug \'stephpy/vim-php-cs-fixer\'\r\n\r\n    \"editorconfig插件\r\n    Plug \'editorconfig/editorconfig-vim\'\r\ncall plug#end()\r\n\r\n\"=========================设置主题的几种方式==============================\r\n\"solarized主题\r\n\"if has(\'gui_running\')\r\n\"    set background=light\r\n\"else\r\n\"    set background=dark\r\n\"endif\r\n\"colorscheme solarized\r\n\r\n\"onedark包中的主题\r\nlet g:onedark_termcolors=256\r\ncolorscheme onedark\r\n\r\n\"monokai包主题\r\n\"colorscheme monokai\r\n\r\n\"molokai主题\r\n\"set t_Co=256\r\n\"colorscheme molokai\r\n\r\n\"space vim dark主题\r\n\"set t_Co=256\r\n\"colorscheme space-vim-dark\r\n\r\n\"gruvbox主题\r\n\"set t_Co=256\r\n\"set background=dark\r\n\"set background=light\r\n\"colorscheme gruvbox\r\n\r\n\"railscast主题\r\n\"set t_Co=256\r\n\"colorscheme railscasts\r\n\r\n\"github主题\r\n\"set t_Co=256\r\n\"colorscheme github\r\n\r\n\"jellybeans主题\r\n\"set t_Co=256\r\n\"colorscheme jellybeans\r\n\r\n\"one主题\r\n\"set t_Co=256\r\n\"set background=dark\r\n\"set background=light\r\n\"colorscheme one\r\n\r\n\"jdkanani/vim-material-theme\r\n\"set t_Co=256\r\n\"set background=dark\r\n\"colorscheme material-theme\r\n\r\n\"dracula主题\r\n\"set t_Co=256\r\n\"colorscheme dracula\r\n\r\n\"PaperColor主题\r\n\"set t_Co=256\r\n\"set background=light\r\n\"set background=dark\r\n\"colorscheme PaperColor\r\n\r\n\"=========================设置主题end=====================================\r\n\r\n\r\n\"树形目录配置\r\nmap <C-n> :NERDTreeToggle<CR>\r\n\" open NERDTree automatically when vim starts up if no files were specified\r\nautocmd StdinReadPre * let s:std_in=1\r\nautocmd VimEnter * if argc() == 0 && !exists(\"s:std_in\") | NERDTree | endif\r\n\" close vim if the only window left is a NERDTree\r\nautocmd bufenter * if (winnr(\"$\") == 1 && exists(\"b:NERDTreeType\") && b:NERDTreeType == \"primary\") | q | endif\r\nlet NERDTreeHighlightCursorline=1\r\nlet NERDTreeIgnore=[ \'\\.pyc$\', \'\\.pyo$\', \'\\.obj$\', \'\\.o$\', \'\\.so$\', \'\\.egg$\', \'^\\.git$\', \'^\\.svn$\', \'^\\.hg$\' ]\r\nlet g:NERDTreeWinPos = \"right\"\r\nmap <Leader>nn :NERDTreeTabsToggle<CR>\r\nmap <leader>nb :NERDTreeFromBookmark\r\nmap <leader>nf :NERDTreeFind<cr>\r\nlet g:NERDTreeMapOpenSplit = \'s\'\r\nlet g:NERDTreeMapOpenVSplit = \'v\'\r\nmap <Leader>n <plug>NERDTreeTabsToggle<CR>\r\nlet g:nerdtree_tabs_synchronize_view=1\r\nlet g:nerdtree_tabs_synchronize_focus=0\r\n\" 是否显示隐藏文件\r\nlet NERDTreeShowHidden=1\r\n\"设置宽度\r\n let NERDTreeWinSize=25\r\n\"忽略一下文件的显示\r\nlet NERDTreeIgnore=[\'\\.pyc\',\'\\~$\',\'\\.swp\']\r\n\r\n\"代码注释配置\r\n\"为python和shell等添加注释\r\nautocmd FileType python,shell,coffee set commentstring=#\\ %s\r\n\"修改注释风格\r\nautocmd FileType java,c,cpp,php set commentstring=//\\ %s\r\n\r\n\"ctrl+p 文件搜索\r\n\"set wildignore+=*/tmp/*,*.so,*.swp,*.zip     \" MacOSX/Linux\"\r\nlet g:ctrlp_custom_ignore = {\r\n    \\ \'dir\':  \'\\v[\\/]\\.(git|hg|svn|rvm)$\',\r\n    \\ \'file\': \'\\v\\.(exe|so|dll|zip|tar|tar.gz)$\',\r\n    \\ }\r\n\"\\ \'link\': \'SOME_BAD_SYMBOLIC_LINKS\',\r\nlet g:ctrlp_working_path_mode=0\r\nlet g:ctrlp_match_window_bottom=1\r\nlet g:ctrlp_max_height=15\r\nlet g:ctrlp_match_window_reversed=0\r\nlet g:ctrlp_mruf_max=500\r\nlet g:ctrlp_follow_symlinks=1\r\n\r\n\"函数搜索\r\nnnoremap <Leader>fu :CtrlPFunky<Cr>\r\n\" narrow the list down with a word under cursor\r\nnnoremap <Leader>fU :execute \'CtrlPFunky \' . expand(\'<cword>\')<Cr>\r\nlet g:ctrlp_funky_syntax_highlight = 1\r\nlet g:ctrlp_extensions = [\'funky\']\r\n\r\n\"状态栏设置\r\nlet g:airline#extensions#tabline#enabled = 1\r\n\r\n\"彩虹括号\r\nlet g:rainbow_active = 1\r\n\r\n\"语法检查配置\r\nexecute pathogen#infect()\r\nset statusline+=%#warningmsg#\r\nset statusline+=%{SyntasticStatuslineFlag()}\r\nset statusline+=%*\r\nlet g:syntastic_always_populate_loc_list = 1\r\nlet g:syntastic_auto_loc_list = 1\r\nlet g:syntastic_check_on_open = 1\r\nlet g:syntastic_check_on_wq = 0\r\n\r\n\"缩进配置\r\nlet g:indentLine_color_term = 239\r\n\"let g:indentLine_char = \'┆\'\r\n\r\n\"多光标控制\r\n\"使用方法:ctrl+j选择下一行，ctrl+k选择前一行，ctrl+x跳过当前行，再命令行模式c进行删除替换\r\nlet g:multi_cursor_use_default_mapping=0\r\n\" Default mapping\r\nlet g:multi_cursor_next_key=\'<C-j>\'\r\nlet g:multi_cursor_prev_key=\'<C-k>\'\r\nlet g:multi_cursor_skip_key=\'<C-x>\'\r\nlet g:multi_cursor_quit_key=\'<Esc>\'\r\n\r\n\"tagbar\r\n\"F9触发，设置宽度为30\r\nlet g:tagbar_width = 30\r\nnmap <F9> :TagbarToggle<CR>\r\n\"开启自动预览(随着光标在标签上的移动，顶部会出现一个实时的预览窗口)\r\nlet g:tagbar_autopreview = 1\r\n\"关闭排序,即按标签本身在文件中的位置排序\r\nlet g:tagbar_sort = 0\r\n\"设置tagbar的窗口显示的位置,为右边\r\nlet g:tagbar_right_=1\r\n\"打开文件自动 打开\r\n\"autocmd BufReadPost *.* call tagbar#autoopen()\"\r\n\r\n\"php代码格式化配置\r\n\" If php-cs-fixer is in $PATH, you don\'t need to define line below\r\n\" let g:php_cs_fixer_path = \"~/php-cs-fixer.phar\" \" define the path to the php-cs-fixer.phar\r\n\r\n\" If you use php-cs-fixer version 1.x\r\nlet g:php_cs_fixer_level = \"symfony\"                   \" options: --level (default:symfony)\r\nlet g:php_cs_fixer_config = \"default\"                  \" options: --config\r\n\" If you want to define specific fixers:\r\n\"let g:php_cs_fixer_fixers_list = \"linefeed,short_tag\" \" options: --fixers\r\n\"let g:php_cs_fixer_config_file = \'.php_cs\'            \" options: --config-file\r\n\" End of php-cs-fixer version 1 config params\r\n\r\n\" If you use php-cs-fixer version 2.x\r\nlet g:php_cs_fixer_rules = \"@PSR2\"          \" options: --rules (default:@PSR2)\r\n\"let g:php_cs_fixer_cache = \".php_cs.cache\" \" options: --cache-file\r\n\"let g:php_cs_fixer_config_file = \'.php_cs\' \" options: --config\r\n\" End of php-cs-fixer version 2 config params\r\n\r\nlet g:php_cs_fixer_php_path = \"php\"               \" Path to PHP\r\nlet g:php_cs_fixer_enable_default_mapping = 1     \" Enable the mapping by default (<leader>pcd)\r\nlet g:php_cs_fixer_dry_run = 0                    \" Call command with dry-run option\r\nlet g:php_cs_fixer_verbose = 0                    \" Return the output of command if 1, else an inline information.\r\n\r\nautocmd BufWritePost *.php silent! call PhpCsFixerFixFile()\r\n```',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,1003,1),(83,'php异步执行方式','83',1615102528,1615102528,'<!--markdown-->- nohup\r\n用nohup配合&,php可以作为linux守护进程运行\r\n```shell\r\nnohup /usr/local/bin/php /opt/cron.php 2>&1 /dev/null &\r\n```\r\n\r\n- popen函数\r\npopen函数可以实现异步调用\r\n```shell\r\npclose(popen(\'/usr/local/bin/php /opt/cron.php &\',\'r\'));\r\n```',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,620,0),(104,'如何获取文件里面的类名','104',1630294200,1630294392,'<!--markdown-->下面是一个根据文件内容获取文件里面命名空间格式类名的方法，方便进行健壮性操作。\r\n\r\n```php\r\nfunction getClassname(string $file)\r\n{\r\n    $php       = file_get_contents($file);\r\n    $tokens    = token_get_all($php);\r\n    $dlm       = false;\r\n    $namespace = \'\';\r\n    $className = \'\';\r\n\r\n    foreach ($tokens as $i => $token)\r\n    {\r\n        if ($i < 2)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        if ((isset($tokens[$i - 2][1]) && ($tokens[$i - 2][1] === \'phpnamespace\' || $tokens[$i - 2][1] === \'namespace\')) || ($dlm && $tokens[$i - 1][0] === T_NS_SEPARATOR && $token[0] === T_STRING))\r\n        {\r\n            if (! $dlm)\r\n            {\r\n                $namespace = 0;\r\n            }\r\n            if (isset($token[1]))\r\n            {\r\n                $namespace = $namespace ? $namespace . \'\\\\\' . $token[1] : $token[1];\r\n                $dlm       = true;\r\n            }\r\n        }\r\n        elseif ($dlm && ($token[0] !== T_NS_SEPARATOR) && ($token[0] !== T_STRING))\r\n        {\r\n            $dlm = false;\r\n        }\r\n\r\n        if (($tokens[$i - 2][0] === T_CLASS || (isset($tokens[$i - 2][1]) && $tokens[$i - 2][1] === \'phpclass\'))\r\n            && $tokens[$i - 1][0] === T_WHITESPACE\r\n            && $token[0] === T_STRING)\r\n        {\r\n            $className = $token[1];\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (empty($className))\r\n    {\r\n        return \'\';\r\n    }\r\n\r\n    return $namespace . \'\\\\\' . $className;\r\n}\r\n\r\n```\r\n\r\n使用方法:\r\n\r\n```php\r\n//UserModel.php\r\n<?php\r\nnamespace App\\Models;\r\n\r\nclass UserModel {\r\n    \r\n}\r\n```\r\n\r\n```php\r\nvar_dump(getClassname(\'./UserModel.php\'));//输出:string(20) \"App\\Models\\UserModel\"\r\n```',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,492,0),(100,'php坑之比较运算符==','100',1623373740,1623373820,'<!--markdown-->- 之前碰到过下面的细节坑\r\n```php\r\nvar_dump(\"true\" == 0);//返回true\r\nvar_dump(\"123abc\" == 123);//返回true\r\n```\r\n这个很好解释，就是当用int类型跟字符串进行比较时，底层会阴影做转换，将字符串转成int类型进行比较，字符串转int类型的规则是:**取字符串前列的数字直到非数字的位置**，然后转成整数。\r\n所以上面的例子\"true\"字符串第一个就是t，那就用0；\"123abc\"前面的数字的123，转成int类型123，也就成了123 == 123，返回true\r\n\r\n- 今天在工作中又发现一个没遇到过的基础问题:\r\n```php\r\nvar_dump(\"0000001\" == \"01\");//返回true\r\n```\r\n太神奇了，怎么可能是true呢，两侧都是字符比较啊，没办法只能找官方手册，\r\n官方在**[运算符](https://www.php.net/manual/zh/language.operators.comparison.php)**一节有这样的解释,如下:**当两个操作对象都是数字字符串， 或一个是数字另一个是数字字符串， 就会自动按照数值进行比较。 此规则也适用于 switch 语句。 当比较时用的是 === 或 !==， 则不会进行类型转换——因为不仅要对比数值，还要对比类型**。\r\n根据这个解释，我们可以看到`\"0000001\" == \"01\"`两侧都是数字型字符串，所以按照数值比较，也就是左侧是数值1，右侧也是数值1，所以就相等了。\r\n\r\n**注意:**这个问题在php8之前会有\r\n\r\n',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,599,0),(89,'window下git bash终端美化','89',1617265500,1617942337,'<!--markdown-->- 修改命令提示符\r\n以下所有命令都需要在 Git Bash 中执行\r\n```shell\r\nvim /etc/profile.d/git-prompt.sh\r\n```\r\n如果不熟悉 vim，并且电脑上装了 VSCode，可以用以下命令打开文件\r\n```shell\r\ncode /etc/profile.d/git-prompt.sh\r\n```\r\n将其修改为如下内容\r\n\r\n	```shell\r\n	if test -f /etc/profile.d/git-sdk.sh\r\n	then\r\n		TITLEPREFIX=SDK-${MSYSTEM#MINGW}\r\n	else\r\n		TITLEPREFIX=$MSYSTEM\r\n	fi\r\n\r\n	if test -f ~/.config/git/git-prompt.sh\r\n	then\r\n		. ~/.config/git/git-prompt.sh\r\n	else\r\n		PS1=\'\\[\\033]0;Bash\\007\\]\'      # 窗口标题\r\n		PS1=\"$PS1\"\'\\n\'                 # 换行\r\n		PS1=\"$PS1\"\'\\[\\033[32;1m\\]\'     # 高亮绿色\r\n		PS1=\"$PS1\"\'➜ \'               # unicode 字符，右箭头\r\n		PS1=\"$PS1\"\'\\[\\033[33;1m\\]\'     # 高亮黄色\r\n		PS1=\"$PS1\"\'\\W\'                 # 当前目录\r\n		if test -z \"$WINELOADERNOEXEC\"\r\n		then\r\n			GIT_EXEC_PATH=\"$(git --exec-path 2>/dev/null)\"\r\n			COMPLETION_PATH=\"${GIT_EXEC_PATH%/libexec/git-core}\"\r\n			COMPLETION_PATH=\"${COMPLETION_PATH%/lib/git-core}\"\r\n			COMPLETION_PATH=\"$COMPLETION_PATH/share/git/completion\"\r\n			if test -f \"$COMPLETION_PATH/git-prompt.sh\"\r\n			then\r\n				. \"$COMPLETION_PATH/git-completion.bash\"\r\n				. \"$COMPLETION_PATH/git-prompt.sh\"\r\n				PS1=\"$PS1\"\'\\[\\033[31m\\]\'   # 红色\r\n				PS1=\"$PS1\"\'`__git_ps1`\'    # git 插件\r\n			fi\r\n		fi\r\n		PS1=\"$PS1\"\'\\[\\033[36m\\] \'      # 青色\r\n	fi\r\n\r\n	MSYS2_PS1=\"$PS1\"\r\n	```\r\n效果如下：\r\n![git_1.gif](http://www.fxjson.com/usr/uploads/2021/04/892709726.gif)\r\n\r\n- 解决 Unicode 字符显示异常问题\r\n - [下载](https://raw.githubusercontent.com/powerline/fonts/master/DejaVuSansMono/DejaVu%20Sans%20Mono%20for%20Powerline.ttf)DejaVu Sans Mono 字体\r\n - 执行以下命令，会打开字体文件夹，将字体托进去会自动安装，然后将修改 Git Bash 的字体就能正常显示 Unicode 字符了。(start 是 cmd 所提供的命令)\r\n ```shell\r\n  start c://Windows//Fonts\r\n ```\r\n\r\n- 修改主题\r\n	```shell\r\n	vim ~/.minttyrc\r\n	```\r\n	内容如下:\r\n	```shell\r\nFont=DejaVu Sans Mono for Powerline\r\nFontHeight=14\r\nTransparency=low\r\nFontSmoothing=default\r\nLocale=C\r\nCharset=UTF-8\r\nColumns=88\r\nRows=26\r\nOpaqueWhenFocused=no\r\nScrollbar=none\r\nLanguage=zh_CN\r\nForegroundColour=131,148,150\r\nBackgroundColour=0,43,54\r\nCursorColour=220,130,71\r\nBoldBlack=128,128,128\r\nRed=255,64,40\r\nBoldRed=255,128,64\r\nGreen=64,200,64\r\nBoldGreen=64,255,64\r\nYellow=190,190,0\r\nBoldYellow=255,255,64\r\nBlue=0,128,255\r\nBoldBlue=128,160,255\r\nMagenta=211,54,130\r\nBoldMagenta=255,128,255\r\nCyan=64,190,190\r\nBoldCyan=128,255,255\r\nWhite=200,200,200\r\nBoldWhite=255,255,255\r\nBellTaskbar=no\r\nTerm=xterm\r\nFontWeight=400\r\nFontIsBold=no\r\nRightClickAction=paste\r\n	```\r\n效果如下:\r\n![git_2.gif](http://www.fxjson.com/usr/uploads/2021/04/3002196454.gif)\r\n- 重启git终端',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,1794,1),(85,'console.png','console-png',1615338319,1615338319,'a:5:{s:4:\"name\";s:11:\"console.png\";s:4:\"path\";s:35:\"/usr/uploads/2021/03/2498297245.png\";s:4:\"size\";i:14148;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',1,2,NULL,'attachment','publish',NULL,0,'1','0','1',86,0,0),(86,'一个简易的php命令行带颜色输出类','86',1615338360,1615338470,'<!--markdown-->写了一个简单的console类，linux命令行下可以输出7种不同颜色的字体,有命令行需求的时候可以直接拿来用。代码如下\r\n```php\r\nclass Console {\r\n\r\n    private static $modesList = [\r\n        [\r\n            \'name\'  =>  \"log\",   \r\n            \'color\' =>  \"white\",  \r\n            \'font\'  =>   37,\r\n        ],\r\n        [\r\n            \'name\'  =>  \"error\", \r\n            \'color\' =>  \"red\",   \r\n            \'font\'  =>  31\r\n        ],\r\n        [\r\n            \'name\'  =>  \"debug\", \r\n            \'color\' =>  \"cyan\",   \r\n            \'font\'  =>  36\r\n        ],\r\n        [\r\n            \'name\'  =>  \"info\", \r\n            \'color\' =>  \"green\",   \r\n            \'font\'  =>  32\r\n        ],\r\n        [\r\n            \'name\'  =>  \"warn\", \r\n            \'color\' =>  \"yellow\",   \r\n            \'font\'  =>  33\r\n        ],\r\n        [\r\n            \'name\'  =>  \"trace\", \r\n            \'color\' =>  \"blue\",   \r\n            \'font\'  =>  34\r\n        ],\r\n        [\r\n            \'name\'  =>  \"fatal\", \r\n            \'color\' =>  \"magenta\",   \r\n            \'font\'  =>  35\r\n        ]\r\n    ];\r\n\r\n    private static function isWindows() {\r\n        return strtolower(substr(PHP_OS, 0, 3)) === \'win\';\r\n    }\r\n\r\n    private static function isCli() {\r\n        return preg_match(\"/cli/i\", php_sapi_name()) ? true : false;\r\n    }\r\n\r\n    public static function __callStatic($method,$arguments) {\r\n        $colorDict = array_column(self::$modesList,\'font\',\'color\');\r\n        $levelDict = array_column(self::$modesList,\'font\',\'name\');\r\n        if(!isset($colorDict[$method]) && !isset($levelDict[$method])) {\r\n            throw new Exception(\"方法不存在\");\r\n        }\r\n        $message = is_array($arguments)?implode(\',\',$arguments):$arguments;\r\n        if(self::isWindows() || !self::isCli()) {\r\n            echo $message;\r\n        } else {\r\n            if(isset($colorDict[$method])) {\r\n                echo sprintf(\"\\033[0;%sm%s\\033[0m\",\'\'. $colorDict[$method],$message);\r\n            } else {\r\n                echo sprintf(\"\\033[0;%sm%s\\033[0m\",\'\'. $levelDict[$method],$message);\r\n            }\r\n        }\r\n        if(self::isCli()) {\r\n            echo \"\\n\";\r\n        }\r\n    }\r\n\r\n    public static function success($message) {\r\n        self::green($message);\r\n    }\r\n\r\n    public static function fail($message) {\r\n        self::red($message);\r\n    }\r\n\r\n}\r\n```\r\n\r\n### 使用方式\r\n```php\r\nConsole::info(\"this is info test\");\r\nConsole::debug(\"this is debug test\");\r\nConsole::warn(\"this is warn test\");\r\nConsole::error(\"this is error test\");\r\nConsole::trace(\"this is trace test\");\r\nConsole::log(\"this is log test\");\r\nConsole::fatal(\"this is fatal test\");\r\n\r\nConsole::success(\"this is success test\");\r\nConsole::fail(\"this is fail test\");\r\n\r\nConsole::white(\"this is white test\");\r\nConsole::red(\"this is red test\");\r\nConsole::green(\"this is green test\");\r\nConsole::yellow(\"this is yellow test\");\r\nConsole::blue(\"this is blue test\");\r\nConsole::magenta(\"this is magenta test\");\r\nConsole::cyan(\"this is cyan test\");\r\n```\r\n\r\n### 效果图\r\n![console.png](http://www.fxjson.com/usr/uploads/2021/03/2498297245.png)',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,719,0),(87,'php中switch的巧妙用法','87',1615785240,1615785316,'<!--markdown-->### 常规用法\r\nswitch最常用的方式是传递一个参数然后逐一跟case对比，类型下面的代码\r\n```php\r\n$os = PHP_OS;\r\nswitch($os) {\r\n    case \"LINUX\":\r\n        echo \"LINUX\";\r\n        break;\r\n    case \"WINNT\":\r\n        echo \"Windows\";\r\n        break;\r\n    case \"Mac\":\r\n        echo \"Mac\";\r\n        break;\r\n}\r\n```\r\n这里有一个需要注意的地方，就是PHP是弱类型语言的宽松比较,举例如下:\r\n```php\r\n$variable = 123;\r\nswitch($variable) {\r\n    case \"123hello\":\r\n        echo \"123hello\";\r\n        break;\r\n    case \"123\":\r\n        echo \"123\";\r\n		break;\r\n}\r\n```\r\n理想情况下，我们希望的是输出`123`,但是却输出了`123hello`,解决这种方式比较简单，如下,将参数转成跟case一样的类型\r\n```php\r\n$variable = 123;\r\nswitch(strval($variable)) {\r\n    case \"123hello\":\r\n        echo \"123hello\";\r\n        break;\r\n    case \"123\":\r\n        echo \"123\";\r\n		break;\r\n}\r\n```\r\n\r\n### 进阶用法\r\n在阅读Codeigniter4代码的时候，看到有如下的用法，用true作为switch参数，每个case就相当于一个else if\r\n```php\r\nswitch (true)\r\n{\r\n	case array_key_exists($name, $_ENV):\r\n		return $_ENV[$name];\r\n	case array_key_exists($name, $_SERVER):\r\n		return $_SERVER[$name];\r\n	default:\r\n		$value = getenv($name);\r\n\r\n		// switch getenv default to null\r\n		return $value === false ? null : $value;\r\n}\r\n```\r\n我表示自己在工作当中没有用过这样的方式，这样的好处是代码逻辑清晰，在分支比较多的时候，用switch代替if、else if，一目了然。\r\n\r\n### switch的坑\r\n先看代码:\r\n```php\r\n$var = 0;\r\nswitch($var) {\r\n    case $var>=0:\r\n        echo 0;\r\n        break;\r\n    case $var>10:\r\n        echo 1;\r\n        break;\r\n    default:\r\n        echo 2;\r\n}\r\n```\r\n你觉得结果应该是输出什么呢?乍一看,似乎应该是进入第一个case，但是还有一个但是，\r\n**switch匹配的是case中表达式的值,不能简单的把case当if用**\r\n这里第一行case ($var >= 0),这个条件表达式的值为`true`,switch($var) 中传过来的是0,0和true 匹配,当然匹配不上。下面几行都是false，第二行 0 和false匹配，所以匹配走第二个case然后break。\r\n所以最后应该输出： 1\r\n\r\n',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,655,0),(88,'使用phpcbf工具自动美化php文件代码','88',1615978020,1615978175,'<!--markdown-->熟悉php的朋友应该都知道`squizlabs/php_codesniffer`这个库，这是一个进行php代码检查&美化的库，现在结合这个库写了一个git钩子。\r\n\r\n这个钩子的目的是自动对**将要提交的文件**进行代码美化，再也不需要手动执行代码去美化了，而且只针对提交的文件，不是所有文件美化。\r\n\r\n现分享下钩子文件，以及配置步骤：\r\n\r\n- 第一步：确保本机全局安装composer\r\n- 第二步: 全局安装格式化工具\r\n\r\n```shell\r\ncomposer global require \"squizlabs/php_codesniffer=*\"\r\n```\r\n- 第三步:将如下代码写入**项目路径\\\\.git\\hooks\\pre-commit**文件\r\n\r\n```shell\r\n#!/bin/sh\r\n\r\n# 使用phpcbf美化工具，美化正在提交文件的代码\r\noutput=`git diff --name-only --cached | grep \'.php\'`;\r\n\r\nif [ -n \"$output\" ]; then \r\n    for file in $output \r\n	do\r\n		file=`echo \"$file\" | awk \'{gsub(/^\\s+|\\s+$/, \"\");print}\'`\r\n		phpcbf $file\r\n		git add $file\r\n	done\r\nfi\r\nexit 0\r\n```\r\n\r\n配置完成，提交代码看看效果吧\r\n\r\n注意:**确保git、php命令能全局使用**\r\n\r\n',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,702,0),(90,'git_1.gif','git_1-gif',1617265762,1617265762,'a:5:{s:4:\"name\";s:9:\"git_1.gif\";s:4:\"path\";s:34:\"/usr/uploads/2021/04/892709726.gif\";s:4:\"size\";i:104453;s:4:\"type\";s:3:\"gif\";s:4:\"mime\";s:9:\"image/gif\";}',1,2,NULL,'attachment','publish',NULL,0,'1','0','1',89,0,0),(91,'git_2.gif','git_2-gif',1617266216,1617266216,'a:5:{s:4:\"name\";s:9:\"git_2.gif\";s:4:\"path\";s:35:\"/usr/uploads/2021/04/3002196454.gif\";s:4:\"size\";i:268893;s:4:\"type\";s:3:\"gif\";s:4:\"mime\";s:9:\"image/gif\";}',2,2,NULL,'attachment','publish',NULL,0,'1','0','1',89,0,0),(99,'Go入门指南笔记','99',1617945610,1617945610,'<!--markdown--># 误用短声明导致变量覆盖\r\n\r\n```go\r\nvar remember bool = false\r\nif something {\r\n    remember := true //错误\r\n}\r\n// 使用remember\r\n```\r\n\r\n在此代码段中，`remember`变量永远不会在`if`语句外面变成`true`，如果`something`为`true`，由于使用了短声明`:=`，`if`语句内部的新变量`remember`将覆盖外面的`remember`变量，并且该变量的值为`true`，但是在`if`语句外面，变量`remember`的值变成了`false`，所以正确的写法应该是：\r\n\r\n```go\r\nif something {\r\n    remember = true\r\n}\r\n```\r\n\r\n此类错误也容易在`for`循环中出现，尤其当函数返回一个具名变量时难于察觉，例如以下的代码段：\r\n\r\n```go\r\nfunc shadow() (err error) {\r\n	x, err := check1() // x是新创建变量，err是被赋值\r\n	if err != nil {\r\n		return // 正确返回err\r\n	}\r\n	if y, err := check2(x); err != nil { // y和if语句中err被创建\r\n		return // if语句中的err覆盖外面的err，所以错误的返回nil！\r\n	} else {\r\n		fmt.Println(y)\r\n	}\r\n	return\r\n}\r\n```\r\n\r\n\r\n# 何时使用 new() 和 make()\r\n    - 切片、映射和通道，使用make\r\n    - 数组、结构体和所有的值类型，使用new \r\n	\r\n# 不需要将一个指向切片的指针传递给函数\r\n\r\n切片实际是一个指向潜在数组的指针。我们常常需要把切片作为一个参数传递给函数是因为：实际就是传递一个指向变量的指针，在函数内可以改变这个变量，而不是传递数据的拷贝。\r\n\r\n因此应该这样做：\r\n```go\r\nfunc findBiggest( listOfNumbers []int ) int {}\r\n```\r\n而不是：\r\n```go\r\nfunc findBiggest( listOfNumbers *[]int ) int {}\r\n```\r\n\r\n\r\n## 不要使用布尔值检测错误：\r\n\r\n像下面代码一样，创建一个布尔型变量用于测试错误条件是多余的：\r\n\r\n```go\r\nvar good bool\r\n    // 测试一个错误，`good`被赋为`true`或者`false`\r\n    if !good {\r\n        return errors.New(\"things aren’t good\")\r\n    }\r\n```\r\n\r\n正确方式如下,立即检测一个错误：\r\n\r\n```go\r\nerr1 := api.Func1()\r\nif err1 != nil { … }\r\n```\r\n\r\n# defer 会推迟资源的释放，所以尽量不要在 for 中使用\r\n```go\r\nfor {\r\n    time.Sleep(time.Second)\r\n    // ......\r\n    conn, err := grpc.Dial(address, grpc.WithInsecure())\r\n    if err != nil {\r\n        log.Fatalf(\"did not connect: %v\", err)\r\n    }\r\n    defer conn.Close()\r\n        //...\r\n}\r\n```\r\n由于这是一个死循环，defer代码不会被执行到，所以申请的内存得不到释放，然后会导致程序占满整个内存，死机',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,789,0),(92,'Conemu_1.png','Conemu_1-png',1617427033,1617427033,'a:5:{s:4:\"name\";s:12:\"Conemu_1.png\";s:4:\"path\";s:35:\"/usr/uploads/2021/04/2609629114.png\";s:4:\"size\";i:27100;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',1,2,NULL,'attachment','publish',NULL,0,'1','0','1',97,0,0),(93,'Conemu_2.png','Conemu_2-png',1617427102,1617427102,'a:5:{s:4:\"name\";s:12:\"Conemu_2.png\";s:4:\"path\";s:35:\"/usr/uploads/2021/04/3880995162.png\";s:4:\"size\";i:53228;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',2,2,NULL,'attachment','publish',NULL,0,'1','0','1',97,0,0),(94,'Conemu_3.png','Conemu_3-png',1617427127,1617427127,'a:5:{s:4:\"name\";s:12:\"Conemu_3.png\";s:4:\"path\";s:35:\"/usr/uploads/2021/04/2410849549.png\";s:4:\"size\";i:83011;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',3,2,NULL,'attachment','publish',NULL,0,'1','0','1',97,0,0),(95,'Conemu_4.png','Conemu_4-png',1617427132,1617427132,'a:5:{s:4:\"name\";s:12:\"Conemu_4.png\";s:4:\"path\";s:35:\"/usr/uploads/2021/04/1524471857.png\";s:4:\"size\";i:29319;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',4,2,NULL,'attachment','publish',NULL,0,'1','0','1',97,0,0),(96,'ConEmu_5.png','ConEmu_5-png',1617427381,1617427381,'a:5:{s:4:\"name\";s:12:\"ConEmu_5.png\";s:4:\"path\";s:35:\"/usr/uploads/2021/04/3420831647.png\";s:4:\"size\";i:47492;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',5,2,NULL,'attachment','publish',NULL,0,'1','0','1',97,0,0),(97,'windows终端之ConEmu配置及应用','97',1617427380,1617428170,'<!--markdown-->### 介绍\r\nConemu是windows下的一个终端工具，类似于cmder。\r\n\r\nconemu将windows自带的cmd和powershell整合到了一起，界面优化，支持很多插件，值得使用。\r\n\r\n官方地址[http://conemu.github.io](http://conemu.github.io),进入后点击download下载即可，这里注意的是有免安装版和安装版，随意选择即可。\r\n\r\n### 配置\r\n\r\n这里简单记录下插件的使用，conemu有一个clink插件，效果是自动补全，类似于linux终端效果，打开conemu安装目录下的conemu\\clink\\readme.txt，里面介绍了clink以及下载地址，地址是[http://mridgers.github.io/clink/](http://mridgers.github.io/clink/)，进入后下载即可。\r\n\r\n这里注意的是如果刚刚conemu是免安装版，则这里的clink就下载对应的免安装版，下载后直接解压到conemu\\clink目录下即可。\r\n\r\n如果刚刚conemu下载的是安装版，则这里建议clink也下载安装版，安装目录选择conemu\\clink即可，如下图。\r\n\r\n![Conemu_1.png](http://www.fxjson.com/usr/uploads/2021/04/2609629114.png)\r\n\r\n安装好clink后，conemu不用做任何配置，直接打开就会加载其插件。\r\n\r\n配置好后确定即可，可以看到已经自动加载了clink插件，且tab键可以正常使用，如下图。\r\n\r\n![Conemu_2.png](http://www.fxjson.com/usr/uploads/2021/04/3880995162.png)\r\n\r\n还有一个大家经常用的功能就是添加到右键，我们在conemu右上角菜单处点击设置，然后选择integration（集成的意思）, 在菜单集成处点击register注册即可，如下图。\r\n\r\n![Conemu_3.png](http://www.fxjson.com/usr/uploads/2021/04/2410849549.png)\r\n\r\n![Conemu_4.png](http://www.fxjson.com/usr/uploads/2021/04/1524471857.png)\r\n\r\n如果想去掉右键菜单，点击反注册即可。以上就是conemu的简单使用和配置。\r\n\r\n注意:**如果目录有中文或者文件有中文展示乱码**，需要如下设置\r\n![ConEmu_5.png](http://www.fxjson.com/usr/uploads/2021/04/3420831647.png)\r\n\r\n设置界面全中文，如下:\r\n\r\n![ConEmu_6.png](http://www.fxjson.com/usr/uploads/2021/04/1841090978.png)\r\n',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,1284,0),(98,'ConEmu_6.png','ConEmu_6-png',1617427755,1617427755,'a:5:{s:4:\"name\";s:12:\"ConEmu_6.png\";s:4:\"path\";s:35:\"/usr/uploads/2021/04/1841090978.png\";s:4:\"size\";i:44639;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',6,2,NULL,'attachment','publish',NULL,0,'1','0','1',97,0,0),(102,'get不常用的php cli命令','102',1628083320,1628086419,'<!--markdown-->之前很少用php cli命令，因为毕竟php在web领域上用的多，最近接触到的php cli多了，感觉挺有意思，现在汇总到这里，作为笔记。\r\n\r\n### php命令\r\n\r\n- 查看ini文件位置\r\n```php\r\nphp --ini\r\n```\r\n\r\n- 查看php加载的扩展、模块\r\n```php\r\nphp -m\r\n```\r\n\r\n- text方式查看phpinfo()\r\n```php\r\nphp -i\r\n```\r\n\r\n- 无需<?php，运行php代码\r\n```php\r\nphp -r \"phpinfo();\"\r\nphp -r \"echo 1+2;\"\r\nphp -r \"copy(\'https://install.phpcomposer.com/installer\', \'composer-setup.php\');\"\r\nphp -r \"unlink(\'composer-setup.php\');\"\r\n```\r\n\r\n### php运行管道输出\r\n```php\r\ncurl -Ss http://www.workerman.net/check.php | php\r\n\r\n```\r\n上面是curl获取curl的输出结果，作为管道php命令的运行内容\r\n\r\n下面的方式是运行本地脚本，输出其实就是一个php格式的内容\r\ntest.php内容如下:\r\n```php\r\n<?php\r\nheader(\'HTTP/1.1 206 Partial Content\');\r\nheader(\"Content-Type: application/octet-stream\");\r\n\r\necho \'<?php\r\n$version_ok = $pcntl_loaded = $posix_loaded = false;\r\nif(version_compare(phpversion(), \"5.3.3\", \">=\"))\r\n{\r\n  $version_ok = true;\r\n}\r\nif(in_array(\"pcntl\", get_loaded_extensions()))\r\n{\r\n    $pcntl_loaded = true;\r\n}\r\nif(in_array(\"posix\", get_loaded_extensions()))\r\n{\r\n    $posix_loaded = true;\r\n}\r\n\r\nfunction check($val)\r\n{\r\n    if($val)\r\n    {\r\n       return \"\\033[32;40m [OK] \\033[0m\\n\";\r\n    }\r\n    else\r\n    {\r\n       return \"\\033[31;40m [fail] \\033[0m\\n\";\r\n    }\r\n}\r\n\r\necho \"PHP Version >= 5.3.3                 \" . check($version_ok);\r\n\r\necho \"Extension pcntl check                \" . check($pcntl_loaded);\r\n\r\necho \"Extension posix check                \" . check($posix_loaded);\r\n\r\n\';\r\n\r\n```\r\n运行方式:\r\n```php\r\nphp test.php | php\r\n```',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,534,0),(101,'json_decode之长整数的坑','101',1625791500,1625792897,'<!--markdown-->### 案例\r\n\r\n前两天跟金蝶财务系统对接凭证，就涉及了api调用，当我call接口成功后对方会返回金蝶系统生成的凭证Id，在撤销凭证接口时会使用这个Id，生成凭证成功后的结果如下:\r\n```bash\r\n{\"data\":[{\"dindex\":0,\"number\":\"0002\",\"orgnumber\":\"BU-00002\",\"success\":true,\"id\":1195649395178081280}],\"success\":true,\"errorCode\":null,\"message\":null}\r\n```\r\n我现在要解析这个json字符串，获取id存储起来，以备撤销凭证接口使用\r\n\r\n当我使用`json_decode`之后竟然并没有获取到我想要的格式，代码如下\r\n\r\n```php\r\n$result_str = \'{\"data\":[{\"dindex\":0,\"number\":\"0002\",\"orgnumber\":\"BU-00002\",\"success\":true,\"id\":1195649395178081280}],\"success\":true,\"errorCode\":null,\"message\":null}\';\r\n\r\n$result = json_decode($result_str,true);\r\n\r\nvar_dump($result);\r\n```\r\n\r\n获取到的结果是:\r\n```php\r\narray(4) {\r\n  [\"data\"]=>\r\n  array(1) {\r\n    [0]=>\r\n    array(5) {\r\n      [\"dindex\"]=>\r\n      int(0)\r\n      [\"number\"]=>\r\n      string(4) \"0002\"\r\n      [\"orgnumber\"]=>\r\n      string(8) \"BU-00002\"\r\n      [\"success\"]=>\r\n      bool(true)\r\n      [\"id\"]=>\r\n      float(1.1956493951781E+18)\r\n    }\r\n  }\r\n  [\"success\"]=>\r\n  bool(true)\r\n  [\"errorCode\"]=>\r\n  NULL\r\n  [\"message\"]=>\r\n  NULL\r\n}\r\n```\r\nid奇迹般的解析成了float类型，成了科学计数法格式，这并不是我想要的结果，我想获取id的结果为1195649395178081280。\r\n\r\n### 原因\r\n\r\n之所以出现将json字符串中的1195649395178081280解析成php的float类型，是因为该值已经超过了php数据类型int长度PHP_INT_MAX，所以会自动转换成float类型\r\n\r\n### 解决方式\r\n怎么处理这种情况呢，php又没有long类型，好吧，既然用到了json_decode函数，那我看看手册上这个函数有没有其它参数解决这种问题。结果一看，**[官方](https://www.php.net/manual/zh/function.json-decode.php)**还是挺牛掰的，竟然有专门的处理方式.\r\n\r\n第四个可选参数JSON_BIGINT_AS_STRING可以完美解决这个问题,那好吧，对json_decode做一个小小的修改，代码如下:\r\n```php\r\n\r\narray(4) {\r\n  [\"data\"]=>\r\n  array(1) {\r\n    [0]=>\r\n    array(5) {\r\n      [\"dindex\"]=>\r\n      int(0)\r\n      [\"number\"]=>\r\n      string(4) \"0002\"\r\n      [\"orgnumber\"]=>\r\n      string(8) \"BU-00002\"\r\n      [\"success\"]=>\r\n      bool(true)\r\n      [\"id\"]=>\r\n      string(19) \"1195649395178081280\"\r\n    }\r\n  }\r\n  [\"success\"]=>\r\n  bool(true)\r\n  [\"errorCode\"]=>\r\n  NULL\r\n  [\"message\"]=>\r\n  NULL\r\n}\r\n```\r\nid成了自己想要的数值，只不过类型变成了string，但是对于php弱类型并没有多大影响。最终问题得到解决。\r\n\r\n**注意**:官方手册有说明，在php5.4.0版本之后json_decode才加入了JSON_BIGINT_AS_STRING可选项\r\n\r\n\r\n',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,557,0),(105,'不实例化类判断是否是某个类的子类','105',1630208280,1630295155,'<!--markdown-->校验是否是某个类的实例，我们首先想到的是instanceof函数，如下代码:\r\n```php\r\nclass BaseController {\r\n\r\n}\r\n\r\nclass Home extends BaseController {\r\n\r\n}\r\n\r\n$instance = new Home;\r\nvar_dump($instance instanceof BaseController);\r\n```\r\n\r\n那如何在不实例化Home类的情况下，判断Home类是否是BaseController类的子类呢，这里给大家介绍的是is_subclass_of函数，使用方式如下:\r\n```php\r\n$controllerName = \'Home\';\r\n\r\nvar_dump(is_subclass_of($controllerName,\'BaseController\'));\r\n```\r\n上面两个参数都是类名字符串，其实第一个参数也可以是实例对象:\r\n```php\r\n$instance = new Home;\r\n\r\nvar_dump(is_subclass_of($instance,\'BaseController\'));\r\n```',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,503,0),(106,'Redis的内存优化(Redis3.2以及之前版本)','106',1631235840,1631252995,'<!--markdown-->一. [redisObject对象](#chapter1)\r\n二. [缩减键值对象](#chapter2)\r\n三. [共享对象池](#chapter3)\r\n四. [字符串优化](#chapter4)\r\n五. [编码优化](#chapter5)\r\n六. [控制key的数量](#chapter6)\r\n\r\n<a name=\"chapter1\"> </a>\r\n## 一. redisObject对象\r\nRedis存储的所有值对象在内部定义为redisObject结构体，内部结构如下图所示。\r\n![1png.png](http://www.fxjson.com/usr/uploads/2021/09/435384062.png)\r\n\r\nRedis存储的数据都使用redisObject来封装，包括string,hash,list,set,zset在内的所有数据类型。理解redisObject对内存优化非常有帮助，下面针对每个字段做详细说明：\r\n\r\n### 1.type字段:\r\n表示当前对象使用的数据类型，Redis主要支持5种数据类型:string,hash,list,set,zset。可以使用type {key}命令查看对象所属类型，type命令返回的是值对象类型，键都是string类型。\r\n\r\n###2.encoding字段:\r\n表示Redis内部编码类型，encoding在Redis内部使用，代表当前对象内部采用哪种数据结构实现。理解Redis内部编码方式对于优化内存非常重要，同一个对象采用不同的编码实现内存占用存在明显差异，具体细节见之后编码优化部分。\r\n\r\n### 3.lru字段:\r\n\r\n记录对象最后一次被访问的时间，当配置了 maxmemory和maxmemory-policy=volatile-lru | allkeys-lru 时， 用于辅助LRU算法删除键数据。可以使用object idletime {key}命令在不更新lru字段情况下查看当前键的空闲时间。\r\n```shell\r\n开发提示：可以使用scan + object idletime  命令批量查询哪些键长时间未被访问，找出长时间不访问的键进行清理降低内存占用。\r\n```\r\n### 4.refcount字段:\r\n记录当前对象被引用的次数，用于通过引用次数回收内存，当refcount=0时，可以安全回收当前对象空间。使用object refcount {key}获取当前对象引用。当对象为整数且范围在[0-9999]时，Redis可以使用共享对象的方式来节省内存。具体细节见之后共享对象池部分。\r\n\r\n### 5. *ptr字段:\r\n与对象的数据内容相关，如果是整数直接存储数据，否则表示指向数据的指针。Redis在3.0之后对值对象是字符串且长度&lt;=39字节的数据，内部编码为embstr类型，字符串sds和redisObject一起分配，从而只要一次内存操作。\r\n```shell\r\n开发提示：高并发写入场景中，在条件允许的情况下建议字符串长度控制在39字节以内，减少创建redisObject内存分配次数从而提高性能。\r\n```\r\n<a name=\"chapter2\"> </a>\r\n## 二. 缩减键值对象\r\n\r\n降低Redis内存使用最直接的方式就是缩减键（key）和值（value）的长度。\r\n*   key长度：如在设计键时，在完整描述业务情况下，键值越短越好。\r\n*   value长度：值对象缩减比较复杂，常见需求是把业务对象序列化成二进制数组放入Redis。首先应该在业务上精简业务对象，去掉不必要的属性避免存储无效数据。其次在序列化工具选择上，应该选择更高效的序列化工具来降低字节数组大小。以JAVA为例，内置的序列化方式无论从速度还是压缩比都不尽如人意，这时可以选择更高效的序列化工具，如:protostuff，kryo等，下图是JAVA常见序列化工具空间压缩对比。\r\n![3084_8e427aa5_bf49_c714_45f8_692fccf2cd6b_1.png](http://www.fxjson.com/usr/uploads/2021/09/2911227198.png)\r\n\r\n其中java-built-in-serializer表示JAVA内置序列化方式，更多数据见jvm-serializers项目:[https://github.com/eishay/jvm-serializers/wiki，其它语言也有各自对应的高效序列化工具。](https://github.com/eishay/jvm-serializers/wiki其它语言也有各自对应的高效序列化工具。)\r\n\r\n值对象除了存储二进制数据之外，通常还会使用通用格式存储数据比如:json，xml等作为字符串存储在Redis中。这种方式优点是方便调试和跨语言，但是同样的数据相比字节数组所需的空间更大，在内存紧张的情况下，可以使用通用压缩算法压缩json,xml后再存入Redis，从而降低内存占用，例如使用GZIP压缩后的json可降低约60%的空间。\r\n```shell\r\n开发提示：当频繁压缩解压json等文本数据时，开发人员需要考虑压缩速度和计算开销成本，这里推荐使用google的Snappy压缩工具，在特定的压缩率情况下效率远远高于GZIP等传统压缩工具，且支持所有主流语言环境\r\n```\r\n<a name=\"chapter3\"> </a>\r\n## 三. 共享对象池\r\n\r\n对象共享池指Redis内部维护[0-9999]的整数对象池。创建大量的整数类型redisObject存在内存开销，每个redisObject内部结构至少占16字节，甚至超过了整数自身空间消耗。所以Redis内存维护一个[0-9999]的整数对象池，用于节约内存。除了整数值对象，其他类型如list,hash,set,zset内部元素也可以使用整数对象池。因此开发中在满足需求的前提下，尽量使用整数对象以节省内存。\r\n整数对象池在Redis中通过变量REDIS_SHARED_INTEGERS定义，不能通过配置修改。可以通过object refcount 命令查看对象引用数验证是否启用整数对象池技术，如下:\r\n```shell\r\nredis> set foo 100 \r\nOK\r\nredis> object refcount foo\r\n(integer) 2\r\nredis> set bar 100\r\nOK\r\nredis> object refcount bar\r\n(integer) 3\r\n```\r\n\r\n设置键foo等于100时，直接使用共享池内整数对象，因此引用数是2，再设置键bar等于100时，引用数又变为3，如下图所示。\r\n![3084_ffd40aaf_b79c_0c62_9751_650a6b0ccc53_1.png](http://www.fxjson.com/usr/uploads/2021/09/204039170.png)\r\n使用整数对象池究竟能降低多少内存？让我们通过测试来对比对象池的内存优化效果，如下表所示。\r\n\r\n| 操作说明   | 是否对象共享 | key大小 | value大小    | used_mem | used_memory_rss |\r\n|--------|--------|-------|------------|----------|-----------------|\r\n| 插入200万 | 否      | 20字节  | [0-9999]整数 | 199.91MB | 205.28MB        |\r\n| 插入200万 | 是      | 20字节  | [0-9999]整数 | 138.87MB | 143.28MB        |\r\n\r\n\r\n```shell\r\n注意本文所有测试环境都保持一致，信息如下:\r\n服务器信息: cpu=Intel-Xeon E5606@2.13GHz memory=32GB\r\nRedis版本:Redis server v=3.0.7 sha=00000000:0 malloc=jemalloc-3.6.0 bits=64\r\n```\r\n使用共享对象池后，相同的数据内存使用降低30%以上。可见当数据大量使用[0-9999]的整数时，共享对象池可以节约大量内存。需要注意的是对象池并不是只要存储[0-9999]的整数就可以工作。当设置maxmemory并启用LRU相关淘汰策略如:volatile-lru，allkeys-lru时，Redis禁止使用共享对象池，测试命令如下：\r\n```shell\r\nredis> set key:1 99\r\nOK //设置key:1=99\r\nredis> object refcount key:1\r\n(integer) 2 //使用了对象共享,引用数为2\r\nredis> config set maxmemory-policy volatile-lru\r\nOK //开启LRU淘汰策略\r\nredis> set key:2 99\r\nOK //设置key:2=99\r\nredis> object refcount key:2\r\n(integer) 3 //使用了对象共享,引用数变为3\r\nredis> config set maxmemory 1GB\r\nOK //设置最大可用内存\r\nredis> set key:3 99\r\nOK //设置key:3=99\r\nredis> object refcount key:3\r\n(integer) 1 //未使用对象共享,引用数为1\r\nredis> config set maxmemory-policy volatile-ttl\r\nOK //设置非LRU淘汰策略\r\nredis> set key:4 99\r\nOK //设置key:4=99\r\nredis> object refcount key:4\r\n(integer) 4 //又可以使用对象共享,引用数变为4\r\n```\r\n\r\n### 为什么开启maxmemory和LRU淘汰策略后对象池无效?\r\nLRU算法需要获取对象最后被访问时间，以便淘汰最长未访问数据，每个对象最后访问时间存储在redisObject对象的lru字段。对象共享意味着多个引用共享同一个redisObject，这时lru字段也会被共享，导致无法获取每个对象的最后访问时间。如果没有设置maxmemory，直到内存被用尽Redis也不会触发内存回收，所以共享对象池可以正常工作。\r\n\r\n综上所述，共享对象池与maxmemory+LRU策略冲突，使用时需要注意。对于ziplist编码的值对象，即使内部数据为整数也无法使用共享对象池，因为ziplist使用压缩且内存连续的结构，对象共享判断成本过高，ziplist编码细节后面内容详细说明。\r\n\r\n### 为什么只有整数对象池？\r\n\r\n首先整数对象池复用的几率最大，其次对象共享的一个关键操作就是判断相等性，Redis之所以只有整数对象池，是因为整数比较算法时间复杂度为O(1)，只保留一万个整数为了防止对象池浪费。如果是字符串判断相等性，时间复杂度变为O(n)，特别是长字符串更消耗性能(浮点数在Redis内部使用字符串存储)。对于更复杂的数据结构如hash,list等，相等性判断需要O(n<sup>2</sup>)。对于单线程的Redis来说，这样的开销显然不合理，因此Redis只保留整数共享对象池。\r\n<a name=\"chapter4\"> </a>\r\n## 四. 字符串优化\r\n字符串对象是Redis内部最常用的数据类型。所有的键都是字符串类型， 值对象数据除了整数之外都使用字符串存储。比如执行命令:lpush cache:type redis memcache tair levelDB，Redis首先创建cache:type 键字符串，然后创建链表对象，链表对象内再包含四个字符串对象，排除Redis内部用到的字符串对象之外至少创建5个字符串对象。可见字符串对象在Redis内部使用非常广泛，因此深刻理解Redis字符串对于内存优化非常有帮助:\r\n### 1.字符串结构\r\n\r\nRedis没有采用原生C语言的字符串类型而是自己实现了字符串结构，内部简单动态字符串(simple dynamic string)，简称SDS。结构下图所示。\r\n![3084_54bb9bb0_a89d_8e7e_2edb_11fcfc6ee5f1_1.png](http://www.fxjson.com/usr/uploads/2021/09/1621911020.png)\r\n\r\nRedis自身实现的字符串结构有如下特点:\r\n*   O(1)时间复杂度获取：字符串长度，已用长度，未用长度。\r\n*   可用于保存字节数组，支持安全的二进制数据存储。\r\n*   内部实现空间预分配机制，降低内存再分配次数。\r\n*   惰性删除机制，字符串缩减后的空间不释放，作为预分配空间保留。\r\n\r\n### 2.预分配机制\r\n\r\n因为字符串(SDS)存在预分配机制，日常开发中要小心预分配带来的内存浪费，例如下表的测试用例。\r\n\r\n#### 表：字符串内存预分配测试\r\n\r\n| 阶段  | 数据量  | 操作说明              | 命令     | key大小 | value大小 | used_mem | used_memory_rss | mem_fragmentation_ratio |\r\n|-----|------|-------------------|--------|-------|---------|----------|-----------------|-------------------------|\r\n| 阶段1 | 200w | 新插入200w数据         | set    | 20字节  | 60字节    | 321.98MB | 331.44MB        | 1.02                    |\r\n| 阶段2 | 200w | 在阶段1上每个对象追加60字节数据 | append | 20字节  | 60字节    | 657.67MB | 752.80MB        | 1.14                    |\r\n| 阶段3 | 200w | 重新插入200w数据        | set    | 20字节  | 120字节   | 474.56MB | 482.45MB        | 1.02                    |\r\n\r\n\r\n从测试数据可以看出，同样的数据追加后内存消耗非常严重，下面我们结合图来分析这一现象。阶段1每个字符串对象空间占用如下图所示。\r\n![3084_348deb09_9394_4809_f74f_638d4a8cc902_1.png](http://www.fxjson.com/usr/uploads/2021/09/1620578911.png)\r\n\r\n阶段1插入新的字符串后，free字段保留空间为0，总占用空间=实际占用空间+1字节，最后1字节保存‘\\0’标示结尾，这里忽略int类型len和free字段消耗的8字节。在阶段1原有字符串上追加60字节数据空间占用如下图所示。\r\n![3084_ea8adf90_7c43_cff3_2bf8_7426f0fa60de_1.png](http://www.fxjson.com/usr/uploads/2021/09/3966228186.png)\r\n\r\n追加操作后字符串对象预分配了一倍容量作为预留空间，而且大量追加操作需要内存重新分配，造成内存碎片率(mem_fragmentation_ratio)上升。直接插入与阶段2相同数据的空间占用，如下图所示。\r\n![3084_0a3583f6_57d1_9c73_95b9_13bd067bc3c9_1.png](http://www.fxjson.com/usr/uploads/2021/09/3423879729.png)\r\n阶段3直接插入同等数据后，相比阶段2节省了每个字符串对象预分配的空间，同时降低了碎片率。\r\n字符串之所以采用预分配的方式是防止修改操作需要不断重分配内存和字节数据拷贝。但同样也会造成内存的浪费。字符串预分配每次并不都是翻倍扩容，空间预分配规则如下:\r\n*   1) 第一次创建len属性等于数据实际大小，free等于0，不做预分配。\r\n*   2)修改后如果已有free空间不够且数据小于1M，每次预分配一倍容量。如原有len=60byte，free=0，再追加60byte，预分配120byte，总占用空间:60byte+60byte+120byte+1byte。\r\n*   3) 修改后如果已有free空间不够且数据大于1MB，每次预分配1MB数据。如原有len=30MB，free=0，当再追加100byte,预分配1MB，总占用空间:1MB+100byte+1MB+1byte。\r\n开发提示:尽量减少字符串频繁修改操作如append，setrange,改为直接使用set修改字符串，降低预分配带来的内存浪费和内存碎片化。\r\n\r\n### 3.字符串重构\r\n\r\n字符串重构:指不一定把每份数据作为字符串整体存储，像json这样的数据可以使用hash结构，使用二级结构存储也能帮我们节省内存。同时可以使用hmget,hmset命令支持字段的部分读取修改，而不用每次整体存取。例如下面的json数据：\r\n```shell\r\n{\r\n    \"vid\": \"413368768\",\r\n    \"title\": \"搜狐屌丝男士\",\r\n    \"videoAlbumPic\": \"http://photocdn.sohu.com/60160518/vrsa_ver8400079_ae433_pic26.jpg\",\r\n    \"pid\": \"6494271\",\r\n    \"type\": \"1024\",\r\n    \"playlist\": \"6494271\",\r\n    \"playTime\": \"468\"\r\n}\r\n```\r\n分别使用字符串和hash结构测试内存表现，如下表所示。\r\n\r\n#### 表：测试内存表现\r\n\r\n| 数据量  | key  | 存储类型   | value      | 配置                        | used_mem  |\r\n|------|------|--------|------------|---------------------------|-----------|\r\n| 200W | 20字节 | string | json字符串    | 默认                        | 612.62M   |\r\n| 200W | 20字节 | hash   | key-value对 | 默认                        | 默认 1.88GB |\r\n| 200W | 20字节 | hash   | key-value对 | hash-max-ziplist-value:66 | 535.60M   |\r\n\r\n\r\n根据测试结构，第一次默认配置下使用hash类型，内存消耗不但没有降低反而比字符串存储多出2倍，而调整hash-max-ziplist-value=66之后内存降低为535.60M。因为json的videoAlbumPic属性长度是65，而hash-max-ziplist-value默认值是64，Redis采用hashtable编码方式，反而消耗了大量内存。调整配置后hash类型内部编码方式变为ziplist，相比字符串更省内存且支持属性的部分操作。下一节将具体介绍ziplist编码优化细节。\r\n<a name=\"chapter5\"> </a>\r\n## 五. 编码优化\r\n### 1.了解编码\r\n\r\nRedis对外提供了string,list,hash,set,zet等类型，但是Redis内部针对不同类型存在编码的概念，所谓编码就是具体使用哪种底层数据结构来实现。编码不同将直接影响数据的内存占用和读写效率。使用object encoding {key}命令获取编码类型。如下:\r\n```shell\r\nredis> set str:1 hello\r\nOK\r\nredis> object encoding str:1\r\n\"embstr\" // embstr编码字符串\r\nredis> lpush list:1 1 2 3\r\n(integer) 3\r\nredis> object encoding list:1\r\n\"ziplist\" // ziplist编码列表\r\n```\r\n\r\nRedis针对每种数据类型(type)可以采用至少两种编码方式来实现，下表表示type和encoding的对应关系。\r\n\r\n#### 表：type和encoding对应关系表\r\n| 类型     | 编码方式                       | 数据结构                    |\r\n|--------|----------------------------|-------------------------|\r\n| string | rawembstrint               | 动态字符串编码优化内存分配的字符串编码整数编码 |\r\n| hash   | hashtableziplist           | 散列表编码压缩列表编码             |\r\n| list   | linkedlistziplistquicklist | 双向链表编码压缩列表编码3.2版本新的列表编码 |\r\n| set    | hashtableintset            | 散列表编码整数集合编码             |\r\n| zset   | skiplistziplist            | 跳跃表编码压缩列表编码             |\r\n\r\n\r\n了解编码和类型对应关系之后，我们不禁疑惑Redis为什么需要对一种数据结构实现多种编码方式？\r\n主要原因是Redis作者想通过不同编码实现效率和空间的平衡。比如当我们的存储只有10个元素的列表，当使用双向链表数据结构时，必然需要维护大量的内部字段如每个元素需要:前置指针，后置指针，数据指针等，造成空间浪费，如果采用连续内存结构的压缩列表(ziplist)，将会节省大量内存，而由于数据长度较小，存取操作时间复杂度即使为O(n2)性能也可满足需求。\r\n### 2.控制编码类型\r\n\r\n编码类型转换在Redis写入数据时自动完成，这个转换过程是不可逆的，转换规则只能从小内存编码向大内存编码转换。例如：\r\n```shell\r\nredis> lpush list:1 a b c d\r\n(integer) 4 //存储4个元素\r\nredis> object encoding list:1\r\n\"ziplist\" //采用ziplist压缩列表编码\r\nredis> config set list-max-ziplist-entries 4\r\nOK //设置列表类型ziplist编码最大允许4个元素\r\nredis> lpush list:1 e\r\n(integer) 5 //写入第5个元素e\r\nredis> object encoding list:1\r\n\"linkedlist\" //编码类型转换为链表\r\nredis> rpop list:1\r\n\"a\" //弹出元素a\r\nredis> llen list:1\r\n(integer) 4 // 列表此时有4个元素\r\nredis> object encoding list:1\r\n\"linkedlist\" //编码类型依然为链表，未做编码回退\r\n```\r\n以上命令体现了list类型编码的转换过程，其中Redis之所以不支持编码回退，主要是数据增删频繁时，数据向压缩编码转换非常消耗CPU，得不偿失。以上示例用到了list-max-ziplist-entries参数，这个参数用来决定列表长度在多少范围内使用ziplist编码。当然还有其它参数控制各种数据类型的编码，如下表所示：\r\n#### 表：hash,list,set,zset内部编码配置\r\n\r\n| 类型   | 编码         | 决定条件                                                                                                                                                                              |\r\n|------|------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\r\n| hash | ziplist    | 满足所有条件:value最大空间(字节)<=hash-max-ziplist-valuefield个数<=hash-max-ziplist-entries                                                                                                     |\r\n| 同上   | hashtable  | 满足任意条件:value最大空间(字节)>hash-max-ziplist-valuefield个数>hash-max-ziplist-entries                                                                                                       |\r\n| list | ziplist    | ziplist    满足所有条件:value最大空间(字节)<=list-max-ziplist-value链表长度<=list-max-ziplist-entries                                                                                             |\r\n| 同上   | linkedlist | 满足任意条件value最大空间(字节)>list-max-ziplist-value链表长度>list-max-ziplist-entries                                                                                                           |\r\n| 同上   | quicklist  | 3.2版本新编码:废弃list-max-ziplist-entries和list-max-ziplist-entries配置使用新配置: list-max-ziplist-size:表示最大压缩空间或长度,最大空间使用[-5-1]范围配置，默认-2表示8KB,正整数表示最大压缩长度list-compress-depth:表示最大压缩深度，默认=0不压缩 |\r\n| set  | intset     | 满足所有条件:元素必须为整数集合长度<=set-max-intset-entries                                                                                                                                        |\r\n| 同上   | hashtable  | 满足任意条件元素非整数类型集合长度>hash-max-ziplist-entries                                                                                                                                        |\r\n| zset | ziplist    | 满足所有条件:value最大空间(字节)<=zset-max-ziplist-value有序集合长度<=zset-max-ziplist-entries                                                                                                      |\r\n| 同上   | skiplist   | 满足任意条件:value最大空间(字节)>zset-max-ziplist-value有序集合长度>zset-max-ziplist-entries                                                                                                        |\r\n\r\n\r\n掌握编码转换机制，对我们通过编码来优化内存使用非常有帮助。下面以hash类型为例，介绍编码转换的运行流程，如下图所示。\r\n![3084_706c9e3a_9b61_95c5_69ac_f46b88d41bc5_1.png](http://www.fxjson.com/usr/uploads/2021/09/2110683165.png)\r\n\r\n理解编码转换流程和相关配置之后，可以使用config set命令设置编码相关参数来满足使用压缩编码的条件。对于已经采用非压缩编码类型的数据如hashtable,linkedlist等，设置参数后即使数据满足压缩编码条件，Redis也不会做转换，需要重启Redis重新加载数据才能完成转换。\r\n\r\n### 3.ziplist编码\r\nziplist编码主要目的是为了节约内存，因此所有数据都是采用线性连续的内存结构。ziplist编码是应用范围最广的一种，可以分别作为hash、list、zset类型的底层数据结构实现。一个ziplist可以包含多个entry(元素)，每个entry保存具体的数据(整数或者字节数组)，内部结构如下图所示。\r\n![3084_8e48faac_2a3e_51f4_d602_1fb45a002892_1.png](http://www.fxjson.com/usr/uploads/2021/09/461866986.png)\r\nziplist结构字段含义：\r\n*   1) zlbytes:记录整个压缩列表所占字节长度，方便重新调整ziplist空间。类型是int-32，长度为4字节\r\n*   2) zltail:记录距离尾节点的偏移量，方便尾节点弹出操作。类型是int-32，长度为4字节\r\n*   3) zllen:记录压缩链表节点数量，当长度超过216-2时需要遍历整个列表获取长度，一般很少见。类型是int-16，长度为2字节\r\n*   4) entry:记录具体的节点，长度根据实际存储的数据而定。\r\n	*  a) prev_entry_bytes_length:记录前一个节点所占空间，用于快速定位上一个节点，可实现列表反向迭代。\r\n    *   b) encoding:标示当前节点编码和长度，前两位表示编码类型：字符串/整数，其余位表示数据长度。\r\n	*   c) contents:保存节点的值，针对实际数据长度做内存占用优化。\r\n*   5) zlend:记录列表结尾，占用一个字节。\r\n\r\n根据以上对ziplist字段说明，可以分析出该数据结构特点如下:\r\n\r\n*   1) 内部表现为数据紧凑排列的一块连续内存数组。\r\n*   2) 可以模拟双向链表结构，以O(1)时间复杂度入队和出队。\r\n*   3) 新增删除操作涉及内存重新分配或释放，加大了操作的复杂性。\r\n*   4) 读写操作涉及复杂的指针移动，最坏时间复杂度为O(n2)。\r\n*   5) 适合存储小对象和长度有限的数据。\r\n\r\n下面通过测试展示ziplist编码在不同类型中内存和速度的表现，如下表所示。\r\n\r\n#### 表：ziplist在hash,list,zset内存和速度测试\r\n\r\n| 类型   | 数据量  | key总数量 | 长度 | value大小 | 普通编码内存量/平均耗时   | 压缩编码内存量/平均耗时   | 内存降低比例 | 耗时增长倍数 |\r\n|------|------|--------|----|---------|----------------|----------------|--------|--------|\r\n| hash | 100万 | 1千     | 1千 | 36字节    | 103.37M/0.84微秒 | 43.83M/13.24微秒 | 57.5%  | 15倍    |\r\n| list | 100万 | 1千     | 1千 | 36字节    | 92.46M/2.04微秒  | 39.92M/5.45微秒  | 56.8%  | 2.5倍   |   |\r\n| zset | 100万 | 1千     | 1千 | 36字节    | 151.84M/1.85微秒 | 43.83M/77.88微秒 | 71%    | 42倍    |\r\n\r\n\r\n测试数据采用100W个36字节数据，划分为1000个键，每个类型长度统一为1000。从测试结果可以看出：\r\n1) 使用ziplist可以分别作为hash,list,zset数据类型实现。\r\n2) 使用ziplist编码类型可以大幅降低内存占用。\r\n3) ziplist实现的数据类型相比原生结构，命令操作更加耗时，不同类型耗时排序:list &lt; hash &lt;zset。ziplist压缩编码的性能表现跟值长度和元素个数密切相关，正因为如此Redis提供了{type}-max-ziplist-value和{type}-max-ziplist-entries相关参数来做控制ziplist编码转换。最后再次强调使用ziplist压缩编码的原则：追求空间和时间的平衡。\r\n开发提示：\r\n1）针对性能要求较高的场景使用ziplist，建议长度不要超过1000，每个元素大小控制在512字节以内。\r\n2）命令平均耗时使用info Commandstats命令获取，包含每个命令调用次数，总耗时，平均耗时，单位微秒。\r\n\r\n### 4.intset编码\r\nintset编码是集合(set)类型编码的一种，内部表现为存储有序，不重复的整数集。当集合只包含整数且长度不超过set-max-intset-entries配置时被启用。执行以下命令查看intset表现：\r\n```shell\r\n127.0.0.1:6379> sadd set:test 3 4 2 6 8 9 2\r\n(integer) 6 //乱序写入6个整数\r\n127.0.0.1:6379> object encoding set:test\r\n\"intset\" //使用intset编码\r\n127.0.0.1:6379> smembers set:test\r\n\"2\" \"3\" \"4\" \"6\" \"8\" \"9\" // 排序输出整数结合\r\nredis> config set set-max-intset-entries 6\r\nOK //设置intset最大允许整数长度\r\nredis> sadd set:test 5\r\n(integer) 1 //写入第7个整数 5\r\nredis> object encoding set:test\r\n\"hashtable\" // 编码变为hashtable\r\nredis> smembers set:test\r\n\"8\" \"3\" \"5\" \"9\" \"4\" \"2\" \"6\" //乱序输出\r\n```\r\n\r\n以上命令可以看出intset对写入整数进行排序，通过O(log(n))时间复杂度实现查找和去重操作，intset编码结构如下图所示。\r\n![3084_5417a9b7_6050_0614_09f1_ce8565f04eca_1.png](http://www.fxjson.com/usr/uploads/2021/09/2137304141.png)\r\n\r\nintset的字段结构含义：\r\n1) encoding:整数表示类型，根据集合内最长整数值确定类型，整数类型划分三种:int-16，int-32，int-64。\r\n2) length:表示集合元素个数。\r\n3) contents:整数数组，按从小到大顺序保存。\r\nintset保存的整数类型根据长度划分，当保存的整数超出当前类型时，将会触发自动升级操作且升级后不再做回退。升级操作将会导致重新申请内存空间，把原有数据按转换类型后拷贝到新数组。\r\n\r\n开发提示：使用intset编码的集合时，尽量保持整数范围一致，如都在int-16范围内。防止个别大整数触发集合升级操作，产生内存浪费。\r\n下面通过测试查看ziplist编码的集合内存和速度表现，如下表所示。\r\n\r\n#### 表：ziplist编码在set下内存和速度表现\r\n\r\n| 数据量  | key大小  | value大小 | 编码        | 集合长度 | 内存量     | 内存降低比例 | 平均耗时    |\r\n|------|--------|---------|-----------|------|---------|--------|---------|\r\n| 100w | 20byte | 7字节     | hashtable | 1千   | 61.97MB | –      | 0.78毫秒  |\r\n| 100w | 20byte | 7字节     | intset    | 1千   | 4.77MB  | 92.6%  | 0.51毫秒  |\r\n| 100w | 20byte | 7字节     | ziplist   | 1千   | 8.67MB  | 86.2%  | 13.12毫秒 |\r\n\r\n\r\n根据以上测试结果发现intset表现非常好，同样的数据内存占用只有不到hashtable编码的十分之一。intset数据结构插入命令复杂度为O(n)，查询命令为O(log(n))，由于整数占用空间非常小，所以在集合长度可控的基础上，写入命令执行速度也会非常快，因此当使用整数集合时尽量使用intset编码。上表测试第三行把ziplist-hash类型也放入其中，主要因为intset编码必须存储整数，当集合内保存非整数数据时，无法使用intset实现内存优化。这时可以使用ziplist-hash类型对象模拟集合类型，hash的field当作集合中的元素，value设置为1字节占位符即可。使用ziplist编码的hash类型依然比使用hashtable编码的集合节省大量内存。\r\n<a name=\"chapter6\"> </a>\r\n## 六 控制key的数量\r\n\r\n当使用Redis存储大量数据时，通常会存在大量键，过多的键同样会消耗大量内存。Redis本质是一个数据结构服务器，它为我们提供多种数据结构，如hash，list，set，zset等结构。使用Redis时不要进入一个误区，大量使用get/set这样的API，把Redis当成Memcached使用。对于存储相同的数据内容利用Redis的数据结构降低外层键的数量，也可以节省大量内存。如下图所示，通过在客户端预估键规模，把大量键分组映射到多个hash结构中降低键的数量。\r\n![3084_d48315af_6789_08d6_823d_beec6378e7da_1.png](http://www.fxjson.com/usr/uploads/2021/09/3817038926.png)\r\nhash结构降低键数量分析：\r\n\r\n*   根据键规模在客户端通过分组映射到一组hash对象中，如存在100万个键，可以映射到1000个hash中，每个hash保存1000个元素。\r\n*   hash的field可用于记录原始key字符串，方便哈希查找。\r\n*   hash的value保存原始值对象，确保不要超过hash-max-ziplist-value限制。\r\n下面测试这种优化技巧的内存表现，如下表所示。\r\n\r\n#### 表：hash分组控制键规模测试\r\n\r\n| 数据量  | key大小  | value大小 | string类型占用内存 | hash-ziplist类型占用内存 | 内存降低比例 | string:set平均耗时 | hash:hset平均耗时 |\r\n|------|--------|---------|--------------|--------------------|--------|----------------|---------------|\r\n| 200w | 20byte | 512byte | 1392.64MB    | 1000.97MB          | 28.1%  | 2.13微秒         | 21.28微秒       |\r\n| 200w | 20byte | 200byte | 596.62MB     | 399.38MB           | 33.1%  | 1.49微秒         | 16.08微秒       |\r\n| 200w | 20byte | 100byte | 382.99MB     | 211.88MB           | 44.6%  | 1.30微秒         | 14.92微秒       |\r\n| 200w | 20byte | 50byte  | 291.46MB     | 110.32MB           | 62.1%  | 1.28微秒         | 13.48微秒       |\r\n| 200w | 20byte | 20byte  | 246.40MB     | 55.63MB            | 77.4%  | 1.10微秒         | 13.21微秒       |\r\n| 200w | 20byte | 5byte   | 199.93MB     | 24.42MB            | 87.7%  | 1.10微秒         | 13.06微秒       |\r\n\r\n\r\n通过这个测试数据，可以说明：\r\n\r\n*   同样的数据使用ziplist编码的hash类型存储比string类型节约内存\r\n*   节省内存量随着value空间的减少，越来越明显。\r\n*   hash-ziplist类型比string类型写入耗时，但随着value空间的减少，耗时逐渐降低。\r\n使用hash重构后节省内存量效果非常明显，特变对于存储小对象的场景，内存只有不到原来的1/5。下面分析这种内存优化技巧的关键点：\r\n	* 1)hash类型节省内存的原理是使用ziplist编码，如果使用hashtable编码方式反而会增加内存消耗。\r\n	* 2)ziplist长度需要控制在1000以内，否则由于存取操作时间复杂度在O(n)到O(n2)之间，长列表会导致CPU消耗严重，得不偿失。\r\n	* 3)ziplist适合存储的小对象，对于大对象不但内存优化效果不明显还会增加命令操作耗时。\r\n	* 4) 需要预估键的规模，从而确定每个hash结构需要存储的元素数量。\r\n	* 5)根据hash长度和元素大小，调整hash-max-ziplist-entries和hash-max-ziplist-value参数，确保hash类型使用ziplist编码。\r\n\r\n关于hash键和field键的设计：\r\n1)  当键离散度较高时，可以按字符串位截取，把后三位作为哈希的field，之前部分作为哈希的键。如：key=1948480 哈希key=group: hash:1948，哈希field=480。\r\n2)当键离散度较低时，可以使用哈希算法打散键，如:使用crc32(key)&amp;10000函数把所有的键映射到“0-9999”整数范围内，哈希field存储键的原始值。\r\n3)尽量减少hash键和field的长度，如使用部分键内容。\r\n\r\n使用hash结构控制键的规模虽然可以大幅降低内存，但同样会带来问题，需要提前做好规避处理。如下:\r\n1.  客户端需要预估键的规模并设计hash分组规则，加重客户端开发成本。\r\n2.  hash重构后所有的键无法再使用超时(expire)和LRU淘汰机制自动删除，需要手动维护删除。\r\n3.  对于大对象，如1KB以上的对象。使用hash-ziplist结构控制键数量。\r\n不过瑕不掩瑜，对于大量小对象的存储场景，非常适合使用ziplist编码的hash类型控制键的规模来降低内存。\r\n```shell\r\n开发提示：使用ziplist+hash优化keys后，如果想使用超时删除功能，开发人员可以存储每个对象写入的时间，再通过定时任务使用hscan命令扫描数据，找出hash内超时的数据项删除即可。\r\n```\r\n\r\n本文主要讲解Redis内存优化技巧，Redis的数据特性是”ALL IN MEMORY”，优化内存将变得非常重要。对于内存优化建议读者先要掌握Redis内存存储的特性比如字符串，压缩编码，整数集合等，再根据数据规模和所用命令需求去调整，从而达到空间和效率的最佳平衡。建议使用Redis存储大量数据时，把内存优化环节加入到前期设计阶段，否则数据大幅增长后，开发人员需要面对重新优化内存所带来开发和数据迁移的双重成本。当Redis内存不足时，首先考虑的问题不是加机器做水平扩展，应该先尝试做内存优化。当遇到瓶颈时，再去考虑水平扩展。即使对于集群化方案，垂直层面优化也同样重要，避免不必要的资源浪费和集群化后的管理成本。',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,477,0),(121,'Redis3.2的内存回收机制之过期删除策略','121',1631943960,1631944490,'<!--markdown-->### 概念\r\n过期删除策略指的是删除达到过期时间的key。\r\n通常有3种处理方式，分别是`定时删除`、`惰性删除`、`定期删除`。\r\n- 定时删除\r\n对于每一个设置了过期时间的key都会创建一个定时器，一旦到达过期时间就立即删除。该策略可以立即清除过期的数据，对内存较友好，但是缺点是占用了大量的CPU资源去处理过期的数据，会影响Redis的吞吐量和响应时间\r\n\r\n- 惰性删除\r\n当访问一个key时，才判断该key是否过期，过期则删除。该策略能最大限度地节省CPU资源，但是对内存却十分不友好。有一种极端的情况是可能出现大量的过期key没有被再次访问，因此不会被清除，导致占用了大量的内存。\r\n\r\n- 定期删除\r\n每隔一段时间，扫描Redis中过期key字典，并清除部分过期的key。该策略是前两者的一个折中方案，还可以通过调整定时扫描的时间间隔和每次扫描的限定耗时，在不同情况下使得CPU和内存资源达到最优的平衡效果\r\n\r\n### Redis中的过期删除策略\r\n**在Redis中，同时使用了定期删除和惰性删除，而没用使用定时删除**\r\n\r\n- redis中的惰性删除\r\n在客户端调用GET、TTL、TYPE、HGET、MGET、HMGET等访问key的命令时，都会直接或者间接的调用`expireIfNeeded`函数，这个函数会验证key是否过期，如果过期了会删除过期的key，从而回收占用的内存。函数具体逻辑如下:\r\n	- 如果没有设置过期时间，则直接return\r\n	- 如果正在加载rdb、aof文件，则直接return\r\n	- 如果是非master进程，则直接return\r\n	- 如果没有过期，则不进行操作，直接return\r\n	- 上面条件都不满足，表示过期了，会aof文件追加一条del命令(如果开启aof的话)，然后删除key\r\n```shell\r\n * Return value is the number of keys existing. */\r\nvoid existsCommand(client *c) {\r\n    long long count = 0;\r\n    int j;\r\n\r\n    for (j = 1; j < c->argc; j++) {\r\n        expireIfNeeded(c->db,c->argv[j]);\r\n        if (dbExists(c->db,c->argv[j])) count++;\r\n    }\r\n    addReplyLongLong(c,count);\r\n}\r\n```\r\n我们可以看到其中调用了`expireIfNeeded`方法，下面是`expireIfNeeded`函数的全部代码\r\n```\r\nint expireIfNeeded(redisDb *db, robj *key) {\r\n    mstime_t when = getExpire(db,key);\r\n    mstime_t now;\r\n\r\n    if (when < 0) return 0; /* No expire for this key */\r\n\r\n    /* Don\'t expire anything while loading. It will be done later. */\r\n    if (server.loading) return 0;\r\n\r\n    /* If we are in the context of a Lua script, we claim that time is\r\n     * blocked to when the Lua script started. This way a key can expire\r\n     * only the first time it is accessed and not in the middle of the\r\n     * script execution, making propagation to slaves / AOF consistent.\r\n     * See issue #1525 on Github for more information. */\r\n    now = server.lua_caller ? server.lua_time_start : mstime();\r\n\r\n    /* If we are running in the context of a slave, return ASAP:\r\n     * the slave key expiration is controlled by the master that will\r\n     * send us synthesized DEL operations for expired keys.\r\n     *\r\n     * Still we try to return the right information to the caller,\r\n     * that is, 0 if we think the key should be still valid, 1 if\r\n     * we think the key is expired at this time. */\r\n    if (server.masterhost != NULL) return now > when;\r\n\r\n    /* Return when this key has not expired */\r\n    if (now <= when) return 0;\r\n\r\n    /* Delete the key */\r\n    server.stat_expiredkeys++;\r\n    propagateExpire(db,key);\r\n    notifyKeyspaceEvent(NOTIFY_EXPIRED,\r\n        \"expired\",key,db->id);\r\n    return dbDelete(db,key);\r\n}\r\n```\r\n\r\n- Redis的定期删除\r\nRedis在启动的时候，会注册一个时间事件，时间事件主要是Redis处理后台操作的一类事件，比如客户端超时、删除过期key。Redis通过注册的serverCron时间事件调用databasesCron函数，实现清理部分过期key的目的。serverCron事件会每100ms执行一次，这样实现定期进行清理。\r\n```shell\r\nserver.c的main函数=>initServer()=>创建serverCron时间事件=>databasesCron()=>activeExpireCycle=>调用activeExpireCycleTryExpire函数，进行过期键的清理工作\r\n```\r\nactiveExpireCycle函数是处理的核心逻辑，代码如下:\r\n```c\r\nvoid activeExpireCycle(int type) {\r\n    /* This function has some global state in order to continue the work\r\n     * incrementally across calls. */\r\n    static unsigned int current_db = 0; /* Last DB tested. */\r\n    static int timelimit_exit = 0;      /* Time limit hit in previous call? */\r\n    static long long last_fast_cycle = 0; /* When last fast cycle ran. */\r\n\r\n    int j, iteration = 0;\r\n    int dbs_per_call = CRON_DBS_PER_CALL;\r\n    long long start = ustime(), timelimit;\r\n\r\n    if (type == ACTIVE_EXPIRE_CYCLE_FAST) {\r\n        /* Don\'t start a fast cycle if the previous cycle did not exited\r\n         * for time limt. Also don\'t repeat a fast cycle for the same period\r\n         * as the fast cycle total duration itself. */\r\n        if (!timelimit_exit) return;\r\n        if (start < last_fast_cycle + ACTIVE_EXPIRE_CYCLE_FAST_DURATION*2) return;\r\n        last_fast_cycle = start;\r\n    }\r\n\r\n    /* We usually should test CRON_DBS_PER_CALL per iteration, with\r\n     * two exceptions:\r\n     *\r\n     * 1) Don\'t test more DBs than we have.\r\n     * 2) If last time we hit the time limit, we want to scan all DBs\r\n     * in this iteration, as there is work to do in some DB and we don\'t want\r\n     * expired keys to use memory for too much time. */\r\n    if (dbs_per_call > server.dbnum || timelimit_exit)\r\n        dbs_per_call = server.dbnum;\r\n\r\n    /* We can use at max ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC percentage of CPU time\r\n     * per iteration. Since this function gets called with a frequency of\r\n     * server.hz times per second, the following is the max amount of\r\n     * microseconds we can spend in this function. */\r\n    timelimit = 1000000*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/100;\r\n    timelimit_exit = 0;\r\n    if (timelimit <= 0) timelimit = 1;\r\n\r\n    if (type == ACTIVE_EXPIRE_CYCLE_FAST)\r\n        timelimit = ACTIVE_EXPIRE_CYCLE_FAST_DURATION; /* in microseconds. */\r\n\r\n    for (j = 0; j < dbs_per_call; j++) {\r\n        int expired;\r\n        redisDb *db = server.db+(current_db % server.dbnum);\r\n\r\n        /* Increment the DB now so we are sure if we run out of time\r\n         * in the current DB we\'ll restart from the next. This allows to\r\n         * distribute the time evenly across DBs. */\r\n        current_db++;\r\n\r\n        /* Continue to expire if at the end of the cycle more than 25%\r\n         * of the keys were expired. */\r\n        do {\r\n            unsigned long num, slots;\r\n            long long now, ttl_sum;\r\n            int ttl_samples;\r\n\r\n            /* If there is nothing to expire try next DB ASAP. */\r\n            if ((num = dictSize(db->expires)) == 0) {\r\n                db->avg_ttl = 0;\r\n                break;\r\n            }\r\n            slots = dictSlots(db->expires);\r\n            now = mstime();\r\n\r\n            /* When there are less than 1% filled slots getting random\r\n             * keys is expensive, so stop here waiting for better times...\r\n             * The dictionary will be resized asap. */\r\n            if (num && slots > DICT_HT_INITIAL_SIZE &&\r\n                (num*100/slots < 1)) break;\r\n\r\n            /* The main collection cycle. Sample random keys among keys\r\n             * with an expire set, checking for expired ones. */\r\n            expired = 0;\r\n            ttl_sum = 0;\r\n            ttl_samples = 0;\r\n\r\n            if (num > ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP)\r\n                num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP;\r\n\r\n            while (num--) {\r\n                dictEntry *de;\r\n                long long ttl;\r\n\r\n                if ((de = dictGetRandomKey(db->expires)) == NULL) break;\r\n                ttl = dictGetSignedIntegerVal(de)-now;\r\n                if (activeExpireCycleTryExpire(db,de,now)) expired++;\r\n                if (ttl > 0) {\r\n                    /* We want the average TTL of keys yet not expired. */\r\n                    ttl_sum += ttl;\r\n                    ttl_samples++;\r\n                }\r\n            }\r\n\r\n            /* Update the average TTL stats for this database. */\r\n            if (ttl_samples) {\r\n                long long avg_ttl = ttl_sum/ttl_samples;\r\n\r\n                /* Do a simple running average with a few samples.\r\n                 * We just use the current estimate with a weight of 2%\r\n                 * and the previous estimate with a weight of 98%. */\r\n                if (db->avg_ttl == 0) db->avg_ttl = avg_ttl;\r\n                db->avg_ttl = (db->avg_ttl/50)*49 + (avg_ttl/50);\r\n            }\r\n\r\n            /* We can\'t block forever here even if there are many keys to\r\n             * expire. So after a given amount of milliseconds return to the\r\n             * caller waiting for the other active expire cycle. */\r\n            iteration++;\r\n            if ((iteration & 0xf) == 0) { /* check once every 16 iterations. */\r\n                long long elapsed = ustime()-start;\r\n\r\n                latencyAddSampleIfNeeded(\"expire-cycle\",elapsed/1000);\r\n                if (elapsed > timelimit) timelimit_exit = 1;\r\n            }\r\n            if (timelimit_exit) return;\r\n            /* We don\'t repeat the cycle if there are less than 25% of keys\r\n             * found expired in the current DB. */\r\n        } while (expired > ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/4);\r\n    }\r\n}\r\n```\r\n我们可以看到逻辑:\r\n从一定数量的db中随机取固定数量的设置有过期时间的key，如果过期了，则进行过期键的删除。其中db数量可以配置，默认16个；查询的key个数也可以配置，默认20个。\r\n',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,508,0),(108,'3084_8e427aa5_bf49_c714_45f8_692fccf2cd6b_1.png','3084_8e427aa5_bf49_c714_45f8_692fccf2cd6b_1-png',1631236479,1631236479,'a:5:{s:4:\"name\";s:47:\"3084_8e427aa5_bf49_c714_45f8_692fccf2cd6b_1.png\";s:4:\"path\";s:35:\"/usr/uploads/2021/09/2911227198.png\";s:4:\"size\";i:93560;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',2,2,NULL,'attachment','publish',NULL,0,'1','0','1',106,0,0),(107,'1png.png','1png-png',1631236078,1631236078,'a:5:{s:4:\"name\";s:8:\"1png.png\";s:4:\"path\";s:34:\"/usr/uploads/2021/09/435384062.png\";s:4:\"size\";i:138147;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',1,2,NULL,'attachment','publish',NULL,0,'1','0','1',106,0,0),(109,'3084_ffd40aaf_b79c_0c62_9751_650a6b0ccc53_1.png','3084_ffd40aaf_b79c_0c62_9751_650a6b0ccc53_1-png',1631236708,1631236708,'a:5:{s:4:\"name\";s:47:\"3084_ffd40aaf_b79c_0c62_9751_650a6b0ccc53_1.png\";s:4:\"path\";s:34:\"/usr/uploads/2021/09/204039170.png\";s:4:\"size\";i:91707;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',3,2,NULL,'attachment','publish',NULL,0,'1','0','1',106,0,0),(110,'3084_54bb9bb0_a89d_8e7e_2edb_11fcfc6ee5f1_1.png','3084_54bb9bb0_a89d_8e7e_2edb_11fcfc6ee5f1_1-png',1631237160,1631237160,'a:5:{s:4:\"name\";s:47:\"3084_54bb9bb0_a89d_8e7e_2edb_11fcfc6ee5f1_1.png\";s:4:\"path\";s:35:\"/usr/uploads/2021/09/1621911020.png\";s:4:\"size\";i:77828;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',4,2,NULL,'attachment','publish',NULL,0,'1','0','1',106,0,0),(111,'3084_348deb09_9394_4809_f74f_638d4a8cc902_1.png','3084_348deb09_9394_4809_f74f_638d4a8cc902_1-png',1631237245,1631237245,'a:5:{s:4:\"name\";s:47:\"3084_348deb09_9394_4809_f74f_638d4a8cc902_1.png\";s:4:\"path\";s:35:\"/usr/uploads/2021/09/1620578911.png\";s:4:\"size\";i:77097;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',5,2,NULL,'attachment','publish',NULL,0,'1','0','1',106,0,0),(112,'3084_ea8adf90_7c43_cff3_2bf8_7426f0fa60de_1.png','3084_ea8adf90_7c43_cff3_2bf8_7426f0fa60de_1-png',1631237367,1631237367,'a:5:{s:4:\"name\";s:47:\"3084_ea8adf90_7c43_cff3_2bf8_7426f0fa60de_1.png\";s:4:\"path\";s:35:\"/usr/uploads/2021/09/3966228186.png\";s:4:\"size\";i:79130;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',6,2,NULL,'attachment','publish',NULL,0,'1','0','1',106,0,0),(114,'3084_0a3583f6_57d1_9c73_95b9_13bd067bc3c9_1.png','3084_0a3583f6_57d1_9c73_95b9_13bd067bc3c9_1-png',1631237505,1631237505,'a:5:{s:4:\"name\";s:47:\"3084_0a3583f6_57d1_9c73_95b9_13bd067bc3c9_1.png\";s:4:\"path\";s:35:\"/usr/uploads/2021/09/3423879729.png\";s:4:\"size\";i:78986;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',7,2,NULL,'attachment','publish',NULL,0,'1','0','1',106,0,0),(122,'Redis编译失败问题','122',1637298000,1637298102,'<!--markdown-->- problem：No rule to make target \'release.h\', needed by \'release.o\'.  Stop\r\n**解决方式:**\r\n```shell\r\nchmod 777 src/mkreleasehdr.sh\r\n```\r\n\r\n- 错误：jemalloc/jemalloc.h：没有那个文件或目录\r\n错误：#error \"Newer version of jemalloc required\"\r\n**解决方式:**\r\n```shell\r\nmake MALLOC=libc\r\n```',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,391,0),(123,'Laravel包之macroable的精妙设计','123',1641107760,1641107938,'<!--markdown-->今天看Laravel源码中的composer时，发现了`illuminate/macroable`,然后就了解了下，包代码只有一个文件，源码如下:\r\n```php\r\n<?php\r\n\r\nnamespace Illuminate\\Support\\Traits;\r\n\r\nuse BadMethodCallException;\r\nuse Closure;\r\nuse ReflectionClass;\r\nuse ReflectionMethod;\r\n\r\ntrait Macroable\r\n{\r\n    /**\r\n     * The registered string macros.\r\n     *\r\n     * @var array\r\n     */\r\n    protected static $macros = [];\r\n\r\n    /**\r\n     * Register a custom macro.\r\n     *\r\n     * @param  string  $name\r\n     * @param  object|callable  $macro\r\n     * @return void\r\n     */\r\n    public static function macro($name, $macro)\r\n    {\r\n        static::$macros[$name] = $macro;\r\n    }\r\n\r\n    /**\r\n     * Mix another object into the class.\r\n     *\r\n     * @param  object  $mixin\r\n     * @param  bool  $replace\r\n     * @return void\r\n     *\r\n     * @throws \\ReflectionException\r\n     */\r\n    public static function mixin($mixin, $replace = true)\r\n    {\r\n        $methods = (new ReflectionClass($mixin))->getMethods(\r\n            ReflectionMethod::IS_PUBLIC | ReflectionMethod::IS_PROTECTED\r\n        );\r\n        var_dump($methods);\r\n        foreach ($methods as $method) {\r\n            if ($replace || ! static::hasMacro($method->name)) {\r\n                $method->setAccessible(true);\r\n                static::macro($method->name, $method->invoke($mixin));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if macro is registered.\r\n     *\r\n     * @param  string  $name\r\n     * @return bool\r\n     */\r\n    public static function hasMacro($name)\r\n    {\r\n        return isset(static::$macros[$name]);\r\n    }\r\n\r\n    /**\r\n     * Flush the existing macros.\r\n     *\r\n     * @return void\r\n     */\r\n    public static function flushMacros()\r\n    {\r\n        static::$macros = [];\r\n    }\r\n\r\n    /**\r\n     * Dynamically handle calls to the class.\r\n     *\r\n     * @param  string  $method\r\n     * @param  array  $parameters\r\n     * @return mixed\r\n     *\r\n     * @throws \\BadMethodCallException\r\n     */\r\n    public static function __callStatic($method, $parameters)\r\n    {\r\n        if (! static::hasMacro($method)) {\r\n            throw new BadMethodCallException(sprintf(\r\n                \'Method %s::%s does not exist.\', static::class, $method\r\n            ));\r\n        }\r\n\r\n        $macro = static::$macros[$method];\r\n\r\n        if ($macro instanceof Closure) {\r\n            $macro = $macro->bindTo(null, static::class);\r\n        }\r\n\r\n        return $macro(...$parameters);\r\n    }\r\n\r\n    /**\r\n     * Dynamically handle calls to the class.\r\n     *\r\n     * @param  string  $method\r\n     * @param  array  $parameters\r\n     * @return mixed\r\n     *\r\n     * @throws \\BadMethodCallException\r\n     */\r\n    public function __call($method, $parameters)\r\n    {\r\n        if (! static::hasMacro($method)) {\r\n            throw new BadMethodCallException(sprintf(\r\n                \'Method %s::%s does not exist.\', static::class, $method\r\n            ));\r\n        }\r\n\r\n        $macro = static::$macros[$method];\r\n\r\n        if ($macro instanceof Closure) {\r\n            $macro = $macro->bindTo($this, static::class);\r\n        }\r\n\r\n        return $macro(...$parameters);\r\n    }\r\n}\r\n\r\n```\r\n使用例子如下:\r\n```php\r\nrequire __DIR__.\'/vendor/autoload.php\';\r\n\r\nuse Illuminate\\Support\\Traits\\Macroable;\r\n\r\nclass Hello {\r\n    use Macroable;\r\n    \r\n    public $name = \"hello\";\r\n}\r\n\r\nHello::macro(\"sayHi\",function($name) {\r\n    echo \"hello,\".$name;\r\n});\r\n\r\nHello::sayHi(\"Json\");\r\n\r\n$hello = new Hello;\r\n\r\n$hello->sayHi(\"杰哥\");\r\n\r\n\r\nHello::macro(\"Say\",function() {\r\n    echo \"hello,\".$this->name;\r\n});\r\n\r\n$hello->Say();\r\n```\r\nmacroable包就是定义了一个trait，然后使用了该trait的类，可以通过代码动态挂载函数到类或者实例上面，然后可以像访问静态方法或者实例方法一样调用方法了，如上面的`Hello::sayHi`和`$hello->Say`。\r\n\r\n本质上还是利用了php本身的`__call`和`__callStatic`魔术方法结合`static`静态变量实现的，本人越来越不喜欢魔术方法了，因为编辑器难以提示，IDE追踪起来困难，但是代码却可以完好跑起来，太神奇了，心里总是不踏实。\r\n\r\n但是不可否认的是`macroable`包，让代码看起来更优雅，更面向对象了，让开发者写代码更舒服了',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,271,0),(124,'现代化php新特性','124',1646664449,1646664449,'<!--markdown-->### 数组\r\n\r\n#### 解构赋值[7.1]\r\n\r\n- 可以 解构数组，将多个元素提取到单独的变量中\r\n\r\n  ```php\r\n  $array = [11, 22, 33];\r\n  // 使用list语法:\r\n  list($a, $b, $c) = $array;\r\n  // 或速记语法:\r\n  [$a, $b, $c] = $array;\r\n  ```\r\n\r\n- 跳过元素解构\r\n\r\n  ```php\r\n  $array = [11, 22, 33];\r\n  [, , $c] = $array;\r\n  ```\r\n\r\n- 基于键的解构\r\n\r\n  ```php\r\n  $array = [\r\n      \'a\' => 1,\r\n      \'b\' => 2,\r\n      \'c\' => 3,\r\n  ];\r\n  [\'c\' => $c, \'a\' => $a] = $array;\r\n  ```\r\n\r\n#### 展开操作符`...`[5.6]\r\n\r\n- 数组可以展开到函数中\r\n\r\n  ```php\r\n  function test($a,$b) {\r\n      var_dump($a,$b);\r\n  }\r\n  $arr = [11, 22];\r\n  test(...$arr);\r\n  ```\r\n\r\n- 函数可以使用`...`算符自动收集其余变量\r\n\r\n  ```php\r\n  function test($a,...$arr) {\r\n      var_dump($a,$arr);\r\n  }\r\n  test(1,2,3,4,5);\r\n  ```\r\n\r\n  剩余参数甚至可以类型提示\r\n\r\n  ```php\r\n  function test($a,int ...$arr) {\r\n      var_dump($a,$arr);\r\n  }\r\n  test(1,2,3,4,5);\r\n  ```\r\n\r\n- 具有数值键的数组也可以展开到新数组中[7.4]\r\n\r\n  ```php\r\n  $a = [11,22];\r\n  $b = [33,44];\r\n  var_dump([...$a,...$b]);\r\n  ```\r\n\r\n- 使用字符串键展开数组[8.1]\r\n\r\n  ```php\r\n  $a = [\'one\'=>1,\'two\'=>2];\r\n  $b = [33,\'one\'=>11];\r\n  var_dump([...$a,...$b]);\r\n  ```\r\n\r\n### 闭包\r\n\r\n#### 箭头函数[7.4]\r\n\r\n短闭包可自动访问外部作用域，并且只允许自动返回单个表达式\r\n\r\n```php\r\n$arr = [1,3,4,5,6,7];\r\n$result = array_filter($arr,fn($value)=>$value%2==0);\r\nvar_dump($result);\r\n```\r\n\r\n#### 可调用对象[8.1]\r\n\r\n通过传递`...`作为参数到调用的callable 来生成一个闭包\r\n\r\n```php\r\nfunction test($a,$b) {\r\n    var_dump($a,$b);\r\n}\r\n$foo = test(...);\r\n$foo(b:\'bb\',a:\'aa\');\r\n```\r\n\r\n### 修饰\r\n\r\n#### 类名[8.0]\r\n\r\n从 PHP 8 开始，您也可以在对象上使用`::class`\r\n\r\n```php\r\nclass Test {\r\n}\r\n$test = new Test;\r\nvar_dump(Test::class,$test::class);\r\n```\r\n\r\n#### 数字值[7.4]\r\n\r\n使用 `_` 运算符设置数值的格式\r\n\r\n```php\r\n$number = 100_20;\r\n```\r\n\r\n#### 尾随逗号[8.0]\r\n\r\n几个地方允许尾随逗号:\r\n\r\n- 数组\r\n- 函数调用\r\n- 函数定义\r\n- 闭包的 `use` 语句\r\n\r\n### Enums(枚举)[8.1]\r\n\r\n#### 声明枚举\r\n\r\n枚举内置于语言中\r\n\r\n```PHP\r\nenum Status\r\n{\r\n    case DRAFT;\r\n    case PUBLISHED;\r\n    case ARCHIVED;\r\n}\r\nvar_dump(Status::DRAFT);\r\n```\r\n\r\n#### 枚举方法\r\n\r\n枚举可以包含方法，也可以具有每个case的字符串或整数值\r\n\r\n```php\r\nenum Status: int\r\n{\r\n    case DRAFT = 1;\r\n    case PUBLISHED = 2;\r\n    case ARCHIVED = 3;\r\n\r\n    public function color(): string\r\n    {\r\n        return match($this)\r\n        {\r\n            Status::DRAFT => \'grey\',\r\n            Status::PUBLISHED => \'green\',\r\n            Status::ARCHIVED => \'red\',\r\n        };\r\n    }\r\n}\r\n\r\n$status = Status::PUBLISHED;\r\nvar_dump($status->color());\r\n```\r\n\r\n### 异常[8.0]\r\n\r\n引发异常现在是一个表达式，这意味着可以在更多位置抛出，例如短闭包或null并合运算符处\r\n\r\n```php\r\n$error = fn($message) => throw new Error($message);\r\n$input = $data[\'input\'] ?? throw new Exception(\'Input not set\');\r\n```\r\n\r\n### match[8.0]\r\n\r\n相比switch， match会直接返回值\r\n\r\n```php\r\n$result = match($input) {\r\n        \"true\" => 1,\r\n        \"false\" => 0,\r\n        \"null\" => NULL,\r\n};\r\n```\r\n\r\n### null\r\n\r\n#### null合并[7.0]\r\n\r\nPHP 7 新增加的 NULL 合并运算符（??）是用于执行isset()检测的三元运算的快捷方式。\r\n\r\nNULL 合并运算符会判断变量是否存在且值不为NULL，如果是，它就会返回自身的值，否则返回它的第二个操作数\r\n\r\n```php\r\nvar_dump(isset($a)?$a:\'bb\');\r\nvar_dump($a??\'bb\');\r\n```\r\n\r\n可以使用 null 合并*赋值*运算符在原始变量为 `null`时将值写入原始变量[7.4]\r\n\r\n```php\r\n$temp = $a??=\'hello\';\r\nvar_dump($temp,$a);\r\n```\r\n\r\n#### Nullsafe运算符[8.0]\r\n\r\n可能返回`null`的链式方法\r\n\r\n```php\r\n$object\r\n?->methodA()\r\n?->methodB()\r\n?->methodC();\r\n```\r\n\r\n### 命名参数[8.0]\r\n\r\n按名称而不是位置传递参数\r\n\r\n```php\r\nfunction test($name,$age) {\r\n    var_dump($name,$age);\r\n}\r\ntest(age:32,name:\"json\");\r\n```\r\n\r\n命名参数还支持数组展开\r\n\r\n```php\r\nfunction test($name,$age) {\r\n    var_dump($name,$age);\r\n}\r\n$arr = [\r\n    \'name\' => \'json\',\r\n    \'age\'  => 32,\r\n];\r\ntest(...$arr);\r\n```\r\n\r\n### 构造函数属性提升[8.0]\r\n\r\n将构造函数参数加上`public`, `protected` 或 `private`参数，以使其得到提升\r\n\r\n```php\r\nclass Test {\r\n    public function __construct(\r\n        public string $name,\r\n        private int $age\r\n    )\r\n    {\r\n        \r\n    }\r\n}\r\n```\r\n\r\n仍然可以添加构造函数体，并合并提升属性和非提升属性\r\n\r\n```php\r\nclass Test {\r\n    private $age;\r\n    public function __construct(\r\n        public string $name,\r\n        int $age\r\n    )\r\n    {\r\n        $this->age = $age;\r\n    }\r\n}\r\n```\r\n\r\n### 在初始化器中使用new关键字[8.1]\r\n\r\nPHP 8.1 允许您在函数或者方法定义中使用 new 关键字作为默认参数\r\n\r\n```php\r\nclass Test {\r\n    public function say($cls = new stdClass) {\r\n        var_dump($cls);\r\n    }\r\n}\r\n```\r\n\r\n### 只读属性[8.1]\r\n\r\n- 只读属性必须与类型化属性结合使用\r\n- 只读属性不能有默认值，除非它们是提升的属性\r\n- 一旦设置了只读属性，它就不能再更改了\r\n\r\n```php\r\nclass Test {\r\n    public readonly string $name;//无默认值\r\n    public function __construct(\r\n        $name,\r\n        public readonly int $age = 34,// 提升的属性\r\n    )\r\n    {\r\n        $this->name = $name;\r\n    }\r\n}\r\n```\r\n\r\n',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,160,0),(125,'MySQL中ROUND函数进行四舍五入操作陷阱','125',1647496380,1647498014,'<!--markdown-->### 问题\r\n\r\nsql语句中使用内置的round函数可能不会得到预期结果，案例如下:\r\n- 创建测试表\r\n表中字段有不同类型的数据类型，方便测试不同数据类型的现象\r\n```sql\r\nCREATE TABLE test(\r\n	id INT PRIMARY KEY AUTO_INCREMENT,\r\n	amount_1 FLOAT DEFAULT NULL,\r\n	amount_2 DOUBLE DEFAULT NULL,\r\n	amount_3 VARCHAR(10) DEFAULT NULL,\r\n	amount_4 VARCHAR(10) DEFAULT NULL,\r\n	amount_5 DECIMAL(20,4) DEFAULT NULL\r\n);\r\n```\r\n- 写入测试数据\r\n```sql\r\nINSERT INTO test VALUES (NULL,3.245,3.245,\'3.245\',\'3.245\',3.245);\r\nINSERT INTO test VALUES (NULL,3.265,3.265,\'3.265\',\'3.265\',3.265);\r\nINSERT INTO test VALUES (NULL,3.5,3.5,\'3.5\',\'3.5\',3.5);\r\n```\r\n- 查看数据\r\n```sql\r\nselect * from test;\r\n```\r\n\r\n| id  |  amount_1 |amount_2|amount_3|amount_4|amount_5|\r\n| ------------ | ------------ | ------------ | ------------ | ------------ | ------------ |\r\n|  1 |    3.245 |    3.245 | 3.245    | 3.245    |   3.2450 |\r\n|  2 |    3.265 |    3.265 | 3.265    | 3.265    |   3.2650 |\r\n|  3 |      3.5 |      3.5 | 3.5      | 3.5      |   3.5000 |\r\n- 使用round函数，查看数据\r\n```sql\r\nSELECT ROUND(amount_1,2),ROUND(amount_2,2),ROUND(amount_3,2),ROUND(amount_4,2),ROUND(amount_5,2) FROM test;\r\n```\r\n\r\n| ROUND(amount_1,2) | ROUND(amount_2,2) | ROUND(amount_3,2) | ROUND(amount_4,2) | ROUND(amount_5,2) |\r\n| ------------ | ------------ | ------------ | ------------ | ------------ | ------------ |\r\n|              3.24 |              3.24 |              3.24 |              3.24 |              3.25 |\r\n|              3.27 |              3.26 |              3.26 |              3.26 |              3.27 |\r\n|              3.50 |              3.50 |              3.50 |              3.50 |              3.50 |\r\n\r\n我们可以很明显的看到，使用round后，并不能得到预期的结果，比如3.245保留两位小数后，有的结果是3.24，有的结果是3.25，但是我们预期的结果应该是3.25，这是什么原因呢？\r\n\r\n### 官方解释\r\nmysql官方文档中关于ROUND函数的部分，其中包含下面两条规则\r\n\r\n- For exact-value numbers, ROUND() uses the “round half up” rule**（对于精确的数值， ROUND 函数使用四舍五入）**\r\n- For approximate-value numbers, the result depends on the C library. On many systems, this means that ROUND() uses the “round to nearest even” rule: A value with any fractional part is rounded to the nearest even integer **(对于近似值，则依赖于底层的C函数库，在很多系统中 ROUND 函数会使用“取最近的偶数”的规则）**\r\n\r\n根据这个解释，float、double类型是近似值，所以round保留小数位后，末尾应该是偶数，但是从上面的实际结果来看，float类型的3.265round之后是3.27，推翻了这个解释，于是我也不知道怎么解释了\r\n\r\ndecimal类型，mysql当做精确的数据，所以始终按照`四舍五入`保留小数位处理\r\n\r\n### 解决方式\r\n我们预期的结果是`四舍五入`，那有没有什么方式把float、varchar、char、double类型当做decimal类型呢？答案是肯定的，我们自己可以通过网络寻找答案，会好几种方式进行类型转换。\r\n- CAST函数\r\n```sql\r\nSELECT ROUND(CAST(amount_1 AS DECIMAL(20,4)),2),ROUND(CAST(amount_2 AS DECIMAL(20,4)),2),ROUND(CAST(amount_3 AS DECIMAL(20,4)),2),ROUND(CAST(amount_4 AS DECIMAL(20,4)),2),ROUND(CAST(amount_5 AS DECIMAL(20,4)),2) FROM test;\r\n```\r\n- CONVERT函数\r\n```sql\r\nSELECT ROUND(CONVERT(amount_1 , DECIMAL(20,4)),2),ROUND(CONVERT(amount_2 , DECIMAL(20,4)),2),ROUND(CONVERT(amount_3 , DECIMAL(20,4)),2),ROUND(CONVERT(amount_4 , DECIMAL(20,4)),2),ROUND(CONVERT(amount_5 , DECIMAL(20,4)),2) FROM test;\r\n```\r\n- 如果业务逻辑允许，可以修改表的字段类型为decimal类型，这样代码层面不需要做任何修改\r\n\r\n### 进阶\r\n解决方式有了，但是实际项目中，并不一定是刚开始就发现了这个坑，可能项目中已经有大量的地方使用了round函数，另一方面代码修改的话，到处都会有`convert(field,DECIMAL(20,4))`或者`cast(field as DECIMAL(20,4))`这样重复的代码,修改起来的话也更容易出错。有没有更好的方式呢？答案是肯定的。\r\n\r\nmysql为我们提供了可以创建自定义函数的通道，所以我们可以通过创建**自定义函数**(如何创建自定义函数，大家可以自行查阅资料)来替换mysql内置的round函数，然后代码批量替换round函数来达到我们的目的。\r\n那上面的例子举例，我们创建自定义my_round函数\r\n```sql\r\nDELIMITER $$\r\nCREATE FUNCTION MY_ROUND(X VARCHAR(30),D INT)\r\nRETURNS VARCHAR(30) DETERMINISTIC\r\nBEGIN\r\n RETURN(ROUND(CAST(X AS DECIMAL(20,4)),D));\r\nEND$$\r\nDELIMITER ;\r\n```\r\n代码层面批量替换之后，sql语句为\r\n```sql\r\nSELECT MY_ROUND(amount_1,2),MY_ROUND(amount_2,2),MY_ROUND(amount_3,2),MY_ROUND(amount_4,2),MY_ROUND(amount_5,2) FROM test;\r\n```\r\n只需要将`round`函数的关键字批量替换为`MY_ROUND`。\r\n\r\n| MY_ROUND(amount_1,2) | MY_ROUND(amount_2,2) | MY_ROUND(amount_3,2) | MY_ROUND(amount_4,2) | MY_ROUND(amount_5,2) |\r\n| ------------ | ------------ | ------------ | ------------ | ------------ | ------------ |\r\n| 3.25                 | 3.25                 | 3.25                 | 3.25                 | 3.25                 |\r\n| 3.27                 | 3.27                 | 3.27                 | 3.27                 | 3.27                 |\r\n| 3.50                 | 3.50                 | 3.50                 | 3.50                 | 3.50                 |\r\n\r\n以上就是所有内容了。',0,2,NULL,'post','publish',NULL,0,'1','1','1',0,145,0),(116,'3084_706c9e3a_9b61_95c5_69ac_f46b88d41bc5_1.png','3084_706c9e3a_9b61_95c5_69ac_f46b88d41bc5_1-png',1631250839,1631250839,'a:5:{s:4:\"name\";s:47:\"3084_706c9e3a_9b61_95c5_69ac_f46b88d41bc5_1.png\";s:4:\"path\";s:35:\"/usr/uploads/2021/09/2110683165.png\";s:4:\"size\";i:141115;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',8,2,NULL,'attachment','publish',NULL,0,'1','0','1',106,0,0),(117,'3084_8e48faac_2a3e_51f4_d602_1fb45a002892_1.png','3084_8e48faac_2a3e_51f4_d602_1fb45a002892_1-png',1631251096,1631251096,'a:5:{s:4:\"name\";s:47:\"3084_8e48faac_2a3e_51f4_d602_1fb45a002892_1.png\";s:4:\"path\";s:34:\"/usr/uploads/2021/09/558967085.png\";s:4:\"size\";i:108494;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',9,2,NULL,'attachment','publish',NULL,0,'1','0','1',106,0,0),(118,'3084_8e48faac_2a3e_51f4_d602_1fb45a002892_1.png','3084_8e48faac_2a3e_51f4_d602_1fb45a002892_1-png-1',1631251104,1631251104,'a:5:{s:4:\"name\";s:47:\"3084_8e48faac_2a3e_51f4_d602_1fb45a002892_1.png\";s:4:\"path\";s:34:\"/usr/uploads/2021/09/461866986.png\";s:4:\"size\";i:108494;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',10,2,NULL,'attachment','publish',NULL,0,'1','0','1',106,0,0),(119,'3084_5417a9b7_6050_0614_09f1_ce8565f04eca_1.png','3084_5417a9b7_6050_0614_09f1_ce8565f04eca_1-png',1631251310,1631251310,'a:5:{s:4:\"name\";s:47:\"3084_5417a9b7_6050_0614_09f1_ce8565f04eca_1.png\";s:4:\"path\";s:35:\"/usr/uploads/2021/09/2137304141.png\";s:4:\"size\";i:27617;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',11,2,NULL,'attachment','publish',NULL,0,'1','0','1',106,0,0),(120,'3084_d48315af_6789_08d6_823d_beec6378e7da_1.png','3084_d48315af_6789_08d6_823d_beec6378e7da_1-png',1631251391,1631251391,'a:5:{s:4:\"name\";s:47:\"3084_d48315af_6789_08d6_823d_beec6378e7da_1.png\";s:4:\"path\";s:35:\"/usr/uploads/2021/09/3817038926.png\";s:4:\"size\";i:73958;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',12,2,NULL,'attachment','publish',NULL,0,'1','0','1',106,0,0);
/*!40000 ALTER TABLE `tbl_contents` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tbl_fields`
--

DROP TABLE IF EXISTS `tbl_fields`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tbl_fields` (
  `cid` int(10) unsigned NOT NULL,
  `name` varchar(200) NOT NULL,
  `type` varchar(8) DEFAULT 'str',
  `str_value` text,
  `int_value` int(10) DEFAULT '0',
  `float_value` float DEFAULT '0',
  PRIMARY KEY (`cid`,`name`),
  KEY `int_value` (`int_value`),
  KEY `float_value` (`float_value`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tbl_fields`
--

LOCK TABLES `tbl_fields` WRITE;
/*!40000 ALTER TABLE `tbl_fields` DISABLE KEYS */;
/*!40000 ALTER TABLE `tbl_fields` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tbl_metas`
--

DROP TABLE IF EXISTS `tbl_metas`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tbl_metas` (
  `mid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(200) DEFAULT NULL,
  `slug` varchar(200) DEFAULT NULL,
  `type` varchar(32) NOT NULL,
  `description` varchar(200) DEFAULT NULL,
  `count` int(10) unsigned DEFAULT '0',
  `order` int(10) unsigned DEFAULT '0',
  `parent` int(10) unsigned DEFAULT '0',
  PRIMARY KEY (`mid`),
  KEY `slug` (`slug`)
) ENGINE=MyISAM AUTO_INCREMENT=12 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tbl_metas`
--

LOCK TABLES `tbl_metas` WRITE;
/*!40000 ALTER TABLE `tbl_metas` DISABLE KEYS */;
INSERT INTO `tbl_metas` VALUES (1,'PHP','php','category','php技术分享',72,1,0),(3,'tag','tags','tag',NULL,0,0,0),(6,'Java','java','category',NULL,1,2,0),(5,'其它','other','category',NULL,14,4,0),(7,'Go','golang','category','golang',2,3,0),(8,'openresty','openresty','tag',NULL,1,0,0),(9,'lua','lua','tag',NULL,2,0,0),(10,'linux','linux','tag',NULL,1,0,0),(11,'vim','vim','tag',NULL,1,0,0);
/*!40000 ALTER TABLE `tbl_metas` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tbl_options`
--

DROP TABLE IF EXISTS `tbl_options`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tbl_options` (
  `name` varchar(32) NOT NULL,
  `user` int(10) unsigned NOT NULL DEFAULT '0',
  `value` text,
  PRIMARY KEY (`name`,`user`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tbl_options`
--

LOCK TABLES `tbl_options` WRITE;
/*!40000 ALTER TABLE `tbl_options` DISABLE KEYS */;
INSERT INTO `tbl_options` VALUES ('theme',0,'simple'),('theme:SimpleType',0,'a:4:{s:8:\"subtitle\";s:30:\"专注软件开发技术分享\";s:5:\"links\";s:0:\"\";s:5:\"beian\";s:0:\"\";s:4:\"stat\";s:0:\"\";}'),('timezone',0,'28800'),('lang',0,NULL),('charset',0,'UTF-8'),('contentType',0,'text/html'),('gzip',0,'0'),('generator',0,'Typecho 1.1/17.10.30'),('title',0,'Json的博客'),('description',0,'分享技术、分享生活'),('keywords',0,'php,mysql,go,node,javascript,go.node.js,node,es6,python'),('rewrite',0,'1'),('frontPage',0,'recent'),('frontArchive',0,'0'),('commentsRequireMail',0,'0'),('commentsWhitelist',0,'0'),('commentsRequireURL',0,'0'),('commentsRequireModeration',0,'0'),('plugins',0,'a:2:{s:9:\"activated\";a:1:{s:8:\"EditorMD\";a:1:{s:7:\"handles\";a:5:{s:31:\"admin/write-post.php:richEditor\";a:1:{i:0;a:2:{i:0;s:15:\"EditorMD_Plugin\";i:1;s:6:\"Editor\";}}s:31:\"admin/write-page.php:richEditor\";a:1:{i:0;a:2:{i:0;s:15:\"EditorMD_Plugin\";i:1;s:6:\"Editor\";}}s:32:\"Widget_Abstract_Contents:content\";a:1:{i:0;a:2:{i:0;s:15:\"EditorMD_Plugin\";i:1;s:7:\"content\";}}s:32:\"Widget_Abstract_Contents:excerpt\";a:1:{i:0;a:2:{i:0;s:15:\"EditorMD_Plugin\";i:1;s:7:\"excerpt\";}}s:21:\"Widget_Archive:footer\";a:1:{i:0;a:2:{i:0;s:15:\"EditorMD_Plugin\";i:1;s:8:\"footerJS\";}}}}}s:7:\"handles\";a:5:{s:31:\"admin/write-post.php:richEditor\";a:1:{i:0;a:2:{i:0;s:15:\"EditorMD_Plugin\";i:1;s:6:\"Editor\";}}s:31:\"admin/write-page.php:richEditor\";a:1:{i:0;a:2:{i:0;s:15:\"EditorMD_Plugin\";i:1;s:6:\"Editor\";}}s:32:\"Widget_Abstract_Contents:content\";a:1:{i:0;a:2:{i:0;s:15:\"EditorMD_Plugin\";i:1;s:7:\"content\";}}s:32:\"Widget_Abstract_Contents:excerpt\";a:1:{i:0;a:2:{i:0;s:15:\"EditorMD_Plugin\";i:1;s:7:\"excerpt\";}}s:21:\"Widget_Archive:footer\";a:1:{i:0;a:2:{i:0;s:15:\"EditorMD_Plugin\";i:1;s:8:\"footerJS\";}}}}'),('commentDateFormat',0,'F jS, Y \\a\\t h:i a'),('siteUrl',0,'http://www.fxjson.com'),('defaultCategory',0,'1'),('allowRegister',0,'1'),('defaultAllowComment',0,'1'),('defaultAllowPing',0,'1'),('defaultAllowFeed',0,'1'),('pageSize',0,'13'),('postsListSize',0,'13'),('commentsListSize',0,'10'),('commentsHTMLTagAllowed',0,NULL),('postDateFormat',0,'Y-m-d'),('feedFullText',0,'1'),('editorSize',0,'350'),('autoSave',0,'0'),('markdown',0,'1'),('xmlrpcMarkdown',0,'0'),('commentsMaxNestingLevels',0,'5'),('commentsPostTimeout',0,'2592000'),('commentsUrlNofollow',0,'1'),('commentsShowUrl',0,'1'),('commentsMarkdown',0,'0'),('commentsPageBreak',0,'0'),('commentsThreaded',0,'1'),('commentsPageSize',0,'20'),('commentsPageDisplay',0,'last'),('commentsOrder',0,'ASC'),('commentsCheckReferer',0,'1'),('commentsAutoClose',0,'0'),('commentsPostIntervalEnable',0,'1'),('commentsPostInterval',0,'60'),('commentsShowCommentOnly',0,'0'),('commentsAvatar',0,'1'),('commentsAvatarRating',0,'G'),('commentsAntiSpam',0,'1'),('routingTable',0,'a:26:{i:0;a:25:{s:5:\"index\";a:6:{s:3:\"url\";s:1:\"/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:8:\"|^[/]?$|\";s:6:\"format\";s:1:\"/\";s:6:\"params\";a:0:{}}s:7:\"archive\";a:6:{s:3:\"url\";s:6:\"/blog/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:13:\"|^/blog[/]?$|\";s:6:\"format\";s:6:\"/blog/\";s:6:\"params\";a:0:{}}s:2:\"do\";a:6:{s:3:\"url\";s:22:\"/action/[action:alpha]\";s:6:\"widget\";s:9:\"Widget_Do\";s:6:\"action\";s:6:\"action\";s:4:\"regx\";s:32:\"|^/action/([_0-9a-zA-Z-]+)[/]?$|\";s:6:\"format\";s:10:\"/action/%s\";s:6:\"params\";a:1:{i:0;s:6:\"action\";}}s:4:\"post\";a:6:{s:3:\"url\";s:24:\"/archives/[cid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:26:\"|^/archives/([0-9]+)[/]?$|\";s:6:\"format\";s:13:\"/archives/%s/\";s:6:\"params\";a:1:{i:0;s:3:\"cid\";}}s:10:\"attachment\";a:6:{s:3:\"url\";s:26:\"/attachment/[cid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:28:\"|^/attachment/([0-9]+)[/]?$|\";s:6:\"format\";s:15:\"/attachment/%s/\";s:6:\"params\";a:1:{i:0;s:3:\"cid\";}}s:8:\"category\";a:6:{s:3:\"url\";s:17:\"/category/[slug]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:25:\"|^/category/([^/]+)[/]?$|\";s:6:\"format\";s:13:\"/category/%s/\";s:6:\"params\";a:1:{i:0;s:4:\"slug\";}}s:3:\"tag\";a:6:{s:3:\"url\";s:12:\"/tag/[slug]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:20:\"|^/tag/([^/]+)[/]?$|\";s:6:\"format\";s:8:\"/tag/%s/\";s:6:\"params\";a:1:{i:0;s:4:\"slug\";}}s:6:\"author\";a:6:{s:3:\"url\";s:22:\"/author/[uid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:24:\"|^/author/([0-9]+)[/]?$|\";s:6:\"format\";s:11:\"/author/%s/\";s:6:\"params\";a:1:{i:0;s:3:\"uid\";}}s:6:\"search\";a:6:{s:3:\"url\";s:19:\"/search/[keywords]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:23:\"|^/search/([^/]+)[/]?$|\";s:6:\"format\";s:11:\"/search/%s/\";s:6:\"params\";a:1:{i:0;s:8:\"keywords\";}}s:10:\"index_page\";a:6:{s:3:\"url\";s:21:\"/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:22:\"|^/page/([0-9]+)[/]?$|\";s:6:\"format\";s:9:\"/page/%s/\";s:6:\"params\";a:1:{i:0;s:4:\"page\";}}s:12:\"archive_page\";a:6:{s:3:\"url\";s:26:\"/blog/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:27:\"|^/blog/page/([0-9]+)[/]?$|\";s:6:\"format\";s:14:\"/blog/page/%s/\";s:6:\"params\";a:1:{i:0;s:4:\"page\";}}s:13:\"category_page\";a:6:{s:3:\"url\";s:32:\"/category/[slug]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:34:\"|^/category/([^/]+)/([0-9]+)[/]?$|\";s:6:\"format\";s:16:\"/category/%s/%s/\";s:6:\"params\";a:2:{i:0;s:4:\"slug\";i:1;s:4:\"page\";}}s:8:\"tag_page\";a:6:{s:3:\"url\";s:27:\"/tag/[slug]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:29:\"|^/tag/([^/]+)/([0-9]+)[/]?$|\";s:6:\"format\";s:11:\"/tag/%s/%s/\";s:6:\"params\";a:2:{i:0;s:4:\"slug\";i:1;s:4:\"page\";}}s:11:\"author_page\";a:6:{s:3:\"url\";s:37:\"/author/[uid:digital]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:33:\"|^/author/([0-9]+)/([0-9]+)[/]?$|\";s:6:\"format\";s:14:\"/author/%s/%s/\";s:6:\"params\";a:2:{i:0;s:3:\"uid\";i:1;s:4:\"page\";}}s:11:\"search_page\";a:6:{s:3:\"url\";s:34:\"/search/[keywords]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:32:\"|^/search/([^/]+)/([0-9]+)[/]?$|\";s:6:\"format\";s:14:\"/search/%s/%s/\";s:6:\"params\";a:2:{i:0;s:8:\"keywords\";i:1;s:4:\"page\";}}s:12:\"archive_year\";a:6:{s:3:\"url\";s:18:\"/[year:digital:4]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:19:\"|^/([0-9]{4})[/]?$|\";s:6:\"format\";s:4:\"/%s/\";s:6:\"params\";a:1:{i:0;s:4:\"year\";}}s:13:\"archive_month\";a:6:{s:3:\"url\";s:36:\"/[year:digital:4]/[month:digital:2]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:30:\"|^/([0-9]{4})/([0-9]{2})[/]?$|\";s:6:\"format\";s:7:\"/%s/%s/\";s:6:\"params\";a:2:{i:0;s:4:\"year\";i:1;s:5:\"month\";}}s:11:\"archive_day\";a:6:{s:3:\"url\";s:52:\"/[year:digital:4]/[month:digital:2]/[day:digital:2]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:41:\"|^/([0-9]{4})/([0-9]{2})/([0-9]{2})[/]?$|\";s:6:\"format\";s:10:\"/%s/%s/%s/\";s:6:\"params\";a:3:{i:0;s:4:\"year\";i:1;s:5:\"month\";i:2;s:3:\"day\";}}s:17:\"archive_year_page\";a:6:{s:3:\"url\";s:38:\"/[year:digital:4]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:33:\"|^/([0-9]{4})/page/([0-9]+)[/]?$|\";s:6:\"format\";s:12:\"/%s/page/%s/\";s:6:\"params\";a:2:{i:0;s:4:\"year\";i:1;s:4:\"page\";}}s:18:\"archive_month_page\";a:6:{s:3:\"url\";s:56:\"/[year:digital:4]/[month:digital:2]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:44:\"|^/([0-9]{4})/([0-9]{2})/page/([0-9]+)[/]?$|\";s:6:\"format\";s:15:\"/%s/%s/page/%s/\";s:6:\"params\";a:3:{i:0;s:4:\"year\";i:1;s:5:\"month\";i:2;s:4:\"page\";}}s:16:\"archive_day_page\";a:6:{s:3:\"url\";s:72:\"/[year:digital:4]/[month:digital:2]/[day:digital:2]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:55:\"|^/([0-9]{4})/([0-9]{2})/([0-9]{2})/page/([0-9]+)[/]?$|\";s:6:\"format\";s:18:\"/%s/%s/%s/page/%s/\";s:6:\"params\";a:4:{i:0;s:4:\"year\";i:1;s:5:\"month\";i:2;s:3:\"day\";i:3;s:4:\"page\";}}s:12:\"comment_page\";a:6:{s:3:\"url\";s:53:\"[permalink:string]/comment-page-[commentPage:digital]\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:36:\"|^(.+)/comment\\-page\\-([0-9]+)[/]?$|\";s:6:\"format\";s:18:\"%s/comment-page-%s\";s:6:\"params\";a:2:{i:0;s:9:\"permalink\";i:1;s:11:\"commentPage\";}}s:4:\"feed\";a:6:{s:3:\"url\";s:20:\"/feed[feed:string:0]\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:4:\"feed\";s:4:\"regx\";s:17:\"|^/feed(.*)[/]?$|\";s:6:\"format\";s:7:\"/feed%s\";s:6:\"params\";a:1:{i:0;s:4:\"feed\";}}s:8:\"feedback\";a:6:{s:3:\"url\";s:31:\"[permalink:string]/[type:alpha]\";s:6:\"widget\";s:15:\"Widget_Feedback\";s:6:\"action\";s:6:\"action\";s:4:\"regx\";s:29:\"|^(.+)/([_0-9a-zA-Z-]+)[/]?$|\";s:6:\"format\";s:5:\"%s/%s\";s:6:\"params\";a:2:{i:0;s:9:\"permalink\";i:1;s:4:\"type\";}}s:4:\"page\";a:6:{s:3:\"url\";s:12:\"/[slug].html\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:22:\"|^/([^/]+)\\.html[/]?$|\";s:6:\"format\";s:8:\"/%s.html\";s:6:\"params\";a:1:{i:0;s:4:\"slug\";}}}s:5:\"index\";a:3:{s:3:\"url\";s:1:\"/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:7:\"archive\";a:3:{s:3:\"url\";s:6:\"/blog/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:2:\"do\";a:3:{s:3:\"url\";s:22:\"/action/[action:alpha]\";s:6:\"widget\";s:9:\"Widget_Do\";s:6:\"action\";s:6:\"action\";}s:4:\"post\";a:3:{s:3:\"url\";s:24:\"/archives/[cid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:10:\"attachment\";a:3:{s:3:\"url\";s:26:\"/attachment/[cid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:8:\"category\";a:3:{s:3:\"url\";s:17:\"/category/[slug]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:3:\"tag\";a:3:{s:3:\"url\";s:12:\"/tag/[slug]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:6:\"author\";a:3:{s:3:\"url\";s:22:\"/author/[uid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:6:\"search\";a:3:{s:3:\"url\";s:19:\"/search/[keywords]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:10:\"index_page\";a:3:{s:3:\"url\";s:21:\"/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:12:\"archive_page\";a:3:{s:3:\"url\";s:26:\"/blog/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:13:\"category_page\";a:3:{s:3:\"url\";s:32:\"/category/[slug]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:8:\"tag_page\";a:3:{s:3:\"url\";s:27:\"/tag/[slug]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:11:\"author_page\";a:3:{s:3:\"url\";s:37:\"/author/[uid:digital]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:11:\"search_page\";a:3:{s:3:\"url\";s:34:\"/search/[keywords]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:12:\"archive_year\";a:3:{s:3:\"url\";s:18:\"/[year:digital:4]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:13:\"archive_month\";a:3:{s:3:\"url\";s:36:\"/[year:digital:4]/[month:digital:2]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:11:\"archive_day\";a:3:{s:3:\"url\";s:52:\"/[year:digital:4]/[month:digital:2]/[day:digital:2]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:17:\"archive_year_page\";a:3:{s:3:\"url\";s:38:\"/[year:digital:4]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:18:\"archive_month_page\";a:3:{s:3:\"url\";s:56:\"/[year:digital:4]/[month:digital:2]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:16:\"archive_day_page\";a:3:{s:3:\"url\";s:72:\"/[year:digital:4]/[month:digital:2]/[day:digital:2]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:12:\"comment_page\";a:3:{s:3:\"url\";s:53:\"[permalink:string]/comment-page-[commentPage:digital]\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:4:\"feed\";a:3:{s:3:\"url\";s:20:\"/feed[feed:string:0]\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:4:\"feed\";}s:8:\"feedback\";a:3:{s:3:\"url\";s:31:\"[permalink:string]/[type:alpha]\";s:6:\"widget\";s:15:\"Widget_Feedback\";s:6:\"action\";s:6:\"action\";}s:4:\"page\";a:3:{s:3:\"url\";s:12:\"/[slug].html\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}}'),('actionTable',0,'a:0:{}'),('panelTable',0,'a:0:{}'),('attachmentTypes',0,'@image@'),('secret',0,'wB8I4jNeq6BIJS)thHpxFs#vZb(C0qb)'),('installed',0,'1'),('allowXmlRpc',0,'0'),('plugin:EditorMD',0,'a:7:{s:5:\"emoji\";s:1:\"1\";s:8:\"isActive\";s:1:\"1\";s:5:\"isToc\";s:1:\"1\";s:6:\"isTask\";s:1:\"1\";s:5:\"isTex\";s:1:\"1\";s:6:\"isFlow\";s:1:\"0\";s:5:\"isSeq\";s:1:\"0\";}'),('editorSize',2,'350'),('theme:simple',0,'a:4:{s:8:\"subtitle\";s:30:\"专注软件开发技术分享\";s:5:\"links\";s:0:\"\";s:5:\"beian\";s:63:\"<a href=\'http://www.beian.miit.gov.cn\'>京ICP备20025536号</a>\";s:4:\"stat\";s:281:\"<script>\r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"https://hm.baidu.com/hm.js?d9748d9096d17d67396b4b345eb95e5f\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n</script>\r\n\";}');
/*!40000 ALTER TABLE `tbl_options` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tbl_relationships`
--

DROP TABLE IF EXISTS `tbl_relationships`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tbl_relationships` (
  `cid` int(10) unsigned NOT NULL,
  `mid` int(10) unsigned NOT NULL,
  PRIMARY KEY (`cid`,`mid`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tbl_relationships`
--

LOCK TABLES `tbl_relationships` WRITE;
/*!40000 ALTER TABLE `tbl_relationships` DISABLE KEYS */;
INSERT INTO `tbl_relationships` VALUES (1,1),(4,1),(5,1),(6,1),(7,1),(8,1),(9,1),(10,1),(11,1),(12,5),(13,5),(14,1),(15,1),(16,5),(17,1),(18,1),(19,1),(20,1),(21,1),(22,1),(23,5),(24,1),(25,6),(26,1),(27,1),(28,1),(33,1),(34,1),(35,1),(36,1),(37,1),(38,5),(40,1),(42,1),(43,1),(44,1),(46,1),(47,1),(48,1),(49,1),(50,1),(52,1),(53,1),(54,1),(55,1),(56,1),(57,1),(58,1),(59,1),(61,1),(62,1),(63,1),(64,1),(65,1),(66,1),(67,1),(68,1),(69,1),(70,1),(71,1),(72,1),(73,1),(74,7),(75,1),(75,5),(76,5),(76,8),(76,9),(77,5),(77,9),(78,1),(79,1),(81,5),(82,5),(82,10),(82,11),(83,1),(86,1),(87,1),(88,1),(89,5),(97,5),(99,7),(100,1),(101,1),(102,1),(104,1),(105,1),(106,5),(121,1),(122,1),(123,1),(124,1),(125,5);
/*!40000 ALTER TABLE `tbl_relationships` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tbl_users`
--

DROP TABLE IF EXISTS `tbl_users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tbl_users` (
  `uid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(32) DEFAULT NULL,
  `password` varchar(64) DEFAULT NULL,
  `mail` varchar(200) DEFAULT NULL,
  `url` varchar(200) DEFAULT NULL,
  `screenName` varchar(32) DEFAULT NULL,
  `created` int(10) unsigned DEFAULT '0',
  `activated` int(10) unsigned DEFAULT '0',
  `logged` int(10) unsigned DEFAULT '0',
  `group` varchar(16) DEFAULT 'visitor',
  `authCode` varchar(64) DEFAULT NULL,
  PRIMARY KEY (`uid`),
  UNIQUE KEY `name` (`name`),
  UNIQUE KEY `mail` (`mail`)
) ENGINE=MyISAM AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tbl_users`
--

LOCK TABLES `tbl_users` WRITE;
/*!40000 ALTER TABLE `tbl_users` DISABLE KEYS */;
INSERT INTO `tbl_users` VALUES (1,'admin','$P$BcvvtQ2rnqnseN40fjgrWr1V2D9nOA.','fanqingxuan@163.com','http://www.typecho.org','admin',1591518525,1618632884,1615098347,'administrator','cb143a3de0023a56792aad9a2f845a1b'),(2,'json','$P$BFKrQ3uBBA7U4.CpgZcA9oRyk6AqRr.','hdbkxxfw@163.com','https://github.com/fanqingxuan','json',1591533228,1647498016,1646664452,'editor','6c384ebf3c174828fb1a88b4d005a3b8');
/*!40000 ALTER TABLE `tbl_users` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2022-06-11 18:04:42
